Обзор проекта mirmik/termin (TECHNICAL_NOTES)
Обзор директорий
    • termin/editor – Приложения и утилиты на базе движка. Содержит запуск редактора (run_editor.py) и файлы интерфейса редактора (например, editor_window.py, editor_tree.py, editor_inspector.py).
    • termin/visualization – Подсистема визуализации 3D-сцены. Включает ядро рендеринга (сцена, сущности, компоненты, рендерер, граф кадров), графический бэкенд (OpenGL/Qt/GLFW), материалы и шейдеры, систему пост-эффектов и утилиты для отображения (камеры, контроллеры, gизмо и пр.).
    • termin/kinematic – Кинематические структуры и трансформации. Определяет иерархические трансформы (Transform, Transform3), позволяющие строить сцену как дерево трансформаций, и связанные алгоритмы (например, кинематические цепи).
    • termin/geombase – Базовые геометрические примитивы и алгебры. Содержит классы позиций/ориентаций (Pose3 – комбинация кватерниона и вектора трансляции) и базовые операции с ними (например, умножение поз, преобразование точек).
    • termin/mesh – Работа с полигональными мешами. Реализует структуры для 2D/3D сеток (Mesh2, Mesh3), генераторы простых форм (например, CubeMesh, CylinderMesh) и функции импорта (через Assimp).
    • termin/colliders – Коллизии и пересечения. Определяет компоненты-коллайдеры (ColliderComponent) и формы (сферы, лучи и др.), поддерживает расчёт пересечений/лучевых бросков в сцене (см. методы Scene.raycast()).
    • termin/physics – Модуль физики (возможно экспериментальный). Содержит зачатки физического движка (например, динамические тела, силы) – сейчас расположен в архиве проекта и не активно используется.
    • termin/fem – Реализация элементов конечных элементов (Finite Element Method) и связанных алгоритмов (например, расчёты для многотельных систем).
    • termin/geomalgo – Геометрические алгоритмы высокого уровня (вычислительная геометрия, операции над примитивами и т.п.).
    • termin/linalg – Вспомогательная линейная алгебра (возможно, утилиты для работы с матрицами, векторами, кватернионами и т.д.).
    • termin/robot – Компоненты для робототехники и кинематики роботов (например, класс Robot, расчет прямой/обратной кинематики).
    • termin/loaders – Импортеры внешних форматов и моделей (например, загрузчик FBX, OBJ и др. через pyassimp).
    • termin/utils – Разные утилиты и вспомогательные функции, включая работу с кватернионами (termin/util.py предоставляет операции qmul, qrot и пр., используемые в Pose3).
Карта ключевых классов
    • Scene (termin/visualization/core/scene.py): Класс сцены – контейнер всех сущностей. Хранит список entities и глобальные параметры (цвет фона, освещение). Отвечает за добавление/удаление объектов, регистрацию компонентов (в т.ч. коллайдеров и интерактивных компонентов) и обновление их логики каждый кадр. Методы add/remove управляют иерархией сущностей и автоматически регистрируют компоненты в соответствующих списках (коллайдеры, апдейты и т.д.).
    • Entity (termin/visualization/core/entity.py): Сущность сцены (объект) с компонентной архитектурой (аналог Unity GameObject). Содержит трансформ (transform: Transform3), список компонентов и свойства видимости/активности. Предоставляет методы управления компонентами (add_component, remove_component), поиска компонентов, обновления и отрисовки. Метод Entity.draw(context) обходит все компоненты и вызывает их draw, если объект активен.
    • Component (termin/visualization/core/entity.py): Базовый класс компонента сущности (отрисовываемого или логического). Хранит ссылку на владельца (self.entity), флаг активности (enabled). Определяет интерфейсы: start() (вызвается при добавлении в активную сцену), update(dt) для обновления каждый кадр, draw(context) для рендеринга. Разновидности компонентов могут переопределять эти методы.
    • MeshRenderer (termin/visualization/render/components/mesh_renderer.py): Компонент-отрисовщик меша. Хранит ссылку на геометрию (mesh: MeshDrawable) и материал(ы) для рендера. Поддерживает несколько проходов рендеринга: свойство passes – список RenderPass (каждый содержит материал и состояние рендера). В методе draw применяет для каждого пасса нужное состояние (RenderState – глубина, режим отрисовки и т.п.), устанавливает материал (шейдер и униформы), затем рисует меш. После отрисовки сбрасывает состояние к дефолтному.
    • RenderPass (termin/visualization/render/renderpass.py): Структура, описывающая материал и состояние рендеринга для одного прохода отрисовки. Содержит ссылку на материал (Material) и конфигурацию графического состояния (RenderState – параметры тестов глубины, смешивания, отсекающей поверхности и пр.). Используется компонентами-отрисовщиками (например, в MeshRenderer.passes) для задания нескольких этапов вывода одного объекта (например, сначала непрозрачный материал, затем контур и т.п.).
    • CameraComponent и контроллеры камер (termin/visualization/core/camera.py): Компоненты, отвечающие за матрицы вида/проекции. Например, PerspectiveCameraComponent – перспективная камера с расчётом матриц, а OrbitCameraController – компонент-ввод, позволяющий вращать/приближать камеру орбитально вокруг цели. Камеры являются тоже компонентами Entity, что позволяет добавлять их в сцену.
    • Window (termin/visualization/platform/window.py): Абстракция оконного контекста. Создаётся через бэкенд (WindowBackend – Qt или GLFW) и держит нативное окно или виджет. Содержит список вьюпортов (экземпляры Viewport) – областей отображения сцены. Следит за событиями ввода (мышь, клавиатура) и делегирует их компонентам (Scene.dispatch_input распространяет события интерактивным компонентам). Имеет метод render(), который запускает рендеринг всех вьюпортов, собирая их конвейеры рендеринга и выполняя граф кадра.
    • Viewport (termin/visualization/core/viewport.py): Представление сцены в окне, связка из указателя на scene, camera и прямоугольника в окне. Имеет собственный список проходов frame_passes – конвейер рендеринга кадра для данного вида. Метод Viewport.make_default_pipeline() собирает типовой набор проходов (Color → PostFX → Canvas → Present), а set_render_pipeline(passes) применяется для установки пользовательского конвейера.
    • FrameGraph (termin/visualization/render/framegraph/core.py): Класс, реализующий граф зависимостей ресурсов кадра. На вход получает список объектов FramePass (каждый описывает один этап рендеринга) и вычисляет их порядок выполнения с учётом зависимостей «чтение после записи». Проверяет на ошибки: несколько пассов пишущих один ресурс, циклы зависимостей, правила in-place пассов (изменяющих ресурс на месте). Результат – упорядоченный список пассов (schedule) для выполнения.
    • FramePass (termin/visualization/render/framegraph/core.py): Структура одного этапа графа кадра. Содержит имя пасса, множество ресурсов reads (читаемых) и writes (писаемых), а также флаг inplace (модифицирует ли ресурс на месте). От FramePass наследуется RenderFramePass (termin/visualization/render/framegraph/passes/base.py), добавляющий абстрактный метод execute(self, ctx) – реализацию действия пасса над контекстом кадра.
    • Renderer (termin/visualization/render/renderer.py): Класс-отрисовщик сцены. Экземпляр Renderer создаётся в мире визуализации и привязан к графическому бэкенду (OpenGL). Предоставляет методы для отрисовки содержимого вьюпорта: render_viewport(scene, camera, viewport_rect, key) – подготавливает камеру (устанавливает viewport, собирает матрицы вида/проекции), затем обходит все Entity в сцене и вызывает у них draw (что в итоге вызывает draw компонентов). Таким образом Renderer выполняет главный проход рисования мира. Также есть специальный render_viewport_pick – отрисовка сцены в режим идентификаторов для picking (см. ниже).
    • VisualizationWorld (termin/visualization/core/world.py): Глобальный управляющий объект приложения. Хранит список сцен и окон, а также экземпляр Renderer. Предоставляет методы add_scene, create_window и управляет главным циклом (run()) – обновляет все сцены (вызов Scene.update(dt) для компонентов каждый кадр) и запускает отрисовку окон.
(Кроме того, проект содержит множество других классов: системы материалов и шейдеров, бэкенды (termin/visualization/platform/backends), примеры использования в examples/, но выше перечислены ключевые сущности для понимания структуры.)
Архитектура редактора Termin
Редактор – это встроенное приложение (PyQt5) для визуального управления сценой. Он расположен в модуле termin/editor и включает следующие основные компоненты:
    • Окно редактора (EditorWindow, файл termin/editor/editor_window.py) – Главный класс UI на основе QMainWindow. Загружает разметку интерфейса из Qt Designer (editor.ui) и содержит области: дерево сцены (QTreeView), панель инспектора и контейнер для виджета viewport. При инициализации получает текущий world (VisualizationWorld) и scene, подсоединяет их к виджету отображения и настраивает взаимодействие. В конструкторе EditorWindow:
    • Загружает UI, инициализирует sceneTree (виджет иерархии) с моделью SceneTreeModel.
    • Создаёт EntityInspector для панели свойств и настраивает библиотеку компонентов, доступных для добавления (регистрация стандартных компонентов камеры, контроллера, меш-рендерера).
    • Добавляет в сцену служебные объекты редактора: EditorEntities (контейнер), под которым создаётся своя камера редактора и объект gizmo (манипулятор). Gizmo представлен классами GizmoEntity и GizmoMoveController (в termin.editor.gizmo_axes), которые отвечают за отображение осей и перемещение выделенного объекта.
    • Выстраивает связи сигналов/слотов Qt: например, при клике по дереву сцены вызывает обработчик on_tree_click для обновления инспектора и выделения объекта.
    • Дерево сцены (SceneTreeModel, файл termin/editor/editor_tree.py) – Модель данных Qt, отражающая иерархию сущностей сцены. Построена на основе дерева Transform3: в дереве показываются только объекты Entity (Transform-узлы пропущены). Модель обеспечивает методы index/parent для Qt и функцию index_for_object(obj) – найти QModelIndex по объекту сцены, что позволяет, например, выделить в дереве сущность, на которую пользователь кликнул в viewport.
    • Панель инспектора: состоит из нескольких частей, объединённых классом EntityInspector (termin/editor/editor_inspector.py). EntityInspector (QWidget) содержит вертикально:
    • TransformInspector – виджет для редактирования трансформации (позиция, вращение, масштаб) выделенного объекта. Он привязывается либо к Entity.transform, либо прямо к Transform3, если выделен узел трансформации. Реализован в termin/editor/transform_inspector.py: три ряда QDoubleSpinBox для XYZ позиции, вращения и масштаба, обновляющие Transform3 и испускающие сигнал transform_changed.
    • ComponentsPanel – список компонентов текущего объекта. Отображает имена всех ent.components и позволяет через контекстное меню добавлять новый компонент (из зарегистрированной библиотеки) или удалять существующий. При добавлении/удалении он испускает сигнал components_changed.
    • ComponentInspectorPanel – инспектор свойств выбранного компонента. Отображает поля из Component.inspect_fields (если определены компонентом) динамически, создавая для каждого поля соответствующий UI элемент (числовые спинбоксы, чекбоксы, текстовые поля и т.д.). Изменения значений вызывают обновление компонента (через setter-функции, если заданы). Испускает сигнал component_changed при модификации.
EntityInspector управляет синхронизацией этих панелей: метод set_target(obj) устанавливает текущую цель (Entity или Transform3) – обновляет TransformInspector и список компонентов, сбрасывает компонент-инспектор. При выборе компонента из списка вызывается _on_component_selected, который передаёт этот компонент в ComponentInspectorPanel для отображения его полей. Сигналы от вложенных панелей транслируются наружу (transform_changed, component_changed). В итоге панель инспектора обеспечивает редактирование всех аспектов выбранного объекта.
    • Gizmo (манипулятор) – Специальный объект для манипуляции трансформацией выделенной сущности. Создаётся EditorWindow при старте и добавляется в сцену под родителем EditorEntities. Класс GizmoEntity представляет визуальные оси и плоскости, а компонент GizmoMoveController обрабатывает события ввода (drag-n-drop) для перемещения/вращения выделенного объекта. Когда меняется выбор, EditorWindow вызывает gizmo.find_component(GizmoMoveController).set_target(selected_ent), тем самым задавая, к какому объекту привязан манипулятор. Gizmo не является выбираемым (selectable=False), чтобы не перехватывать выделение пользователя.
    • Виджет viewport – область визуализации 3D-сцены внутри окна редактора. EditorWindow интегрирует движок рендеринга в Qt: при инициализации вызывается world.create_window(parent=self.viewportContainer), что создаёт окно рендеринга на базе Qt (через QtWindowBackend) и возвращает объект Window. Затем добавляется вьюпорт: self.viewport = viewport_window.add_viewport(self.scene, self.camera) – привязка текущей сцены и редакторской камеры к вьюпорту. Полученный OpenGL-виджет (viewport_window.handle.widget) вставляется в макет Qt-интерфейса.
    • Обработка ввода и выбор объектов: EditorWindow переключает окно в режим "editor" (viewport_window.set_world_mode("editor")) – это включает генерацию буфера идентификаторов (ID buffer) для подбора объектов. В EditorWindow настраиваются коллбеки: viewport_window.on_mouse_button_event = self.mouse_button_event, on_mouse_move_event = self.mouse_moved, а after_render_handler = self._after_render. При движении курсора метод mouse_moved просто запоминает координаты для hover-pick. В after_render (вызывается после каждого кадра) редактор выполняет скрытый рендер-проход picking’a, читает ID под курсором и определяет hover_entity_id – идентификатор сущности под мышью, затем вызывает _request_update() для перерисовки с подсветкой. Щелчок мыши (mouse press) аналогично запускает чтение ID и обновляет selected_entity_id – идентификатор выбранной сущности. Далее происходит вызов on_selection_changed, который помимо установки gizmo, находит сам Entity по ID (через Window) и обновляет выделение в дереве сцены (_select_object_in_tree) и инспекторе. Таким образом реализовано интерактивное выделение объектов в viewport.
    • Конвейер рендеринга редактора: в отличие от простого приложения, редактор использует расширенный граф рендеринга для поддержки выделения и подсветки. EditorWindow переопределяет конвейер вьюпорта через viewport.set_render_pipeline(self.make_pipeline()). Метод make_pipeline() собирает список пассов:
    • ColorPass – основной проход цвета сцены (пишет ресурс "color", рисует все видимые объекты).
    • IdPass – проход генерации ID-буфера (пишет ресурс "preid", читая "empty_id"). Он использует Renderer.render_viewport_pick для отрисовки всех MeshRenderer объектов с уникальными цветами, сохраняя ссылки Entity→ID внутри Window.
    • GizmoPass – дополнительный проход для корректировки ID-буфера с учётом Gizmo. Этот пасс читает промежуточный буфер "preid" и пишет итоговый "id", одновременно рисуя геометрию gizmo особым образом (только в альфа-канале). Это нужно, чтобы детали манипулятора не мешали подсветке: GizmoPass помечает пиксели gizmo, изменяя альфа, но не меняя RGB ID-карты.
    • PostProcessPass (назван "PostFX") – пасс постобработки цвета. Берёт на вход "color" и выдаёт "color_pp". Содержит цепочку PostEffect-эффектов, которая настраивается далее. В редакторе сразу после создания пасса добавляются два эффекта HighlightEffect – для hover и для selected. Класс HighlightEffect (termin/visualization/render/posteffects/highlight.py) – пост-эффект, выделяющий границы выбранного/подсвеченного объекта цветной рамкой. Он запрашивает ресурс "id" (ID-карта сцены), сравнивает каждый пиксель ID с заданным ID объекта и рисует контур вокруг областей совпадения (жёлтый для выбранного, голубой для подсвеченного). Эти эффекты делают визуальную подсветку выделенного объекта и объекта под курсором.
    • CanvasPass – проход наложения UI. Берёт результат цвета с постэффектами ("color_pp") и выводит "color+ui". Если у вьюпорта задан canvas (например, для отрисовки 2D-элементов интерфейса поверх 3D), CanvasPass вызовет viewport.canvas.render() для рисования этих элементов. В редакторе canvas обычно не используется, но пасс включён для общности.
    • PresentToScreenPass – финальный пасс вывода на экран. Берёт комбинированный буфер ("color+ui") и отображает в окно (осуществляет blit в системный framebuffer).
Такой пайплайн обеспечивает: отрисовку сцены, получение ID-карты для интерактивности, маскирование gizmo, наложение подсветки и вывод результата. FrameGraph внутри Window выстраивает зависимости этих пассов (например, что GizmoPass и HighlightEffect зависят от ресурса "id" от IdPass, а постэффект зависит от "color") и выполняет их в нужном порядке.
Архитектура графического пайплайна Termin
Основной графический конвейер построен вокруг FrameGraph (графа кадра) и набора FramePass (проходов). Этот механизм обеспечивает гибкую конфигурацию этапов рендеринга для каждого вьюпорта: можно добавлять/удалять пассы (например, пост-эффекты, буфер picking’а и пр.) без жёсткого сценария. Ниже — ключевые элементы этого пайплайна:
    • FramePass и FrameGraph – Каждый проход кадра (FramePass) декларирует, какие именованные ресурсы (текстуры/буферы кадра) он читает и пишет. Например, ColorPass пишет ресурс "color", читая "empty" (заглушку начала графа). FrameGraph собирает все пассы в граф зависимостей: если пасс B читает ресурс, который пишет пасс A, то установится зависимость A→B. Метод FrameGraph.build_schedule() выполняет топологическую сортировку, разделяя inplace-проходы (которые помечены как inplace=True, то есть модифицируют ресурс на месте) и контролируя, что один ресурс пишется только одним пассом. Результат — упорядоченный список, по которому будет выполнен рендеринг кадра.
    • Подготовка ресурсов графа – Перед выполнением графа Window строит schedule через FrameGraph и по группам алиасов создаёт/ресайзит FBO (viewport.get_viewport_fbo). Все полученные FBO кладутся в viewport.fbos под всеми именами группы, чтобы дальнейшие этапы работали с единственными экземплярами.
• Реализация проходов (RenderFramePass) – Каждый конкретный проход рендеринга – класс, наследующий RenderFramePass, реализует метод execute(self, graphics, reads_fbos, writes_fbos, rect, scene, camera, renderer, context_key, ...). Вместо общего контекста в execute прилетают только нужные зависимости: графический бэкенд, прямоугольник вывода, сцена и камера текущего вьюпорта, renderer и две карты FBO (для чтения и записи), отфильтрованные по reads|writes данного пасса. Дополнительно прокидываются lights и canvas. Благодаря этому зависимости явны, а пасс не лезет сам в Window за ресурсами.
• Для вывода на экран зарезервирован ресурс DISPLAY: PresentToScreenPass объявляет его в writes, а окно подставляет handle оконного FBO вместо отдельного буфера в пуле viewport'а.
    • ColorPass – Очищает буфер цвета и вызывает window.renderer.render_viewport(...) для отрисовки всей сцены текущей камерой в привязанный FBO. Этот пасс отвечает за основную геометрию. Помечен inplace=True, так как обновляет ресурс "color" на месте.
    • IdPass – Создаёт буфер идентификаторов для picking. Перед выполнением Window назначает FBO для "id" ресурса. В execute IdPass очищает его и проходится по всем сущностям сцены: для каждого видимого и pickable объекта берёт уникальный ID из свойства Entity.pick_id и использует его при окраске. RenderViewportPick в Renderer отрисовывает только компоненты MeshRenderer, заливая каждую меш-геометрию плоским цветом, закодированным под ID. В итоге в текстуру "id" записываются уникальные цвета идентификаторов (RGB).
    • PostProcessPass – Универсальный пасс постобработки. Инициализируется с цепочкой эффектов (объекты, наследующие PostEffect) и входным/выходным ресурсами. В execute этот пасс реализует применение N эффектов последовательно, используя технику ping-pong: если один эффект – рисует сразу в целевой FBO, если несколько – чередует два временных FBO. Каждый PostEffect получает на вход текущую текстуру цвета, словарь extra_textures (доп. ресурсы, которые эффект запросил через required_resources()), размер кадра и ключ контекста. Затем эффект должен настроить шейдер и нарисовать полноэкранный квад, применяя свой фильтр. По завершении цепочки PostProcessPass возвращает глубинный буфер в нормальное состояние (включает тест глубины обратно).
    • Примеры пост-эффектов: HighlightEffect (описан выше) накладывает цветной контур на выбранные объекты с использованием буфера "id". Другие эффекты могут быть, например, GrayscaleEffect (оттенки серого) и т.п. – они обычно лежат в termin/visualization/render/posteffects/* и реализуют свой метод draw.
    • CanvasPass – Пасс-компоновщик UI. Он помечен inplace=True и читает, например, ресурс "color_pp", а пишет "color+ui". В execute он просто биндит выходной FBO и вызывает рендер 2D-канвы (если задана). Как правило, CanvasPass используется для наложения элементов интерфейса (текст, иконки) поверх 3D.
    • PresentToScreenPass – Финальный пасс графа, который берёт указанный ресурс (обычно комбинированный цвет+UI) и выводит на экран. Реализован, вероятно, внутри Window: после выполнения всех пассов Window берет конечный FBO и делает swap_buffers() для отображения. (В коде PresentToScreenPass просто пишет в буфер окна).
    • Связь с Renderer и компонентами – Обратите внимание, глобальный Renderer работает совместно с FrameGraph-пассами: ColorPass и IdPass используют window.renderer для отрисовки сцены. Таким образом логика обхода Entities и вызова их компонентов сконцентрирована в одном месте (Renderer), а пассы лишь настраивают параметры (какой буфер таргет, очищать ли фон, специальные режимы). Компоненты визуализации (например, MeshRenderer, SkyboxRenderer и др.) в своих методах draw(context) проверяют фазы/режимы через поле context.phase если нужно (например, могут не рисовать что-то в режиме "pick"). Большинство компонентов просто рисуют во всех фазах, но, например, можно настроить чтобы какой-то компонент отрисовывался только на определённом этапе.
    • Рендер-стейт и материалы – При рендере каждого объекта компоненты могут менять состояние рендеринга (глубина, блэнд, отсеивание) с помощью GraphicsBackend.apply_render_state(). Класс RenderState определяет все такие параметры и используется внутри RenderPass каждого MeshRenderer. Например, для полупрозрачного материала можно задать blend=True с нужными факторами. Сами материалы (termin/visualization/core/material.py) хранят шейдеры и параметры униформ. В ходе MeshRenderer.draw() каждый материал активируется методом apply(model, view, proj, ...), который привязывает шейдер и загружает матрицы преобразования. После отрисовки объекта рендер-стейт обычно сбрасывается на по умолчанию (глубина включена, блэнд выключен).
    • Гибкость системы – Подход с FrameGraph и компонентами делает движок модульным. Можно добавлять новые компоненты (например, ParticleEmitter с собственным draw), они автоматически впишутся в цикл Renderer. Можно изменять конвейер вьюпорта: например, отключить пост-эффекты или добавить свой (достаточно вставить/удалить пасс в viewport.frame_passes). Конвейер редактора, как показано, расширяет дефолтный, добавляя IdPass и эффекты. Все ресурсы именованные, и конфликтов не возникает благодаря проверкам FrameGraph (один ресурс – один продюсер). Такой дизайн облегчает нейросети понимание последовательности шагов визуализации и взаимодействия компонентов: сцена содержит объекты с компонентами, Renderer обходит сцену и вызывает их отрисовку, FrameGraph управляет многоэтапным выводом кадра (основной цвет, идентификаторы, пост-обработка, UI), а PostEffects позволяют на лету модифицировать итоговое изображение без изменения логики компонентов сцены.
