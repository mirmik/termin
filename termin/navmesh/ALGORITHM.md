# NavMesh Polygon Building Algorithm

## Шаг 1: Сбор поверхностных вокселей

**Вход:** VoxelGrid с surface_normals (dict: coord → list[normal])

**Выход:** dict `{(vx, vy, vz): [normal, ...]}` — воксели со списками нормалей треугольников

---

## Шаг 2: Region Growing

**Вход:** dict `{(vx, vy, vz): [normal, ...]}`

**Алгоритм:** BFS с 26-связностью — берём seed, добавляем соседей если `dot(seed_normal, neighbor_first_normal) > threshold`. Используется первая нормаль из списка.

**Выход:** list of `(list[coord], avg_normal)` — группы вокселей с усреднённой нормалью

---

## Шаг 2.5: Расширение регионов (Region Expansion)

**Вход:** регионы из шага 2, dict `{coord: [normal, ...]}`

**Алгоритм:** Для каждого региона ищем граничные воксели (соседи региона, не входящие в него). Если у граничного вокселя есть ХОТЯ БЫ ОДНА нормаль, близкая к нормали региона (`dot >= threshold`), добавляем его в регион.

**Выход:** расширенные регионы (могут перекрываться)

**Примечание:** После этого шага один воксель может принадлежать нескольким регионам — это ожидаемое поведение для вокселей на стыке поверхностей.

---

## Шаг 3: Вычислить плоскость для группы

**Вход:** `list[coord]` — координаты вокселей группы, `avg_normal`

**Алгоритм:**
- Переводим coord в мировые координаты центров вокселей
- Вычисляем центроид (среднее)
- Плоскость: точка = центроид, нормаль = avg_normal

**Выход:** `(plane_point, plane_normal)` — плоскость

---

## Шаг 4: Проецируем центры на плоскость

**Вход:** центры вокселей (3D), плоскость

**Алгоритм:** `projected = point - dot(point - plane_point, normal) * normal`

**Выход:** list of 3D точек на плоскости

---

## Шаг 5: Переводим в 2D

**Вход:** 3D точки на плоскости, normal

**Алгоритм:** строим ортонормированный базис (u, v) перпендикулярный normal, проецируем

**Выход:** list of 2D точек `(u, v)`, базис `(origin, u, v)` для обратного преобразования

---

## Шаг 6: Alpha Shape (Delaunay + фильтрация)

**Вход:** list of 2D точек, alpha = cell_size * 1.5

**Алгоритм:**
1. Delaunay триангуляция (scipy.spatial.Delaunay, потом заменим на свою)
2. Для каждого треугольника вычисляем circumradius: `R = (a * b * c) / (4 * area)`
3. Оставляем треугольники где `circumradius <= alpha`

**Выход:** треугольники (индексы вершин)

---

## Шаг 7: Извлечение boundary

**Вход:** треугольники (индексы вершин), 2D точки

**Алгоритм:**
1. Собираем все рёбра из треугольников (как неупорядоченные пары вершин)
2. Считаем сколько раз встречается каждое ребро
3. Boundary = рёбра, встречающиеся ровно 1 раз

**Выход:** set of edges `{(i, j), ...}` — неупорядоченные пары индексов

---

## Шаг 8: Построение контуров

**Вход:** boundary edges

**Алгоритм:**
1. Строим граф смежности из рёбер
2. Обходим граф, собирая связные цепочки
3. Каждая замкнутая цепочка — контур

**Выход:** list of контуров, каждый контур — упорядоченный список индексов вершин

---

## Шаг 9: Определение внешнего контура и дыр

**Вход:** list of контуров, 2D точки

**Алгоритм:**
1. Находим точку с минимальным X среди всех точек
2. Контур, содержащий эту точку — внешний
3. Вычисляем signed area внешнего контура
4. Нормализуем ориентацию: внешний → CCW (положительная area), дыры → CW

**Выход:** внешний контур (CCW), список дыр (CW)

---

## Шаг 10: Douglas-Peucker упрощение

**Вход:** контур (список 2D точек), epsilon

**Алгоритм:**
1. Рекурсивно находим точку максимально удалённую от прямой между концами
2. Если расстояние < epsilon — удаляем все промежуточные точки
3. Иначе — разбиваем на две части и повторяем

**Выход:** упрощённый контур (подмножество исходных точек)

Применяем к внешнему контуру и каждой дыре отдельно.

---

## Шаг 11: Bridge (соединение дыр)

**Вход:** внешний контур (CCW), список дыр (CW)

**Алгоритм:**
1. Для каждой дыры находим ближайшую пару точек (одна на внешнем контуре, одна на дыре)
2. Разрезаем внешний контур в этой точке
3. Вставляем дыру (с двумя bridge-рёбрами)
4. Получаем один простой контур

**Выход:** один простой контур без дыр

---

## Шаг 12: Ear Clipping триангуляция

**Вход:** простой контур (список 2D точек, CCW)

**Алгоритм:**
1. Находим "ухо" — вершину, где треугольник с соседями не пересекает другие рёбра и внутри нет других вершин
2. Отрезаем ухо — добавляем треугольник, удаляем вершину
3. Повторяем пока не останется 3 вершины

**Выход:** треугольники (индексы вершин)

---

## Шаг 13: Обратно в 3D

**Вход:** 2D вершины контура, треугольники, базис `(origin, u, v)`

**Алгоритм:** `3D = origin + u_coord * basis_u + v_coord * basis_v`

**Выход:** NavPolygon с vertices (3D), triangles, normal

---

## TODO

- [x] Шаг 7-9: Извлечение boundary и построение контуров
- [x] Шаг 10: Douglas-Peucker
- [x] Шаг 2.5: Расширение регионов (Region Expansion)
- [ ] Шаг 11: Bridge
- [ ] Шаг 12: Ear Clipping
- [ ] Перенос Delaunay на C++
