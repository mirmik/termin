# NavMesh Polygon Building Algorithm

## Обзор

Алгоритм строит NavMesh из воксельной сетки с нормалями поверхности.
Каждый регион обрабатывается независимо, результаты объединяются без геометрической сшивки.

### Стадии (NavMeshStage)

| # | Стадия | Описание |
|---|--------|----------|
| 0 | REGIONS_BASIC | Region growing (базовые регионы) |
| 1 | REGIONS_EXPANDED | + расширение регионов на граничные воксели |
| 2 | STITCHED | + проекция вершин на пересечения плоскостей |
| 3 | WITH_CONTOURS | + извлечение контуров из треугольников |
| 4 | SIMPLIFIED | + упрощение контуров (Douglas-Peucker) |
| 5 | FINAL | + Voronoi-разбиение |

---

## Шаг 1: Сбор поверхностных вокселей

**Вход:** VoxelGrid с surface_normals (dict: coord → list[normal])

**Выход:** dict `{(vx, vy, vz): [normal, ...]}` — воксели со списками нормалей треугольников

**Примечание:** Каждый воксель хранит список нормалей всех треугольников, которые его пересекают. Это позволяет корректно обрабатывать воксели на стыке поверхностей.

---

## Шаг 2: Region Growing

**Вход:** dict `{(vx, vy, vz): [normal, ...]}`

**Алгоритм:** BFS с 26-связностью:
1. Берём seed-воксель
2. Добавляем соседей если `dot(seed_normal, neighbor_first_normal) >= threshold`
3. Используется первая нормаль из списка для сравнения

**Выход:** list of `(list[coord], avg_normal)` — группы вокселей с усреднённой нормалью

---

## Шаг 2.5: Расширение регионов (Region Expansion)

**Вход:** регионы из шага 2, dict `{coord: [normal, ...]}`

**Алгоритм:** Для каждого региона:
1. Находим граничные воксели (соседи региона, не входящие в него)
2. Если у граничного вокселя есть ХОТЯ БЫ ОДНА нормаль, близкая к нормали региона (`dot >= threshold`), добавляем его в регион

**Выход:** расширенные регионы (могут перекрываться)

**Примечание:** После этого шага один воксель может принадлежать нескольким регионам — это ожидаемое поведение для вокселей на стыке поверхностей.

---

## Шаг 3: Вычисление плоскости для региона

**Вход:** `list[coord]` — координаты вокселей группы, `avg_normal`

**Алгоритм:**
1. Переводим coord в мировые координаты центров вокселей
2. Вычисляем центроид (среднее)
3. Плоскость: точка = центроид, нормаль = avg_normal

**Выход:** `(plane_point, plane_normal)` — плоскость региона

---

## Шаг 4: Проекция на плоскость (с опциональной сшивкой)

**Вход:** центры вокселей (3D), плоскость региона, информация о принадлежности вокселей регионам

**Алгоритм без сшивки:**
```
projected = point - dot(point - plane_point, normal) * normal
```

**Алгоритм со сшивкой (stitch_polygons=True):**
- Воксель в 1 регионе: обычная проекция на плоскость
- Воксель в 2 регионах: проекция на линию пересечения двух плоскостей
- Воксель в 3+ регионах: проекция в точку пересечения трёх плоскостей

**Математика сшивки:**
- Линия пересечения двух плоскостей: направление `d = n1 × n2`, точка через least squares
- Точка пересечения трёх плоскостей: решение системы `[n1; n2; n3] * x = [d1; d2; d3]`

**Выход:** list of 3D точек (на плоскости или на пересечениях)

**Эффект:** Вершины на границах регионов совпадают геометрически, что даёт ровные стыки.

---

## Шаг 5: Перевод в 2D

**Вход:** 3D точки на плоскости, normal

**Алгоритм:**
1. Строим ортонормированный базис (u, v) перпендикулярный normal
2. Проецируем точки на этот базис

**Выход:** list of 2D точек `(u, v)`, базис `(centroid, u, v)` для обратного преобразования

---

## Шаг 6: Alpha Shape (Delaunay + фильтрация)

**Вход:** list of 2D точек, alpha = cell_size * 1.5

**Алгоритм:**
1. Delaunay триангуляция (scipy.spatial.Delaunay)
2. Для каждого треугольника вычисляем circumradius: `R = (a * b * c) / (4 * area)`
3. Оставляем треугольники где `circumradius <= alpha`

**Выход:** треугольники (индексы вершин)

---

## Шаг 7: Обратно в 3D

**Вход:** 2D точки, треугольники, базис `(centroid, u, v)`

**Алгоритм:**
```
vertex_3d = centroid + u_coord * basis_u + v_coord * basis_v
```

**Выход:** NavPolygon с vertices (3D), triangles, normal

---

## Шаг 8: Извлечение контуров (опционально)

**Вход:** треугольники (индексы вершин), 2D точки

**Алгоритм:**
1. Собираем все рёбра из треугольников
2. Boundary = рёбра, встречающиеся ровно 1 раз
3. Строим граф смежности из boundary edges
4. Обходим граф, собирая замкнутые цепочки
5. Определяем внешний контур (содержит точку с min X) и дыры
6. Нормализуем ориентацию: внешний → CCW, дыры → CW

**Выход:** outer_contour (CCW), holes (CW)

---

## Шаг 9: Douglas-Peucker упрощение (опционально)

**Вход:** контур (список индексов вершин), epsilon

**Алгоритм:**
1. Разбиваем замкнутый контур в точке максимально удалённой от начала
2. Рекурсивно находим точку максимально удалённую от прямой между концами
3. Если расстояние < epsilon — удаляем все промежуточные точки
4. Иначе — разбиваем на две части и повторяем

**Выход:** упрощённый контур (подмножество исходных индексов)

Применяем к внешнему контуру и каждой дыре отдельно.

---

## Шаг 10: Voronoi-разбиение

**Вход:** упрощённый контур (CCW), voronoi_cell_size

**Алгоритм:**
1. Вычисляем bounding box контура
2. Расставляем сиды (seed points) на регулярной сетке внутри контура
3. Добавляем "далёкие" точки для ограничения бесконечных рёбер Вороного
4. Вычисляем диаграмму Вороного (scipy.spatial.Voronoi)
5. Для каждой ячейки:
   - Обрезаем по контуру региона (Sutherland-Hodgman clipping)
   - Триангулируем ячейку (fan triangulation)
6. Объединяем все ячейки в единый меш

**Выход:** новые вершины и треугольники

**Параметр:** `voronoi_cell_size` — шаг сетки сидов (чем больше, тем крупнее ячейки)

---

## Шаг 11: Объединение регионов

**Вход:** список NavPolygon от всех регионов

**Алгоритм:** Конкатенация вершин и треугольников (без геометрической сшивки)

**Выход:** NavMesh

**Примечание:** Граф связности регионов строится отдельно на основе общих вокселей. Геометрическая сшивка не требуется для pathfinding.

---

## TODO

- [x] Шаг 1: Сбор поверхностных вокселей (список нормалей на воксель)
- [x] Шаг 2: Region Growing
- [x] Шаг 2.5: Расширение регионов (Region Expansion)
- [x] Шаг 3-4: Плоскость + проекция с сшивкой
- [x] Шаг 5-7: 2D → Alpha Shape → 3D
- [x] Шаг 8: Извлечение контуров
- [x] Шаг 9: Douglas-Peucker
- [x] Шаг 10: Voronoi-разбиение
- [ ] Граф связности регионов
- [ ] Перенос Delaunay на C++
