using System.Collections.Generic;
using System;

#if UNITY_64
using UnityEngine;
#endif

public class MovingCommand : ActorCommand
{
    protected ReferencedPoint _target_position;
    protected PathFindingTarget _target_type;
    protected PathFindingTarget _start_type;
    protected WalkingType _walking_type;

    protected BracedCoordinates _braced_coordinates = default;
    protected LookAroundSettings _look_around;

    public MovingCommand() { }

    public MovingCommand(
        ReferencedPoint target_position,
        WalkingType walking_type,
        long stamp,
        PathFindingTarget target_type = PathFindingTarget.Standart,
        PathFindingTarget start_type = PathFindingTarget.Standart,
        BracedCoordinates braced_coordinates = default,
        LookAroundSettings look_around = default
    ) : base(stamp)
    {
        _target_position = target_position;
        _walking_type = walking_type;
        _target_type = target_type;
        _start_type = start_type;
        _braced_coordinates = braced_coordinates;
        _look_around = look_around;

        // if (_braced_coordinates != default &&
        // 	_braced_coordinates.TargetPoint != default)
        // 	_target_position = _braced_coordinates.TargetPoint;
    }

    public void MovingPhase(ObjectOfTimeline actor, ITimeline timeline)
    {
        if (timeline.IsPast())
            actor.DropToCurrentState();

        var sposition = actor.CurrentReferencedPosition();
        var start_position = sposition;

        var unitpath = PathFinding.MakeUnitPathForMoving(
            actor,
            timeline,
            start_position,
            _target_position,
            _start_type,
            _target_type,
            _braced_coordinates,
            navmesh_precast: false,
            use_normal_as_up: actor.UseSurfaceNormalForOrientation
        );

        ApplyUnitPath(actor as Actor, unitpath);
    }

    public void ApplyUnitPath(Actor actor, UnitPath unitpath)
    {
        var timeline = actor.GetTimeline();
        var list = actor.PlanPath(unitpath, _walking_type, 0, look_around: _look_around);
        actor.ApplyAnimatronicsList(list);

        if (actor.grabbed_actor != default && actor.is_drag_grabbed_actor)
        {
            var pulled_object = timeline.GetObject(actor.grabbed_actor);
            if (pulled_object != null)
            {
                var pulled_path = PathFinding.PulledPathFrom(
                    list,
                    pulled_object.CurrentReferencedPose(),
                    timeline
                );
                pulled_object.ApplyAnimatronicsList(pulled_path);
            }
        }
    }

    public override bool ExecuteFirstTime(ObjectOfTimeline actor, ITimeline timeline)
    {
        MovingPhase(actor, timeline);
        return false;
    }

    public override bool Execute(ObjectOfTimeline actor, ITimeline timeline)
    {
        var last_animatronic = actor.LastAnimatronic;
        if (last_animatronic == null)
            return true;

        if (
            last_animatronic is MovingAnimatronic && last_animatronic.FinishStep > actor.LocalStep()
        )
        {
            return false;
        }

        var actor_curstep = actor.LocalStep();
        var last_animatronic_curstep = last_animatronic.FinishStep;
        if (actor_curstep >= last_animatronic_curstep)
            return true;

        var current_position = actor.CurrentReferencedPosition();
        if (current_position.DistanceTo(_target_position, timeline) < Utility.AllowedMovingError)
        {
            return true;
        }

        return false;
    }

    public Vector3 TargetLocalPosition()
    {
        return _target_position.LocalPosition;
    }

    public ReferencedPoint TargetPosition()
    {
        return _target_position;
    }

    public override void CancelHandler(CommandBufferBehaviour behaviour) { }

    //BEGIN################################################################
    // This code was generated by FieldScanner

    public override long HashCode()
    {
        long result = 0;
        result = FieldScanner.ModifyHash(result, _target_position);
        result = FieldScanner.ModifyHash(result, _target_type);
        result = FieldScanner.ModifyHash(result, _start_type);
        result = FieldScanner.ModifyHash(result, _walking_type);
        result = FieldScanner.ModifyHash(result, _braced_coordinates);
        result = FieldScanner.ModifyHash(result, _look_around);
        result = FieldScanner.ModifyHash(result, start_step);
        result = FieldScanner.ModifyHash(result, finish_step);
        return result;
    }

    public override bool Equals(object obj)
    {
        if (obj == null)
            return false;
        if (obj.GetType() != GetType())
            return false;
        var other = obj as MovingCommand;
        return _target_position == other._target_position
            && _target_type == other._target_type
            && _start_type == other._start_type
            && _walking_type == other._walking_type
            && _braced_coordinates == other._braced_coordinates
            && _look_around == other._look_around
            && start_step == other.start_step
            && finish_step == other.finish_step
            && true;
    }

    public override int GetHashCode()
    {
        return (int)HashCode();
    }
    //END################################################################
}
