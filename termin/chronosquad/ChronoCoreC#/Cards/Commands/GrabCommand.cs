using System.Collections.Generic;
using System;

#if UNITY_64
using UnityEngine;
#endif

public class GrabCommand : MovingToObjectCommand
{
    bool is_dragging = false;

    public GrabCommand(
        ObjectId target_actor,
        long stamp,
        bool is_dragging,
        WalkingType walktype = WalkingType.Run
    ) : base(target_actor, walktype: walktype, stamp: stamp)
    {
        this.is_dragging = is_dragging;
    }

    bool IsCloseDistance(ObjectOfTimeline actor, ITimeline timeline)
    {
        var target_actor = TargetObject(timeline);
        return Vector3.Distance(actor.position(), target_actor.position()) < 1.0f;
    }

    bool GrabPhase(ObjectOfTimeline actor, ITimeline timeline)
    {
        bool croach = walktype == WalkingType.Croach;

        if (!(actor as Actor).IsShort())
            (actor as Actor).SetCroachControl(croach);
        var target_actor = TargetObject(timeline);

        (actor as Actor).GrabImpl(target_actor as Actor, is_dragging: is_dragging);

        if (!is_dragging)
        {
            if (!target_actor.IsDead)
            {
                // var cmd = new GrubbedWhileAliveCommand(
                // 	AnimationType.Idle,
                // 	(target_actor as Actor).LocalStep() + 1,
                // 	confusion_time : 6.0f,
                // 	host_actor : actor.ObjectId());
                // (target_actor as Actor).AddExternalCommand(cmd);
                if ((target_actor as Actor).AiController() == null)
                    throw new Exception("target_actor as Actor).AiController() == null");

                (target_actor as Actor)
                    .AiController()
                    ?.ConfusedWhileGrabbedAnother(Utility.DurationToSteps(6.0f), actor.ObjectId());
            }
            else
            {
                var idle_animatronic = new ParasiteParasiteAnimatronic(
                    target_actor.LocalStep(),
                    long.MaxValue,
                    host: actor.ObjectId(),
                    croach ? AnimationType.Dragged : AnimationType.Grabbed
                );
                (target_actor as Actor).SetNextAnimatronic(idle_animatronic);
            }
        }

        return true;
    }

    public override bool Execute(ObjectOfTimeline actor, ITimeline timeline)
    {
        if (IsCloseDistance(actor, timeline))
        {
            return GrabPhase(actor, timeline);
        }
        else
        {
            MovingPhase(actor, timeline);
            return false;
        }
    }
}

[Serializable]
public class UnGrabCommand : MovingCommand
{
    public UnGrabCommand(
        ReferencedPoint target_position,
        long stamp,
        WalkingType walktype = WalkingType.Walk
    ) : base(target_position, walktype, stamp) { }

    bool IsCloseDistance(ObjectOfTimeline actor)
    {
        var position = actor.CurrentReferencedPoint();
        float distance = position.Distance(TargetPosition(), actor.GetTimeline());
        return distance < 1e-5;
    }

    bool UnGrubPhase(ObjectOfTimeline actor, ITimeline timeline)
    {
        ObjectOfTimeline grabbed_actor = actor
            .GetTimeline()
            .GetObject((actor as Actor).GrabbedActor());

        (actor as Actor).UnGrabImpl();
        (grabbed_actor as Actor).UnGrabbedImpl(
            is_dragging: (actor as Actor).is_drag_grabbed_actor,
            host_pose: actor.CurrentReferencedPose()
        );
        return true;
    }

    public override bool Execute(ObjectOfTimeline actor, ITimeline timeline)
    {
        if (IsCloseDistance(actor))
        {
            return UnGrubPhase(actor, timeline);
        }
        else
        {
            var current_animatronic = actor.CurrentAnimatronic();
            if (current_animatronic is MovingAnimatronic)
            {
                return false;
            }
            else
            {
                MovingPhase(actor, timeline);
                return false;
            }
        }
    }

    //BEGIN################################################################
    // This code was generated by FieldScanner

    public override long HashCode()
    {
        long result = 0;
        result = FieldScanner.ModifyHash(result, _target_position);
        result = FieldScanner.ModifyHash(result, _target_type);
        result = FieldScanner.ModifyHash(result, _start_type);
        result = FieldScanner.ModifyHash(result, _walking_type);
        result = FieldScanner.ModifyHash(result, _braced_coordinates);
        result = FieldScanner.ModifyHash(result, _look_around);
        result = FieldScanner.ModifyHash(result, start_step);
        result = FieldScanner.ModifyHash(result, finish_step);
        return result;
    }

    public override bool Equals(object obj)
    {
        if (obj == null)
            return false;
        if (obj.GetType() != GetType())
            return false;
        var other = obj as UnGrabCommand;
        return _target_position == other._target_position
            && _target_type == other._target_type
            && _start_type == other._start_type
            && _walking_type == other._walking_type
            && _braced_coordinates == other._braced_coordinates
            && _look_around == other._look_around
            && start_step == other.start_step
            && finish_step == other.finish_step
            && true;
    }

    public override int GetHashCode()
    {
        return (int)HashCode();
    }
    //END################################################################
}
