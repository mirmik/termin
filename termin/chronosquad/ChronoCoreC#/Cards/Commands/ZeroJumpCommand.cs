using System.Collections;
using System.Collections.Generic;
using System;
using UnityEngine;
using System.IO;

public class ZeroJumpCommand : MovingCommand
{
    public float radius_of_sound = 2;
    public float jump_radius;
    public float fleet_speed = 5.0f;

    public ZeroJumpCommand(ReferencedPoint target, float jump_radius, float fleet_speed, long stamp)
        : base(target, WalkingType.Run, stamp: stamp, PathFindingTarget.Standart)
    {
        this.jump_radius = jump_radius;
        this.fleet_speed = fleet_speed;
    }

    protected void AddEvents(ObjectOfTimeline actor, ITimeline tl)
    {
        var target_position = PathFinding.NavMeshPoint_Global(_target_position.GlobalPosition(tl));

        var current_pose = actor.CurrentReferencedPose();
        var current_global_pose = current_pose.GlobalPose(tl);
        var direction = target_position - current_global_pose.position;

        var distance = direction.magnitude;
        var time = distance / fleet_speed;

        var finnormal = PathFinding.EvaluateNormal(target_position, true, _target_position.Frame);

        var tgtrot = MathUtil.UpperiseLookRotation(direction, finnormal);

        var finish_pose = ReferencedPose.FromGlobalPose(
            new Pose(target_position, tgtrot),
            _target_position.Frame,
            tl
        );

        var jump_animatronic = new PoseLerpAnimatronic(
            start_step: actor.LocalStep() + 1,
            finish_step: actor.LocalStep() + (long)(time * Utility.GAME_GLOBAL_FREQUENCY),
            pose_a: actor.CurrentReferencedPose(),
            pose_b: finish_pose,
            anim: AnimationType.ZeroJumpFleet
        );
        actor.SetNextAnimatronic(jump_animatronic);
    }

    public bool IsTrajectoryClear(ObjectOfTimeline actor, ITimeline timeline, Vector3 target_global)
    {
        return GameCore.InLineOfSight(actor, target_global, maxdistance: jump_radius);
    }

    bool JumpPhase(ObjectOfTimeline actor, ITimeline timeline)
    {
        AddEvents(actor, timeline);
        return true;
    }

    public override bool Execute(ObjectOfTimeline actor, ITimeline timeline)
    {
        var current_position = actor.CurrentReferencedPosition();
        var target_global = _target_position.GlobalPosition(timeline);
        target_global += new Vector3(0, 0.5f, 0);

        if (IsTrajectoryClear(actor, timeline, target_global))
        {
            return JumpPhase(actor, timeline);
        }

        if (current_position.DistanceTo(_target_position, timeline) < 0.1f)
        {
            return true;
        }

        return false;
    }

    //BEGIN################################################################
    // This code was generated by FieldScanner

    public override long HashCode()
    {
        long result = 0;
        result = FieldScanner.ModifyHash(result, radius_of_sound);
        result = FieldScanner.ModifyHash(result, jump_radius);
        result = FieldScanner.ModifyHash(result, fleet_speed);
        result = FieldScanner.ModifyHash(result, _target_position);
        result = FieldScanner.ModifyHash(result, _target_type);
        result = FieldScanner.ModifyHash(result, _start_type);
        result = FieldScanner.ModifyHash(result, _walking_type);
        result = FieldScanner.ModifyHash(result, _braced_coordinates);
        result = FieldScanner.ModifyHash(result, _look_around);
        result = FieldScanner.ModifyHash(result, start_step);
        result = FieldScanner.ModifyHash(result, finish_step);
        return result;
    }

    public override bool Equals(object obj)
    {
        if (obj == null)
            return false;
        if (obj.GetType() != GetType())
            return false;
        var other = obj as ZeroJumpCommand;
        return radius_of_sound == other.radius_of_sound
            && jump_radius == other.jump_radius
            && fleet_speed == other.fleet_speed
            && _target_position == other._target_position
            && _target_type == other._target_type
            && _start_type == other._start_type
            && _walking_type == other._walking_type
            && _braced_coordinates == other._braced_coordinates
            && _look_around == other._look_around
            && start_step == other.start_step
            && finish_step == other.finish_step
            && true;
    }

    public override int GetHashCode()
    {
        return (int)HashCode();
    }
    //END################################################################
}
