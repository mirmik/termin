using System.Collections.Generic;
using System;

#if UNITY_64
using UnityEngine;
#endif

// Тут какая-то хрень с инициирующей позой. Вероятно команда неправильно обращается.

public class SightToCommand : ActorCommand
{
    private ReferencedPose _initial_pose;
    private ReferencedPoint target_position;
    AnimationType anim;

    public SightToCommand() { }

    public SightToCommand(ReferencedPoint target_position, AnimationType anim, long stamp)
        : base(stamp)
    {
        this.target_position = target_position;
        this.anim = anim;
    }

    public void RotatePhase(ObjectOfTimeline actor, ITimeline timeline)
    {
        var forward = actor.CurrentReferencedPose().GlobalDirection(timeline);
        var target_direction =
            target_position.GlobalPosition(timeline)
            - actor.CurrentReferencedPose().GlobalPosition(timeline);
        var angle = Vector3.Angle(forward, target_direction);

        var time_to_rotate = angle / 360.0f;

        var curglobalpose = actor.CurrentReferencedPose().GlobalPose(timeline);
        var tgtglobalpoint = target_position.GlobalPosition(timeline);

        Vector3 gravity_up = Vector3.up;
        if (actor.MovedWith() != default)
        {
            var frame_object = timeline.GetObject(actor.MovedWith());
            gravity_up = frame_object.PlatformPseudoGravityVector(curglobalpose.position);
        }
        var fwd = tgtglobalpoint - curglobalpose.position;
        var rot = Quaternion.LookRotation(fwd, gravity_up);
        var pose = new Pose(curglobalpose.position, rot);
        pose.SetUpBiStep(gravity_up);
        var target_pose = ReferencedPose.FromGlobalPose(
            pose,
            actor.CurrentReferencedPose().Frame,
            timeline
        );

        //Debug.Log("RotatePhase: " + target_pose);

        var current_step = actor.LocalStep();
        var animatronic = new RotateAnimatronic(
            current_step,
            current_step + (long)(time_to_rotate * Utility.GAME_GLOBAL_FREQUENCY),
            time_to_rotate,
            actor.CurrentReferencedPose(),
            target_pose: target_pose,
            target_position: target_position,
            idle_animation: anim
        );
        actor.SetNextAnimatronic(animatronic);
    }

    public override bool ExecuteFirstTime(ObjectOfTimeline actor, ITimeline timeline)
    {
        //Debug.Log("ExecuteFirstTime");
        RotatePhase(actor, timeline);
        return false;
    }

    public override bool Execute(ObjectOfTimeline actor, ITimeline timeline)
    {
        var current_animatronic = actor.CurrentAnimatronic();
        var ranim = current_animatronic as RotateAnimatronic;

        //Debug.Log("start: " + ranim.StartStep + "finish: " + ranim.FinishStep );

        if (ranim == null || ranim.IsFinished(actor.LocalStep()))
            return true;

        return false;
    }

    public Vector3 TargetLocalPosition()
    {
        return target_position.LocalPosition;
    }

    public ReferencedPoint TargetPosition()
    {
        return target_position;
    }

    public override void CancelHandler(CommandBufferBehaviour behaviour) { }

    //BEGIN################################################################
    // This code was generated by FieldScanner

    public override long HashCode()
    {
        long result = 0;
        result = FieldScanner.ModifyHash(result, _initial_pose);
        result = FieldScanner.ModifyHash(result, target_position);
        result = FieldScanner.ModifyHash(result, anim);
        result = FieldScanner.ModifyHash(result, start_step);
        result = FieldScanner.ModifyHash(result, finish_step);
        return result;
    }

    public override bool Equals(object obj)
    {
        if (obj == null)
            return false;
        if (obj.GetType() != GetType())
            return false;
        var other = obj as SightToCommand;
        return _initial_pose == other._initial_pose
            && target_position == other.target_position
            && anim == other.anim
            && start_step == other.start_step
            && finish_step == other.finish_step
            && true;
    }

    public override int GetHashCode()
    {
        return (int)HashCode();
    }
    //END################################################################
}
