using UnityEngine;
using System.Collections.Generic;

public class FlueteCommand : MovingCommand
{
    float radius;

    public FlueteCommand(
        ReferencedPoint target_position,
        long stamp,
        float radius,
        WalkingType walking_type = WalkingType.Walk
    ) : base(target_position, walking_type, stamp)
    {
        this.radius = radius;
    }

    bool IsCloseDistance(ObjectOfTimeline actor)
    {
        var position = actor.CurrentReferencedPoint();
        float distance = position.Distance(TargetPosition(), actor.GetTimeline());
        return distance < 0.1f;
    }

    bool FluetePhase(ObjectOfTimeline actor, ITimeline timeline)
    {
        var tl = timeline;
        ObjectId target_actor = (actor as Actor).GrabbedActor();
        //(actor as Actor).UnGrabImpl();
        //(target_actor as Actor).UnGrabbedImpl();

        long offset = (long)(Utility.GAME_GLOBAL_FREQUENCY * 0.5f);
        var ev = new LoudSoundEvent(
            step: tl.CurrentStep() + offset,
            center: actor.CurrentReferencedPoint(),
            radius: radius,
            noise_parameters: new RestlessnessParameters(duration_of_attention: 8.0f, lures: true)
        );
        tl.AddEvent(ev);

        var effect = new LoudSoundVisualEffect(
            start_step: tl.CurrentStep() + offset,
            finish_step: tl.CurrentStep() + offset + (long)(Utility.GAME_GLOBAL_FREQUENCY * 0.5f),
            position: actor.CurrentReferencedPoint(),
            maxRadius: radius
        );
        tl.AddEvent(effect);

        return true;
    }

    public override bool Execute(ObjectOfTimeline actor, ITimeline timeline)
    {
        if (IsCloseDistance(actor))
        {
            return FluetePhase(actor, timeline);
        }
        else
        {
            var current_animatronic = actor.CurrentAnimatronic();
            if (current_animatronic is MovingAnimatronic)
            {
                return false;
            }
            else
            {
                MovingPhase(actor, timeline);
                return false;
            }
        }
    }

    //BEGIN################################################################
    // This code was generated by FieldScanner

    public override long HashCode()
    {
        long result = 0;
        result = FieldScanner.ModifyHash(result, radius);
        result = FieldScanner.ModifyHash(result, _target_position);
        result = FieldScanner.ModifyHash(result, _target_type);
        result = FieldScanner.ModifyHash(result, _start_type);
        result = FieldScanner.ModifyHash(result, _walking_type);
        result = FieldScanner.ModifyHash(result, _braced_coordinates);
        result = FieldScanner.ModifyHash(result, _look_around);
        result = FieldScanner.ModifyHash(result, start_step);
        result = FieldScanner.ModifyHash(result, finish_step);
        return result;
    }

    public override bool Equals(object obj)
    {
        if (obj == null)
            return false;
        if (obj.GetType() != GetType())
            return false;
        var other = obj as FlueteCommand;
        return radius == other.radius
            && _target_position == other._target_position
            && _target_type == other._target_type
            && _start_type == other._start_type
            && _walking_type == other._walking_type
            && _braced_coordinates == other._braced_coordinates
            && _look_around == other._look_around
            && start_step == other.start_step
            && finish_step == other.finish_step
            && true;
    }

    public override int GetHashCode()
    {
        return (int)HashCode();
    }
    //END################################################################
}
