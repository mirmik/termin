using System.Collections.Generic;
using System;

#if UNITY_64
using UnityEngine;
#endif

public class RotateCommand : ActorCommand
{
    private ReferencedPose _initial_pose;
    private ReferencedPose target_pose;
    AnimationType anim;

    public RotateCommand() { }

    public RotateCommand(ReferencedPose target_pose, AnimationType anim, long stamp) : base(stamp)
    {
        this.target_pose = target_pose;
        this.anim = anim;
    }

    public void RotatePhase(ObjectOfTimeline actor, ITimeline timeline)
    {
        // var forward = actor.CurrentReferencedPose().GlobalDirection(timeline);
        // var target_direction = target_position.GlobalPosition(timeline) - actor.CurrentReferencedPose().GlobalPosition(timeline);
        var angle = Quaternion.Angle(_initial_pose.LocalRotation(), target_pose.LocalRotation());

        var time_to_rotate = angle / 360.0f;

        // var curglobalpose = actor.CurrentReferencedPose().GlobalPose(timeline);
        // var tgtglobalpoint = target_position.GlobalPosition(timeline);

        // Vector3 gravity_up = Vector3.up;
        // if (actor.MovedWith() != default)
        // {
        // 	var frame_object = timeline.GetObject(actor.MovedWith());
        // 	gravity_up = frame_object.PlatformPseudoGravityVector(curglobalpose.position);
        // }
        // var fwd = tgtglobalpoint - curglobalpose.position;
        // var rot = Quaternion.LookRotation(fwd, gravity_up);
        // var pose = new Pose(curglobalpose.position, rot);
        // pose.SetUpBiStep(gravity_up);
        // var target_pose =
        // 	ReferencedPose.FromGlobalPose(
        // 		pose,
        // 	actor.CurrentReferencedPose().Frame, timeline);

        //Debug.Log("RotatePhase: " + target_pose);

        var current_step = actor.LocalStep();
        var animatronic = new RotateAnimatronic(
            current_step,
            current_step + (long)(time_to_rotate * Utility.GAME_GLOBAL_FREQUENCY),
            time_to_rotate,
            actor.CurrentReferencedPose(),
            target_pose: target_pose,
            target_position: default,
            idle_animation: anim
        );
        actor.SetNextAnimatronic(animatronic);
    }

    public override bool ExecuteFirstTime(ObjectOfTimeline actor, ITimeline timeline)
    {
        RotatePhase(actor, timeline);
        return false;
    }

    public override bool Execute(ObjectOfTimeline actor, ITimeline timeline)
    {
        var current_animatronic = actor.CurrentAnimatronic();
        var ranim = current_animatronic as RotateAnimatronic;

        if (ranim == null || ranim.IsFinished(actor.LocalStep()))
            return true;

        return false;
    }

    public override void CancelHandler(CommandBufferBehaviour behaviour) { }

    //BEGIN################################################################
    // This code was generated by FieldScanner

    public override long HashCode()
    {
        long result = 0;
        result = FieldScanner.ModifyHash(result, _initial_pose);
        result = FieldScanner.ModifyHash(result, target_pose);
        result = FieldScanner.ModifyHash(result, anim);
        result = FieldScanner.ModifyHash(result, start_step);
        result = FieldScanner.ModifyHash(result, finish_step);
        return result;
    }

    public override bool Equals(object obj)
    {
        if (obj == null)
            return false;
        if (obj.GetType() != GetType())
            return false;
        var other = obj as RotateCommand;
        return _initial_pose == other._initial_pose
            && target_pose == other.target_pose
            && anim == other.anim
            && start_step == other.start_step
            && finish_step == other.finish_step
            && true;
    }

    public override int GetHashCode()
    {
        return (int)HashCode();
    }
    //END################################################################
}
