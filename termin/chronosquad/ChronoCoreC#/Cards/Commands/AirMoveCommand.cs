using System.Collections.Generic;
using System;

#if UNITY_64
using UnityEngine;
#endif

public class AirMovingCommand : ActorCommand
{
    private ReferencedPoint _target_position;
    PathFindingTarget _target_type;
    PathFindingTarget _start_type;
    WalkingType _walking_type;

    BracedCoordinates _braced_coordinates = default;
    LookAroundSettings _look_around;

    public AirMovingCommand() { }

    public AirMovingCommand(
        ReferencedPoint target_position,
        WalkingType walking_type,
        long stamp,
        PathFindingTarget target_type = PathFindingTarget.Standart,
        PathFindingTarget start_type = PathFindingTarget.Standart,
        BracedCoordinates braced_coordinates = default,
        LookAroundSettings look_around = default
    ) : base(stamp)
    {
        _target_position = target_position;
        _walking_type = walking_type;
        _target_type = target_type;
        _start_type = start_type;
        _braced_coordinates = braced_coordinates;
        _look_around = look_around;
    }

    public void MovingPhase(ObjectOfTimeline actor, ITimeline timeline)
    {
        var speed = 4;
        var distance = actor.CurrentReferencedPosition().DistanceTo(_target_position, timeline);
        var time = distance / speed;
        var anim = new MovingAnimatronic(
            AnimationType.None,
            actor.CurrentReferencedPose(),
            new ReferencedPose(
                new Pose(
                    _target_position.LocalPosition,
                    Quaternion.LookRotation(
                        _target_position.LocalPosition
                            - actor.CurrentReferencedPosition().LocalPosition
                    )
                ),
                _target_position.Frame
            ),
            actor.LocalStep(),
            actor.LocalStep() + (long)(time * Utility.GAME_GLOBAL_FREQUENCY),
            1.0f
        );
        actor.SetNextAnimatronic(anim);
    }

    public override bool ExecuteFirstTime(ObjectOfTimeline actor, ITimeline timeline)
    {
        MovingPhase(actor, timeline);
        return false;
    }

    public override bool Execute(ObjectOfTimeline actor, ITimeline timeline)
    {
        //var animatronic = actor.LastAnimatronic as MovingAnimatronic;
        var current_position = actor.CurrentReferencedPosition();
        if (current_position.DistanceTo(_target_position, timeline) < 0.05f)
        {
            return true;
        }

        return false;
    }

    public Vector3 TargetLocalPosition()
    {
        return _target_position.LocalPosition;
    }

    public ReferencedPoint TargetPosition()
    {
        return _target_position;
    }

    public override void CancelHandler(CommandBufferBehaviour behaviour) { }

    //BEGIN################################################################
    // This code was generated by FieldScanner

    public override long HashCode()
    {
        long result = 0;
        result = FieldScanner.ModifyHash(result, _target_position);
        result = FieldScanner.ModifyHash(result, _target_type);
        result = FieldScanner.ModifyHash(result, _start_type);
        result = FieldScanner.ModifyHash(result, _walking_type);
        result = FieldScanner.ModifyHash(result, _braced_coordinates);
        result = FieldScanner.ModifyHash(result, _look_around);
        result = FieldScanner.ModifyHash(result, start_step);
        result = FieldScanner.ModifyHash(result, finish_step);
        return result;
    }

    public override bool Equals(object obj)
    {
        if (obj == null)
            return false;
        if (obj.GetType() != GetType())
            return false;
        var other = obj as AirMovingCommand;
        return _target_position == other._target_position
            && _target_type == other._target_type
            && _start_type == other._start_type
            && _walking_type == other._walking_type
            && _braced_coordinates == other._braced_coordinates
            && _look_around == other._look_around
            && start_step == other.start_step
            && finish_step == other.finish_step
            && true;
    }

    public override int GetHashCode()
    {
        return (int)HashCode();
    }
    //END################################################################
}
