using System.Collections.Generic;
using System;

#if UNITY_64
using UnityEngine;
#endif

[Serializable]
public class SinusMoveAnimatronic : Animatronic
{
    private Pose _start_pose;
    private Pose _end_pose;
    float period;

    public SinusMoveAnimatronic(Pose start_pose, Pose end_pose, float period)
    {
        _start_pose = start_pose;
        _end_pose = end_pose;
        this.period = period;
    }

    public new Vector3 Position(Int64 stepstamp, ITimeline tl)
    {
        long step = stepstamp - StartStep;
        float t = (float)step / Utility.GAME_GLOBAL_FREQUENCY;
        float x = Mathf.Cos(t * 2 * Mathf.PI / period) * 0.5f + 0.5f;
        return _end_pose.position + (_start_pose.position - _end_pose.position) * x;
    }

    public Quaternion Rotation(Int64 stepstamp, ITimeline tl)
    {
        long step = stepstamp - StartStep;
        float t = (float)step / Utility.GAME_GLOBAL_FREQUENCY;
        float x = Mathf.Cos(t * 2 * Mathf.PI / period) * 0.5f + 0.5f;
        return Quaternion.Slerp(_end_pose.rotation, _start_pose.rotation, x);
    }

    public new Vector3 Direction(Int64 stepstamp, ITimeline tl)
    {
        return MathUtil.QuaternionToXZDirection(Rotation(stepstamp, tl));
    }

    public override AnimationType GetAnimationType(global::System.Int64 local_step)
    {
        return AnimationType.Idle;
    }

    public override ReferencedScrew GetReferencedVelocityScrew(Int64 stepstamp, ITimeline tl)
    {
        long step = stepstamp - StartStep;
        float t = (float)step / Utility.GAME_GLOBAL_FREQUENCY;
        float x = -2 * Mathf.PI / period * Mathf.Sin(t * 2 * Mathf.PI / period) * 0.5f;
        return new ReferencedScrew(
            (_start_pose.position - _end_pose.position) * x,
            new Vector3(0, 0, 0),
            null
        );
    }

    public override ReferencedPose GetReferencedPose(long stepstamp, ITimeline tl)
    {
        var dir = Direction(stepstamp, tl);
        return new ReferencedPose(Position(stepstamp, tl), dir, null);
    }

    //BEGIN################################################################
    // This code was generated by FieldScanner

    public override long HashCode()
    {
        long result = 0;
        result = FieldScanner.ModifyHash(result, _start_pose);
        result = FieldScanner.ModifyHash(result, _end_pose);
        result = FieldScanner.ModifyHash(result, period);
        result = FieldScanner.ModifyHash(result, _initial_animation_time);
        result = FieldScanner.ModifyHash(result, unchanged_start_step);
        result = FieldScanner.ModifyHash(result, unchanged_finish_step);
        result = FieldScanner.ModifyHash(result, start_step);
        result = FieldScanner.ModifyHash(result, finish_step);
        return result;
    }

    public override bool Equals(object obj)
    {
        if (obj == null)
            return false;
        if (obj.GetType() != GetType())
            return false;
        var other = obj as SinusMoveAnimatronic;
        return _start_pose == other._start_pose
            && _end_pose == other._end_pose
            && period == other.period
            && _initial_animation_time == other._initial_animation_time
            && unchanged_start_step == other.unchanged_start_step
            && unchanged_finish_step == other.unchanged_finish_step
            && start_step == other.start_step
            && finish_step == other.finish_step
            && true;
    }

    public override int GetHashCode()
    {
        return (int)HashCode();
    }
    //END################################################################
}
