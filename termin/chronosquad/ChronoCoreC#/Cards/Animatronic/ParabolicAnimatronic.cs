using System.Collections;
using System.Collections.Generic;
using System;
using UnityEngine;

public class ParabolicAnimatronic : Animatronic
{
    ReferencedPose pose_a;
    ReferencedPose pose_b;
    float maxtime = 1.0f;

    public ParabolicAnimatronic(
        ReferencedPose pose_a,
        ReferencedPose pose_b,
        long start_step,
        long finish_step,
        float maxtime
    ) : base(start_step, finish_step)
    {
        Debug.Assert(pose_a != pose_b);
        this.pose_a = pose_a;
        this.pose_b = pose_b;
        this.maxtime = maxtime;
    }

    Vector3 parabolic_trajectory(Vector3 start_position, Vector3 finish_position, float t)
    {
        if (t > maxtime)
        {
            return finish_position;
        }

        float g = 9.8f;
        float horizontal_speed = 2;

        Vector2 start_position_2d = new Vector2(start_position.x, start_position.z);
        Vector2 finish_position_2d = new Vector2(finish_position.x, finish_position.z);
        Vector2 direction = finish_position_2d - start_position_2d;
        float distance = direction.magnitude;

        float vertical_dist = finish_position.y - start_position.y;
        // y = v0 * t - g * t^2 / 2
        // v0 = (y + g * t^2 / 2) / t
        float vertical_speed = (vertical_dist + g * t * t / 2) / t;

        float x = start_position.x + horizontal_speed * t * direction.x / distance;
        float y = start_position.y + vertical_speed * t - g * t * t / 2;
        float z = start_position.z + horizontal_speed * t * direction.y / distance;
        return new Vector3(x, y, z);
    }

    public override ReferencedPose GetReferencedPose(long stepstamp, ITimeline tl)
    {
        float t = (float)(stepstamp - StartStep) / (FinishStep - StartStep);

        ObjectId frame;
        if (t < 0.5f)
        {
            frame = pose_a.Frame;
        }
        else
        {
            frame = pose_b.Frame;
        }

        var a_glb_pose = pose_a.GlobalPose(tl);
        var b_glb_pose = pose_b.GlobalPose(tl);

        var lerped_pose = Pose.Lerp(a_glb_pose, b_glb_pose, t);
        var position = parabolic_trajectory(a_glb_pose.position, b_glb_pose.position, t);
        lerped_pose.position = position;
        return ReferencedPose.FromGlobalPose(lerped_pose, frame, tl);
    }

    public override AnimationType GetAnimationType(long local_step)
    {
        return AnimationType.None;
    }

    //BEGIN################################################################
    // This code was generated by FieldScanner

    public override long HashCode()
    {
        long result = 0;
        result = FieldScanner.ModifyHash(result, pose_a);
        result = FieldScanner.ModifyHash(result, pose_b);
        result = FieldScanner.ModifyHash(result, maxtime);
        result = FieldScanner.ModifyHash(result, _initial_animation_time);
        result = FieldScanner.ModifyHash(result, unchanged_start_step);
        result = FieldScanner.ModifyHash(result, unchanged_finish_step);
        result = FieldScanner.ModifyHash(result, start_step);
        result = FieldScanner.ModifyHash(result, finish_step);
        return result;
    }

    public override bool Equals(object obj)
    {
        if (obj == null)
            return false;
        if (obj.GetType() != GetType())
            return false;
        var other = obj as ParabolicAnimatronic;
        return pose_a == other.pose_a
            && pose_b == other.pose_b
            && maxtime == other.maxtime
            && _initial_animation_time == other._initial_animation_time
            && unchanged_start_step == other.unchanged_start_step
            && unchanged_finish_step == other.unchanged_finish_step
            && start_step == other.start_step
            && finish_step == other.finish_step
            && true;
    }

    public override int GetHashCode()
    {
        return (int)HashCode();
    }
    //END################################################################
}
