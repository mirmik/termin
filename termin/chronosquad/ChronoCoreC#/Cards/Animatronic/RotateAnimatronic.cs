using System.Collections.Generic;
using System;

#if UNITY_64
using UnityEngine;
#endif

public class RotateAnimatronic : Animatronic
{
    ReferencedPose _initial_pose;
    ReferencedPose _target_pose;
    ReferencedPoint _target_position;
    AnimationType _idle_animation;
    float _time_to_rotate;

    public RotateAnimatronic(
        long start_step,
        long finish_step,
        float time_to_rotate,
        ReferencedPose initial_pose,
        ReferencedPose target_pose,
        ReferencedPoint target_position,
        AnimationType idle_animation
    ) : base(start_step, finish_step)
    {
        _time_to_rotate = time_to_rotate;
        _idle_animation = idle_animation;
        _initial_pose = initial_pose;
        _target_pose = target_pose;
        _target_position = target_position;
    }

    public Vector3 InitialDirection()
    {
        return _initial_pose.LocalDirection();
    }

    public ReferencedPoint TargetPosition
    {
        get { return _target_position; }
    }

    new ReferencedPose FinishPose
    {
        get { return _target_pose; }
    }

    // public Quaternion Rotation(Int64 stepstamp, ITimeline tl)
    // {
    // 	var dir = TargetDirection();
    // 	var target_rotation = Quaternion.LookRotation(dir, Vector3.up);
    // 	var initial_rotation = Quaternion.LookRotation(InitialDirection(), Vector3.up);

    // 	var time_from_start = (stepstamp - StartStep) / Utility.GAME_GLOBAL_FREQUENCY;
    // 	var ttr = time_to_rotate();
    // 	if (time_from_start < ttr)
    // 	{
    // 		var koeff = time_from_start / time_to_rotate();
    // 		return Quaternion.Slerp(initial_rotation, target_rotation, koeff);
    // 	}

    // 	return target_rotation;
    // }

    // public float time_to_rotate()
    // {
    // 	return Quaternion.Angle(
    // 		_initial_pose.LocalRotation(),
    // 		_target_pose.LocalRotation()
    // 	) / _angular_speed;
    // }

    public RotateAnimatronic() { }

    public override bool IsCroach(ITimeline tl)
    {
        return _idle_animation == AnimationType.CroachIdle
            || _idle_animation == AnimationType.LeanCroachRight
            || _idle_animation == AnimationType.LeanCroachLeft;
    }

    public override ReferencedPose GetReferencedPose(long stepstamp, ITimeline tl)
    {
        if (stepstamp < StartStep)
        {
            return _initial_pose;
        }

        //long EvalFinishStep = StartStep + (long)(time_to_rotate() * Utility.GAME_GLOBAL_FREQUENCY);
        if (stepstamp > FinishStep)
        {
            return FinishPose;
        }
        if (StartStep == FinishStep)
        {
            return FinishPose;
        }

        long total_steps = (long)(_time_to_rotate * Utility.GAME_GLOBAL_FREQUENCY);

        var koeff = (float)(stepstamp - StartStep) / (float)(total_steps);
        if (koeff > 1.0f)
        {
            return FinishPose;
        }

        if (koeff < 0.0f)
        {
            return _initial_pose;
        }

        if (float.IsNaN(koeff))
        {
            return FinishPose;
        }

        if (float.IsInfinity(koeff))
        {
            return FinishPose;
        }

        //Debug.Log("koeff: " + koeff);
        var rpos_a = _initial_pose.LocalPose();
        var rpos_b = _target_pose.LocalPose();
        var rpos = Pose.Lerp(rpos_a, rpos_b, koeff);

        return new ReferencedPose(rpos, _initial_pose.Frame);
    }

    public override ReferencedPose GetReferencedPose_RealTime(float time, ITimeline tl)
    {
        var start_time = StartStep / Utility.GAME_GLOBAL_FREQUENCY;
        var finish_time = FinishStep / Utility.GAME_GLOBAL_FREQUENCY;

        if (time < start_time)
        {
            return _initial_pose;
        }

        if (time > finish_time)
        {
            return FinishPose;
        }

        var koeff = (time - start_time) / _time_to_rotate;

        if (koeff > 1.0f)
        {
            return FinishPose;
        }

        if (koeff < 0.0f)
        {
            return _initial_pose;
        }

        if (float.IsNaN(koeff))
        {
            return FinishPose;
        }

        if (float.IsInfinity(koeff))
        {
            return FinishPose;
        }

        //Debug.Log("koeff: " + koeff);
        var rpos_a = _initial_pose.LocalPose();
        var rpos_b = _target_pose.LocalPose();
        var rpos = Pose.Lerp(rpos_a, rpos_b, koeff);

        return new ReferencedPose(rpos, _initial_pose.Frame);
    }

    public override AnimationType GetAnimationType(long local_step)
    {
        return _idle_animation;
    }

    //BEGIN################################################################
    // This code was generated by FieldScanner

    public override long HashCode()
    {
        long result = 0;
        result = FieldScanner.ModifyHash(result, _initial_pose);
        result = FieldScanner.ModifyHash(result, _target_pose);
        result = FieldScanner.ModifyHash(result, _target_position);
        result = FieldScanner.ModifyHash(result, _idle_animation);
        result = FieldScanner.ModifyHash(result, _time_to_rotate);
        result = FieldScanner.ModifyHash(result, _initial_animation_time);
        result = FieldScanner.ModifyHash(result, unchanged_start_step);
        result = FieldScanner.ModifyHash(result, unchanged_finish_step);
        result = FieldScanner.ModifyHash(result, start_step);
        result = FieldScanner.ModifyHash(result, finish_step);
        return result;
    }

    public override bool Equals(object obj)
    {
        if (obj == null)
            return false;
        if (obj.GetType() != GetType())
            return false;
        var other = obj as RotateAnimatronic;
        return _initial_pose == other._initial_pose
            && _target_pose == other._target_pose
            && _target_position == other._target_position
            && _idle_animation == other._idle_animation
            && _time_to_rotate == other._time_to_rotate
            && _initial_animation_time == other._initial_animation_time
            && unchanged_start_step == other.unchanged_start_step
            && unchanged_finish_step == other.unchanged_finish_step
            && start_step == other.start_step
            && finish_step == other.finish_step
            && true;
    }

    public override int GetHashCode()
    {
        return (int)HashCode();
    }
    //END################################################################
}
