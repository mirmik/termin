using System.Collections.Generic;
using System;

#if UNITY_64
using UnityEngine;
#endif

public class PulledByAnimatronic : Animatronic
{
    ReferencedPose initial_pulled_pose;
    MovingAnimatronic referenced_animatronic;
    float direction_correction_steps = 1.0f * Utility.GAME_GLOBAL_FREQUENCY;

    float offset_distance = 1.0f;

    public PulledByAnimatronic(
        long start_step,
        long finish_step,
        MovingAnimatronic referenced_animatronic,
        ReferencedPose initial_pulled_pose
    ) : base(start_step, finish_step)
    {
        this.referenced_animatronic = referenced_animatronic;
        this.initial_pulled_pose = initial_pulled_pose;
    }

    public Vector3 InitialAdditionPosition()
    {
        var refer_position = referenced_animatronic.StartPose().LocalPosition();
        var initial_position = initial_pulled_pose.LocalPosition();
        return initial_position - refer_position;
    }

    Quaternion InitialRotation()
    {
        return initial_pulled_pose.LocalRotation();
    }

    Quaternion FinalRotation()
    {
        return referenced_animatronic.TargetRotation();
    }

    public Vector3 FinalAdditionPosition(ITimeline timeline)
    {
        return referenced_animatronic.TargetRotation() * (-Vector3.forward) * offset_distance;
    }

    public Vector3 AdditionPosition(long step, ITimeline timeline)
    {
        var initial_position = InitialAdditionPosition();
        var final_position = FinalAdditionPosition(timeline);
        var coeff = (float)(step - StartStep) / (direction_correction_steps);
        if (coeff > 1.0f)
        {
            return final_position;
        }
        var mcoeff = Easing.OutQuad(coeff);
        var position = Vector3.Lerp(initial_position, final_position, mcoeff);
        return position;
    }

    Quaternion Rotation(long steps)
    {
        var initial_rotation = InitialRotation();
        var final_rotation = FinalRotation();
        var coeff = (float)(steps - StartStep) / (direction_correction_steps);
        if (coeff > 1.0f)
        {
            return final_rotation;
        }
        var mcoeff = Easing.OutQuad(coeff);
        var rotation = Quaternion.Slerp(initial_rotation, final_rotation, mcoeff);
        return rotation;
    }

    public override AnimationType GetAnimationType(long local_step)
    {
        return AnimationType.Dragged;
    }

    public override ReferencedPose GetReferencedPose(long stepstamp, ITimeline tl)
    {
        var referenced_pose = referenced_animatronic.GetReferencedPose(stepstamp, tl);

        Vector3 position = referenced_pose.LocalPosition() + AdditionPosition(stepstamp, tl);
        Quaternion rotation = Rotation(stepstamp);

        return new ReferencedPose(position, rotation, referenced_pose.Frame);
    }

    //BEGIN################################################################
    // This code was generated by FieldScanner

    public override long HashCode()
    {
        long result = 0;
        result = FieldScanner.ModifyHash(result, initial_pulled_pose);
        result = FieldScanner.ModifyHash(result, referenced_animatronic);
        result = FieldScanner.ModifyHash(result, direction_correction_steps);
        result = FieldScanner.ModifyHash(result, offset_distance);
        result = FieldScanner.ModifyHash(result, _initial_animation_time);
        result = FieldScanner.ModifyHash(result, unchanged_start_step);
        result = FieldScanner.ModifyHash(result, unchanged_finish_step);
        result = FieldScanner.ModifyHash(result, start_step);
        result = FieldScanner.ModifyHash(result, finish_step);
        return result;
    }

    public override bool Equals(object obj)
    {
        if (obj == null)
            return false;
        if (obj.GetType() != GetType())
            return false;
        var other = obj as PulledByAnimatronic;
        return initial_pulled_pose == other.initial_pulled_pose
            && referenced_animatronic == other.referenced_animatronic
            && direction_correction_steps == other.direction_correction_steps
            && offset_distance == other.offset_distance
            && _initial_animation_time == other._initial_animation_time
            && unchanged_start_step == other.unchanged_start_step
            && unchanged_finish_step == other.unchanged_finish_step
            && start_step == other.start_step
            && finish_step == other.finish_step
            && true;
    }

    public override int GetHashCode()
    {
        return (int)HashCode();
    }
    //END################################################################
}
