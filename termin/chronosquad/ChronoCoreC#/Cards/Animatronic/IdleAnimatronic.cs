using System.Collections.Generic;
using System;

#if UNITY_64
using UnityEngine;
#endif

public struct LookAroundSettings
{
    public float angle;
    public float frequency;

    public LookAroundSettings(float angle, float frequency)
    {
        this.angle = angle;
        this.frequency = frequency;
    }

    public override string ToString()
    {
        return string.Format("LookAroundSettings({0}, {1})", angle, frequency);
    }

    // operator ==
    public static bool operator ==(LookAroundSettings a, LookAroundSettings b)
    {
        return a.angle == b.angle && a.frequency == b.frequency;
    }

    // operator !=
    public static bool operator !=(LookAroundSettings a, LookAroundSettings b)
    {
        return !(a == b);
    }

    public override int GetHashCode()
    {
        int result = 0;
        result += angle.GetHashCode();
        result += frequency.GetHashCode();
        return result;
    }

    public override bool Equals(object obj)
    {
        if (obj == null)
            return false;

        if (obj.GetType() != GetType())
            return false;

        var other = (LookAroundSettings)obj;
        return angle == other.angle && frequency == other.frequency;
    }
}

public class IdleAnimatronic : Animatronic
{
    protected ReferencedPose _pose;
    protected AnimationType _idle_animation;
    protected Pose _local_camera_pose;
    protected LookAroundSettings _look_around;

    public IdleAnimatronic(
        long start_step,
        ReferencedPose pose,
        AnimationType idle_animation,
        Pose local_camera_pose,
        LookAroundSettings look_around = default
    ) : base(start_step, long.MaxValue)
    {
        _idle_animation = idle_animation;
        _pose = pose;
        _local_camera_pose = local_camera_pose;
        _look_around = look_around;
    }

    public override bool IsLooped()
    {
        return true;
    }

    public IdleAnimatronic() { }

    public override bool IsCroach(ITimeline tl)
    {
        return _idle_animation == AnimationType.CroachIdle
            || _idle_animation == AnimationType.LeanCroachRight
            || _idle_animation == AnimationType.LeanCroachLeft;
    }

    public override ReferencedPose GetReferencedPose(long stepstamp, ITimeline tl)
    {
        return _pose;
    }

    public Pose LocalPose()
    {
        return _pose.LocalPose();
    }

    public override AnimationType GetAnimationType(long local_step)
    {
        return _idle_animation;
    }

    public override Pose LocalCameraPose(ObjectOfTimeline obj, long local_step)
    {
        if (_look_around.angle == 0)
            return _local_camera_pose;

        var step_from_start = local_step - StartStep;
        var step_from_start_in_seconds = step_from_start / Utility.GAME_GLOBAL_FREQUENCY;
        var addpose = new Pose(
            new Vector3(0, 0, 0),
            Quaternion.Euler(
                0,
                Mathf.Sin(step_from_start_in_seconds * _look_around.frequency * 2 * Mathf.PI)
                    * _look_around.angle,
                0
            )
        );
        return _local_camera_pose * addpose;
    }

    //BEGIN################################################################
    // This code was generated by FieldScanner

    public override long HashCode()
    {
        long result = 0;
        result = FieldScanner.ModifyHash(result, _pose);
        result = FieldScanner.ModifyHash(result, _idle_animation);
        result = FieldScanner.ModifyHash(result, _local_camera_pose);
        result = FieldScanner.ModifyHash(result, _look_around);
        result = FieldScanner.ModifyHash(result, _initial_animation_time);
        result = FieldScanner.ModifyHash(result, unchanged_start_step);
        result = FieldScanner.ModifyHash(result, unchanged_finish_step);
        result = FieldScanner.ModifyHash(result, start_step);
        result = FieldScanner.ModifyHash(result, finish_step);
        return result;
    }

    public override bool Equals(object obj)
    {
        if (obj == null)
            return false;
        if (obj.GetType() != GetType())
            return false;
        var other = obj as IdleAnimatronic;
        return _pose == other._pose
            && _idle_animation == other._idle_animation
            && _local_camera_pose == other._local_camera_pose
            && _look_around == other._look_around
            && _initial_animation_time == other._initial_animation_time
            && unchanged_start_step == other.unchanged_start_step
            && unchanged_finish_step == other.unchanged_finish_step
            && start_step == other.start_step
            && finish_step == other.finish_step
            && true;
    }

    public override int GetHashCode()
    {
        return (int)HashCode();
    }
    //END################################################################
}
