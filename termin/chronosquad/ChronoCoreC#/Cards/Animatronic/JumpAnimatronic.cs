using System.Collections;
using System.Collections.Generic;
using System;
using System.Linq;

#if UNITY_64
using UnityEngine;
#endif

[Serializable]
public class JumpAnimatronic : Animatronic
{
    ReferencedPose _start_pose;
    ReferencedPose _finish_pose;

    public JumpAnimatronic(
        ReferencedPose start_pose,
        ReferencedPose finish_pose,
        long start_step,
        long finish_step
    ) : base(start_step, finish_step)
    {
        _start_pose = start_pose;
        _finish_pose = finish_pose;
    }

    public new Vector3 Position(long stepstamp, ITimeline tl)
    {
        if (stepstamp < StartStep)
        {
            return _start_pose.GlobalPosition(tl);
        }

        if (stepstamp > FinishStep)
        {
            return _finish_pose.GlobalPosition(tl);
        }

        var t = (float)(stepstamp - StartStep) / (float)(FinishStep - StartStep);
        var position = Vector3.Lerp(
            _start_pose.GlobalPosition(tl),
            _finish_pose.GlobalPosition(tl),
            t
        );
        return position;
    }

    public override bool CanBeInterruptedForAction()
    {
        return false;
    }

    Vector3 TargetDirection(ITimeline tl)
    {
        var diff = _finish_pose.GlobalPosition(tl) - _start_pose.GlobalPosition(tl);
        diff.y = 0;
        return diff.normalized;
    }

    public override ReferencedPose GetReferencedPose(long stepstamp, ITimeline tl)
    {
        if (stepstamp <= StartStep)
        {
            return _start_pose;
        }

        if (stepstamp >= FinishStep)
        {
            return _finish_pose;
        }

        var dir = Direction(stepstamp, tl);
        return new ReferencedPose(Position(stepstamp, tl), dir, null);
    }

    public new Vector3 Direction(long stepstamp, ITimeline tl)
    {
        if (stepstamp < StartStep)
        {
            return _start_pose.GlobalDirection(tl);
        }

        if (stepstamp > FinishStep)
        {
            return TargetDirection(tl);
        }

        var t = (float)(stepstamp - StartStep) / (float)(FinishStep - StartStep);
        var direction = Vector3.Lerp(_start_pose.GlobalDirection(tl), TargetDirection(tl), t);
        return direction;
    }

    override public AnimationType GetAnimationType(long local_step)
    {
        return AnimationType.Jump;
    }

    //BEGIN################################################################
    // This code was generated by FieldScanner

    public override long HashCode()
    {
        long result = 0;
        result = FieldScanner.ModifyHash(result, _start_pose);
        result = FieldScanner.ModifyHash(result, _finish_pose);
        result = FieldScanner.ModifyHash(result, _initial_animation_time);
        result = FieldScanner.ModifyHash(result, unchanged_start_step);
        result = FieldScanner.ModifyHash(result, unchanged_finish_step);
        result = FieldScanner.ModifyHash(result, start_step);
        result = FieldScanner.ModifyHash(result, finish_step);
        return result;
    }

    public override bool Equals(object obj)
    {
        if (obj == null)
            return false;
        if (obj.GetType() != GetType())
            return false;
        var other = obj as JumpAnimatronic;
        return _start_pose == other._start_pose
            && _finish_pose == other._finish_pose
            && _initial_animation_time == other._initial_animation_time
            && unchanged_start_step == other.unchanged_start_step
            && unchanged_finish_step == other.unchanged_finish_step
            && start_step == other.start_step
            && finish_step == other.finish_step
            && true;
    }

    public override int GetHashCode()
    {
        return (int)HashCode();
    }
    //END################################################################
}
