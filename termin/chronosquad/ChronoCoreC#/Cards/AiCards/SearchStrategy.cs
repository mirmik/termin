using System;
using System.Collections.Generic;
using UnityEngine;

public class SearchStrategy : GroupStrategy
{
    //Vector3 center;
    [IgnoreRefflectionAttribute]
    MyList<Vector3> points_of_interest;

    [IgnoreRefflectionAttribute]
    MyList<bool> checked_points;

    public SearchStrategy(long start_step, MyList<Vector3> points) : base(start_step)
    {
        points_of_interest = points;
        checked_points = new MyList<bool>(points.Count);
        for (int i = 0; i < points.Count; i++)
            checked_points.Add(false);
    }

    MyList<string> ActorList(GroupController group)
    {
        var actor_list = group.ActorList();
        return actor_list;
    }

    bool IsNeedNewCommand(Actor actor)
    {
        var cmd = actor.CommandBuffer().GetCommandQueue().Current();
        if (cmd == null)
            return true;
        if (cmd is MovingCommand)
            return false;
        return true;
    }

    public Vector3 GetNearestPoint(Actor actor)
    {
        var actor_pos = actor.Position();
        double min_dist = double.MaxValue;
        Vector3 min_point = new Vector3(0, 0, 0);
        for (int i = 0; i < points_of_interest.Count; i++)
        {
            var pnt = points_of_interest[i];
            var dist = Vector3.Distance(actor_pos, pnt);
            if (dist < min_dist)
            {
                min_dist = dist;
                min_point = pnt;
            }
        }
        return min_point;
    }

    public void PointCheckedEvent(Vector3 point, GroupController group)
    {
        var ev = new ChangeSearchStrategyStatus_PointChecked(StartStep, point);
        group.AddCard(ev);
    }

    public override void Execute(ITimeline tl, ObjectOfTimeline priv)
    {
        var group = priv as GroupController;
        var actor_list = ActorList(group);

        double min_dist = double.MaxValue;
        Actor min_actor = null;
        Vector3 min_point = new Vector3(0, 0, 0);
        foreach (var aname in actor_list)
        {
            var a = tl.GetActor(aname);
            bool need_command = IsNeedNewCommand(a);
            if (need_command)
            {
                var point = GetNearestPoint(a);
                var dist = Vector3.Distance(a.Position(), point);

                if (dist < 0.1)
                {
                    PointCheckedEvent(point, group);
                    continue;
                }

                if (dist < min_dist)
                {
                    min_dist = dist;
                    min_actor = a;
                    min_point = point;
                }
            }
        }

        if (min_actor != null)
        {
            var cmd = new MovingCommand(
                new ReferencedPoint(min_point, null),
                WalkingType.Walk,
                min_actor.LocalStep() + 1
            );
            min_actor.AddInternalCommand(cmd);
        }
    }

    public int GetPointIndex(Vector3 pnt)
    {
        return points_of_interest.IndexOf(pnt);
    }

    public void SetPointChecked(int index, bool value)
    {
        checked_points[index] = value;
    }

    //BEGIN################################################################
    // This code was generated by FieldScanner

    public override long HashCode()
    {
        long result = 0;
        result = FieldScanner.ModifyHash(result, start_step);
        result = FieldScanner.ModifyHash(result, finish_step);
        return result;
    }

    public override bool Equals(object obj)
    {
        if (obj == null)
            return false;
        if (obj.GetType() != GetType())
            return false;
        var other = obj as SearchStrategy;
        return start_step == other.start_step && finish_step == other.finish_step && true;
    }

    public override int GetHashCode()
    {
        return (int)HashCode();
    }
    //END################################################################
}
