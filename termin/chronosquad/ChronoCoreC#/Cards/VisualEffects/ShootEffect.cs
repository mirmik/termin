#if UNITY_64
using UnityEngine;
#endif

using System;

class ShootEffectEvent : GlobalEvent
{
    float audio_start_time = 0.4f;

    private Vector3 position1;
    private Vector3 position2;

    [IgnoreRefflectionAttribute]
    double audio_modif = 0.0f;

    [IgnoreRefflectionAttribute]
    private Material ShootEffectMaterial;

    [IgnoreRefflectionAttribute]
    private LineRenderer line_renderer;

    [IgnoreRefflectionAttribute]
    private AudioSource audio_source;

    public ShootEffectEvent(
        long start_step,
        long finish_step,
        Vector3 position1,
        Vector3 position2,
        string ShootEffectMaterial = "ShootEffectMaterial"
    ) : base(start_step, finish_step)
    {
        this.position1 = position1;
        this.position2 = position2;
        if (MaterialKeeper.Instance == null)
            this.ShootEffectMaterial = null;
        else
            this.ShootEffectMaterial = new Material(
                MaterialKeeper.Instance.GetMaterial(ShootEffectMaterial)
            );
    }

    public override void on_enter(long current_step, ITimeline tl)
    {
        if (tl.IsTimeSpirit)
            return;

        var clip = MaterialKeeper.Instance?.GetAudioClip("Blaster");

        var ao = new GameObject("ShootEffectAudio");
        audio_source = ao.AddComponent<AudioSource>();
        audio_source.clip = clip;
        audio_source.volume = 0.5f;
        audio_source.time = audio_start_time;
        audio_source.Play();

        var lo = new GameObject("ShootEffectEvent");
        line_renderer = lo.AddComponent<LineRenderer>();
        line_renderer.enabled = true;
        line_renderer.material = ShootEffectMaterial;
        line_renderer.startWidth = 0.05f;
        line_renderer.endWidth = 0.05f;
        line_renderer.startColor = Color.red;
        line_renderer.endColor = Color.red;
        line_renderer.material = ShootEffectMaterial;
        line_renderer.SetPosition(0, position1);
        line_renderer.SetPosition(1, position2);
        update(current_step, tl);
    }

    public override void on_leave(long current_step, ITimeline tl)
    {
        if (tl.IsTimeSpirit)
            return;

        if (line_renderer != null)
        {
            GameObject.Destroy(line_renderer.gameObject);
            line_renderer = null;
        }

        if (audio_source != null)
        {
            GameObject.Destroy(audio_source.gameObject);
            audio_source = null;
        }
    }

    public override void update(long current_step, ITimeline tl)
    {
        if (tl.IsTimeSpirit)
            return;

        if (line_renderer == null)
        {
            // Костыль при копировании события
            on_enter(current_step, tl);
        }

        float distance = Vector3.Distance(position1, position2);
        float blaster_size = 2.0f;

        float phase = (current_step - StartStep) / (float)(FinishStep - StartStep);
        Vector3 center = Vector3.Lerp(position1, position2, phase);

        Vector3 diff = position2 - position1;
        Vector3 udiff = diff.normalized;

        float ss_distance_param = -blaster_size;
        float sf_distance_param = distance;

        float a_param = Mathf.Lerp(ss_distance_param, sf_distance_param, phase);
        float b_param = a_param + blaster_size;

        if (a_param < 0)
        {
            a_param = 0;
        }

        if (b_param > distance)
        {
            b_param = distance;
        }

        Vector3 start_point = position1 + udiff * a_param;
        Vector3 end_point = position1 + udiff * b_param;

        line_renderer.SetPosition(0, start_point);
        line_renderer.SetPosition(1, end_point);

        double modif = 1.0f;
        if (tl.GetChronoSphere() != null)
            modif = tl.GetChronoSphere().GetAudioTimeScale();

        if (audio_modif != modif)
        {
            audio_source.pitch = (float)modif;
            float audio_time = FinishTime - StartTime;
            var current_time = audio_source.time;
            var evaluated_time = audio_start_time + phase * audio_time;

            if (Mathf.Abs(evaluated_time - current_time) > 0.2f)
                audio_source.time = evaluated_time;

            audio_modif = modif;
        }
    }

    //BEGIN################################################################
    // This code was generated by FieldScanner

    public override long HashCode()
    {
        long result = 0;
        result = FieldScanner.ModifyHash(result, audio_start_time);
        result = FieldScanner.ModifyHash(result, position1);
        result = FieldScanner.ModifyHash(result, position2);
        result = FieldScanner.ModifyHash(result, start_step);
        result = FieldScanner.ModifyHash(result, finish_step);
        return result;
    }

    public override bool Equals(object obj)
    {
        if (obj == null)
            return false;
        if (obj.GetType() != GetType())
            return false;
        var other = obj as ShootEffectEvent;
        return audio_start_time == other.audio_start_time
            && position1 == other.position1
            && position2 == other.position2
            && start_step == other.start_step
            && finish_step == other.finish_step
            && true;
    }

    public override int GetHashCode()
    {
        return (int)HashCode();
    }
    //END################################################################
}
