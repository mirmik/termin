using System.Collections.Generic;
using Microsoft.VisualBasic;

#if UNITY_64
using UnityEngine;
#endif

using System;
using System.Linq;

abstract public class Ability
{
    protected long cooldown = 3 * (long)Utility.GAME_GLOBAL_FREQUENCY;

    public Ability() { }

    public Ability(float cooldown)
    {
        this.cooldown = (long)(cooldown * Utility.GAME_GLOBAL_FREQUENCY);
    }

    public virtual bool CanUseAbility(ObjectOfTimeline target_actor)
    {
        return true;
    }

    public virtual void UseOnObjectImpl(
        ObjectOfTimeline target_actor,
        ITimeline tl,
        IAbilityListPanel last_used_stamp
    ) { }

    public virtual void UseOnEnvironmentImpl(
        ReferencedPoint target_position,
        ITimeline tl,
        IAbilityListPanel last_used_stamp,
        PrivateParameters private_parameters
    ) { }

    public virtual void UseSelfImpl(ITimeline tl, IAbilityListPanel last_used_stamp) { }

    public void UseOnObject(
        ObjectOfTimeline target_actor,
        ITimeline tl,
        IAbilityListPanel last_used_stamp,
        bool ignore_cooldown = false
    )
    {
        if (!ignore_cooldown && !CanUse(tl, last_used_stamp))
            return;
        UseOnObjectImpl(target_actor, tl, last_used_stamp);
        var local_step = last_used_stamp.Actor().LocalStep();

        if (cooldown > 0)
            last_used_stamp.AddCooldown(this.GetType(), local_step, local_step + cooldown);
    }

    public void UseOnEnvironment(
        ReferencedPoint target_position,
        ITimeline tl,
        IAbilityListPanel last_used_stamp,
        PrivateParameters private_parameters,
        bool ignore_cooldown = false
    )
    {
        if (!ignore_cooldown && !CanUse(tl, last_used_stamp))
            return;
        UseOnEnvironmentImpl(target_position, tl, last_used_stamp, private_parameters);
        var local_step = last_used_stamp.Actor().LocalStep();

        if (cooldown > 0)
            last_used_stamp.AddCooldown(this.GetType(), local_step, local_step + cooldown);
    }

    public void UseSelf(
        ITimeline tl,
        IAbilityListPanel last_used_stamp,
        bool ignore_cooldown = false
    )
    {
        if (!ignore_cooldown && !CanUse(tl, last_used_stamp))
            return;
        UseSelfImpl(tl, last_used_stamp);
        var local_step = last_used_stamp.Actor().LocalStep();

        if (cooldown > 0)
            last_used_stamp.AddCooldown(this.GetType(), local_step, local_step + cooldown);
    }

    public float CooldownTime()
    {
        return cooldown / (float)Utility.GAME_GLOBAL_FREQUENCY;
    }

    public virtual void SetParameter(string name, float value) { }

    public float Cooldown()
    {
        return cooldown;
    }

    virtual public void HookInstall(ObjectOfTimeline l) { }

    public float DisplayableCooldown(ITimeline tl, IAbilityListPanel last_used_stamp)
    {
        return last_used_stamp.DisplayableCooldown(this.GetType());
    }

    public bool CanUse(ITimeline tl, IAbilityListPanel last_used_stamp)
    {
        bool has_active_cooldown = last_used_stamp.HasActiveCooldown(this.GetType());
        return !has_active_cooldown;
    }

    public virtual string info()
    {
        string typestr = this.GetType().ToString();
        return typestr;
    }
}

public interface IAbilityListPanel
{
    public ObjectOfTimeline Actor();
    public ObjectOfTimeline Object();
    public string ActorName();
    public bool HasActiveCooldown(System.Type type);
    public float DisplayableCooldown(System.Type type);
    public void AddCooldown(System.Type type, long start, long finish);
}

public class CooldownRecord : BasicMultipleAction
{
    public Type type;

    public CooldownRecord(long start, long finish, Type type) : base(start, finish)
    {
        this.type = type;
    }

    //BEGIN################################################################
    // This code was generated by FieldScanner

    public override long HashCode()
    {
        long result = 0;
        result = FieldScanner.ModifyHash(result, type);
        result = FieldScanner.ModifyHash(result, start_step);
        result = FieldScanner.ModifyHash(result, finish_step);
        return result;
    }

    public override bool Equals(object obj)
    {
        if (obj == null)
            return false;
        if (obj.GetType() != GetType())
            return false;
        var other = obj as CooldownRecord;
        return type == other.type
            && start_step == other.start_step
            && finish_step == other.finish_step
            && true;
    }

    public override int GetHashCode()
    {
        return (int)HashCode();
    }
    //END################################################################
}

public class AbilityList : IAbilityListPanel
{
    ObjectOfTimeline owner;

    MyList<Ability> list = new MyList<Ability>();

    //Dictionary<Ability, long> last_used_stamp = new Dictionary<Ability, long>();
    bool prevent_ability_add = false;

    MultipleActionList<CooldownRecord> cooldowns = new MultipleActionList<CooldownRecord>(true);

    public Dictionary<string, object> ToTrent()
    {
        Dictionary<string, object> dict = new Dictionary<string, object>();
        dict["owner"] = owner.Name();
        //dict["list"] = list.Select(x => x.GetType().ToString()).ToList();
        //dict["last_used_stamp"] = last_used_stamp.ToDictionary(
        //	x => x.Key.GetType().ToString(),
        //	x => x.Value
        //);
        return dict;
    }

    public void DropToCurrentState(long step)
    {
        cooldowns.DropToCurrentState();
    }

    public void FromTrent(Dictionary<string, object> dict)
    {
        //	owner = Actor.Find((string)dict["owner"]);
        //	list = ((MyList<string>)dict["list"]).Select(x => (Ability)Activator.CreateInstance(Type.GetType(x))).ToList();
        //	last_used_stamp = ((Dictionary<string, long>)dict["last_used_stamp"]).ToDictionary(x => (Ability)Activator.CreateInstance(Type.GetType(x.Key)), x => x.Value);
    }

    public void AddCooldown(System.Type type, long start, long finish)
    {
        cooldowns.Add(new CooldownRecord(start, finish, type));
    }

    public ObjectOfTimeline Actor()
    {
        return owner;
    }

    public ObjectOfTimeline Object()
    {
        return owner;
    }

    public string ActorName()
    {
        return owner.Name();
    }

    // public long LastUsed<T>() where T : Ability
    // {
    // 	return LastUsed(typeof(T));
    // }

    public void SetLastUsed<T>(long last_used_stamp) where T : Ability
    {
        SetLastUsed(typeof(T), last_used_stamp);
    }

    public long LastUsed(System.Type type)
    {
        return 0;
        //return last_used_stamp[GetAbility(type)];
    }

    public bool HasActiveCooldown(System.Type type)
    {
        var active = cooldowns.ActiveStates();
        foreach (var state in active)
        {
            if (state.type == type)
                return true;
        }
        return false;
    }

    public float GetCooldownPercent<T>() where T : Ability
    {
        return GetCooldownPercent(typeof(T));
    }

    public bool CanUse<T>(ITimeline tl) where T : Ability
    {
        foreach (var ability in list)
        {
            if (ability is T)
            {
                return ability.CanUse(tl, this);
            }
        }
        return false;
    }

    public float GetCooldownPercent(System.Type type)
    {
        if (!Contains(type))
        {
            Debug.Log("Ability not found: " + type.ToString());
            return 100.0f;
        }

        var value = DisplayableCooldown(type) * 100.0f;
        if (value > 100.0f)
            return 100.0f;
        return value;
    }

    public float DisplayableCooldown(System.Type type)
    {
        var active = cooldowns.ActiveStates();
        foreach (var state in active)
        {
            if (state.type == type)
            {
                long length = state.FinishStep - state.StartStep;
                long current = owner.LocalStep() - state.StartStep;
                return 1.0f - (float)current / (float)length;
            }
        }
        return 1.0f;
    }

    public void PromoteCooldowns()
    {
        MyList<CooldownRecord> goned;
        MyList<CooldownRecord> added;
        cooldowns.Promote(owner.LocalStep(), out goned, out added);
    }

    public void SetLastUsed(System.Type type, long last_used_stamp)
    {
        //this.last_used_stamp[GetAbility(type)] = last_used_stamp;
    }

    public AbilityList(ObjectOfTimeline owner)
    {
        this.owner = owner;
    }

    public AbilityList Copy(ObjectOfTimeline newowner)
    {
        var alist = new AbilityList(newowner);
        alist.cooldowns = new MultipleActionList<CooldownRecord>(cooldowns);
        alist.list = new MyList<Ability>();

        foreach (var ability in list)
        {
            alist._AddAbility(ability);
        }
        alist.prevent_ability_add = true;
        return alist;
    }

    private void AddAbility(Ability ability)
    {
        // Use AddOrChange method instead

        if (prevent_ability_add)
            return;

        _AddAbility(ability);
    }

    private void _AddAbility(Ability ability)
    {
        list.Add(ability);
        ability.HookInstall(owner);
    }

    public bool Contains<T>()
    {
        foreach (var ability in list)
        {
            if (ability is T)
                return true;
        }
        return false;
    }

    public bool Contains(System.Type type)
    {
        foreach (var ability in list)
        {
            if (ability.GetType() == type)
                return true;
        }
        return false;
    }

    public Ability AddOrChange(Ability abil)
    {
        var type = abil.GetType();
        if (Contains(type))
        {
            list[IndexOfAbility(type)] = abil;
            return abil;
        }
        else
        {
            AddAbility(abil);
            return abil;
        }
    }

    int IndexOfAbility(System.Type type)
    {
        for (int i = 0; i < list.Count; i++)
        {
            if (list[i].GetType() == type)
                return i;
        }
        return -1;
    }

    public Ability GetAbility<T>() where T : Ability
    {
        foreach (var ability in list)
        {
            if (ability is T)
                return ability;
        }
        return null;
    }

    public Ability GetAbility(System.Type type)
    {
        foreach (var ability in list)
        {
            if (ability.GetType() == type)
                return ability;
        }
        return null;
    }
}
