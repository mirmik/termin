description: "Добавление поддержки внутренних точек в FramePass и корректных тестов, проверяющих работу FrameGraph с ними."
language: "python"
operations:
  - op: replace_py_block
    path: termin/visualization/render/framegraph/core.py
    comment: "Расширяем FramePass полями и методами для внутренних точек дебага, сохраняя dataclass-семантику."
    marker: |
      class FramePass:
    payload: |
      class FramePass:
          """
          Логический проход кадра.

          reads  – какие ресурсы этот проход читает (по именам).
          writes – какие ресурсы он пишет.
          inplace – модифицирующий ли это проход (in-place по смыслу).

          Внутренние точки (internal debug points):
              Некоторые пассы могут объявлять «внутренние» точки наблюдения,
              связанные с их внутренними сущностями (например, отдельные меши,
              стадии рендера и т.п.). По умолчанию проход не имеет таких точек.
          """
          pass_name: str
          reads: Set[str] = field(default_factory=set)
          writes: Set[str] = field(default_factory=set)
          inplace: bool = False

          # Конфигурация внутренней точки дебага (символ и целевой ресурс).
          debug_internal_symbol: str | None = None
          debug_internal_output: str | None = None

          def __repr__(self) -> str:
              return f"FramePass({self.pass_name!r})"

          # ---- API внутренних точек ---------------------------------------------

          def get_internal_symbols(self) -> List[str]:
              """
              Возвращает список доступных внутренних символов/точек для этого пасса.

              Базовая реализация ничего не знает о внутренних точках и
              возвращает пустой список. Конкретные реализации пассов могут
              переопределять метод и формировать список динамически.
              """
              return []

          def set_debug_internal_point(
              self,
              symbol: str | None,
              output_res: str | None = None,
          ) -> None:
              """
              Устанавливает (или сбрасывает) активную внутреннюю точку дебага.

              symbol:
                  Имя внутреннего символа, на который следует «подписаться».
                  None — сброс настройки.
              output_res:
                  Имя ресурса (FBO), в который пасс при необходимости
                  должен выводить состояние для выбранного символа.
              """
              self.debug_internal_symbol = symbol
              self.debug_internal_output = output_res

          def get_debug_internal_point(self) -> tuple[str | None, str | None]:
              """
              Текущая конфигурация внутренней точки дебага:
              (symbol, output_res).
              """
              return self.debug_internal_symbol, self.debug_internal_output

  - op: delete_file
    path: tests/test_framegraph_internal_points.py
    comment: "Удаляем предыдущую версию теста для внутренних точек (если была)."

  - op: create_file
    path: tests/test_framegraph_internal_points.py
    comment: "Новые юнит-тесты для проверки API внутренних точек и того, что FrameGraph корректно работает с ними."
    payload: |
      from __future__ import annotations

      from termin.visualization.render.framegraph.core import FrameGraph, FramePass


      class DummyPass(FramePass):
          def __init__(self, name: str, reads=None, writes=None, inplace: bool = False):
              if reads is None:
                  reads = set()
              if writes is None:
                  writes = set()
              super().__init__(
                  pass_name=name,
                  reads=set(reads),
                  writes=set(writes),
                  inplace=inplace,
              )
              self._internal_symbols = ["a", "b", "c"]

          def get_internal_symbols(self) -> list[str]:
              return list(self._internal_symbols)


      def test_framepass_has_no_internal_symbols_by_default():
          p = FramePass(pass_name="simple")
          assert p.get_internal_symbols() == []


      def test_custom_pass_can_expose_internal_symbols():
          p = DummyPass(name="dummy")
          assert p.get_internal_symbols() == ["a", "b", "c"]


      def test_debug_internal_point_configuration_is_mutable():
          p = FramePass(pass_name="p", reads={"in"}, writes={"out"})
          # по умолчанию точки дебага не заданы
          assert p.debug_internal_symbol is None
          assert p.debug_internal_output is None
          assert p.get_debug_internal_point() == (None, None)

          # можно задать и прочитать конфигурацию
          p.set_debug_internal_point("foo", "debug_out")
          assert p.debug_internal_symbol == "foo"
          assert p.debug_internal_output == "debug_out"
          assert p.get_debug_internal_point() == ("foo", "debug_out")

          # и сбросить её обратно
          p.set_debug_internal_point(None, None)
          assert p.debug_internal_symbol is None
          assert p.debug_internal_output is None
          assert p.get_debug_internal_point() == (None, None)


      def test_framegraph_builds_with_and_without_debug_internal_point():
          """
          Граф должен:
          * корректно строиться, когда у пассов есть внутренние символы,
            но точка дебага не выбрана;
          * так же корректно строиться, когда точка дебага выбрана
            (в том числе с указанием отдельного ресурса вывода).
          В обоих случаях alias-группы зависят только от reads/writes,
          а не от настроек внутренних точек.
          """
          p1 = FramePass(pass_name="A", reads=set(), writes={"a"})
          p2 = DummyPass(name="B", reads={"a"}, writes={"b"})

          # 1) Без конфигурации точки дебага
          graph1 = FrameGraph([p1, p2])
          schedule1 = [p.pass_name for p in graph1.build_schedule()]
          assert schedule1 == ["A", "B"]

          groups1 = graph1.fbo_alias_groups()
          # оба ресурса независимы и имеют свои канонические имена
          assert groups1["a"] == {"a"}
          assert groups1["b"] == {"b"}
          # debug-ресурс не фигурирует, так как мы его не задавали
          assert "debug_b" not in groups1

          # 2) С установленной точкой дебага на втором пассе
          p2.set_debug_internal_point("b", "debug_b")

          graph2 = FrameGraph([p1, p2])
          schedule2 = [p.pass_name for p in graph2.build_schedule()]
          # порядок выполнения не должен измениться
          assert schedule2 == ["A", "B"]

          groups2 = graph2.fbo_alias_groups()
          # alias-группы по-прежнему зависят только от reads/writes
          assert groups2["a"] == {"a"}
          assert groups2["b"] == {"b"}
          # debug-ресурс не попадает в alias-группы, так как FrameGraph
          # не рассматривает его как обычный выход пасса
          assert "debug_b" not in groups2
          # canonical_resource для debug-ресурса должен вернуть его же имя
          # (FrameGraph о нём ничего не знает)
          assert graph2.canonical_resource("debug_b") == "debug_b"
