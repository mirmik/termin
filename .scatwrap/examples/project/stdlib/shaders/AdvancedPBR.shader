<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>examples/project/stdlib/shaders/AdvancedPBR.shader</title>
</head>
<body>
<!-- BEGIN SCAT CODE -->
@program&nbsp;AdvancedPBR<br>
@features&nbsp;lighting_ubo<br>
<br>
@phases&nbsp;opaque,&nbsp;transparent<br>
<br>
@settings&nbsp;transparent<br>
@glDepthMask&nbsp;false<br>
@glBlend&nbsp;true<br>
@glCull&nbsp;true<br>
<br>
@property&nbsp;Color&nbsp;u_color&nbsp;=&nbsp;Color(1.0,&nbsp;1.0,&nbsp;1.0,&nbsp;1.0)<br>
@property&nbsp;Float&nbsp;u_metallic&nbsp;=&nbsp;0.0&nbsp;range(0.0,&nbsp;1.0)<br>
@property&nbsp;Float&nbsp;u_roughness&nbsp;=&nbsp;0.5&nbsp;range(0.0,&nbsp;1.0)<br>
@property&nbsp;Float&nbsp;u_subsurface&nbsp;=&nbsp;0.0&nbsp;range(0.0,&nbsp;1.0)<br>
@property&nbsp;Texture2D&nbsp;u_albedo_texture&nbsp;=&nbsp;&quot;white&quot;<br>
<br>
@stage&nbsp;vertex<br>
#version&nbsp;330&nbsp;core<br>
<br>
layout(location&nbsp;=&nbsp;0)&nbsp;in&nbsp;vec3&nbsp;a_position;<br>
layout(location&nbsp;=&nbsp;1)&nbsp;in&nbsp;vec3&nbsp;a_normal;<br>
layout(location&nbsp;=&nbsp;2)&nbsp;in&nbsp;vec2&nbsp;a_uv;<br>
<br>
uniform&nbsp;mat4&nbsp;u_model;<br>
uniform&nbsp;mat4&nbsp;u_view;<br>
uniform&nbsp;mat4&nbsp;u_projection;<br>
<br>
out&nbsp;vec3&nbsp;v_world_pos;<br>
out&nbsp;vec3&nbsp;v_normal;<br>
out&nbsp;vec2&nbsp;v_uv;<br>
<br>
void&nbsp;main()&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec4&nbsp;world&nbsp;=&nbsp;u_model&nbsp;*&nbsp;vec4(a_position,&nbsp;1.0);<br>
&nbsp;&nbsp;&nbsp;&nbsp;v_world_pos&nbsp;=&nbsp;world.xyz;<br>
&nbsp;&nbsp;&nbsp;&nbsp;v_normal&nbsp;=&nbsp;mat3(transpose(inverse(u_model)))&nbsp;*&nbsp;a_normal;<br>
&nbsp;&nbsp;&nbsp;&nbsp;v_uv&nbsp;=&nbsp;a_uv;<br>
&nbsp;&nbsp;&nbsp;&nbsp;gl_Position&nbsp;=&nbsp;u_projection&nbsp;*&nbsp;u_view&nbsp;*&nbsp;world;<br>
}<br>
@endstage<br>
<br>
@stage&nbsp;fragment<br>
#version&nbsp;330&nbsp;core<br>
<br>
in&nbsp;vec3&nbsp;v_world_pos;<br>
in&nbsp;vec3&nbsp;v_normal;<br>
in&nbsp;vec2&nbsp;v_uv;<br>
<br>
#include&nbsp;&quot;lighting.glsl&quot;<br>
#include&nbsp;&quot;shadows.glsl&quot;<br>
<br>
//&nbsp;Material&nbsp;parameters<br>
uniform&nbsp;vec4&nbsp;u_color;<br>
uniform&nbsp;sampler2D&nbsp;u_albedo_texture;<br>
uniform&nbsp;float&nbsp;u_metallic;<br>
uniform&nbsp;float&nbsp;u_roughness;<br>
uniform&nbsp;float&nbsp;u_subsurface;<br>
<br>
out&nbsp;vec4&nbsp;FragColor;<br>
<br>
const&nbsp;float&nbsp;PI&nbsp;=&nbsp;3.14159265359;<br>
<br>
//&nbsp;Normal&nbsp;Distribution&nbsp;Function&nbsp;(GGX/Trowbridge-Reitz)<br>
float&nbsp;D_GGX(float&nbsp;NdotH,&nbsp;float&nbsp;roughness)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;a&nbsp;=&nbsp;roughness&nbsp;*&nbsp;roughness;<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;a2&nbsp;=&nbsp;a&nbsp;*&nbsp;a;<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;denom&nbsp;=&nbsp;NdotH&nbsp;*&nbsp;NdotH&nbsp;*&nbsp;(a2&nbsp;-&nbsp;1.0)&nbsp;+&nbsp;1.0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;a2&nbsp;/&nbsp;(PI&nbsp;*&nbsp;denom&nbsp;*&nbsp;denom);<br>
}<br>
<br>
//&nbsp;Geometry&nbsp;Function&nbsp;(Smith's&nbsp;method&nbsp;with&nbsp;GGX)<br>
float&nbsp;G_Smith(float&nbsp;NdotV,&nbsp;float&nbsp;NdotL,&nbsp;float&nbsp;roughness)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;r&nbsp;=&nbsp;roughness&nbsp;+&nbsp;1.0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;k&nbsp;=&nbsp;(r&nbsp;*&nbsp;r)&nbsp;/&nbsp;8.0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;G1_V&nbsp;=&nbsp;NdotV&nbsp;/&nbsp;(NdotV&nbsp;*&nbsp;(1.0&nbsp;-&nbsp;k)&nbsp;+&nbsp;k);<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;G1_L&nbsp;=&nbsp;NdotL&nbsp;/&nbsp;(NdotL&nbsp;*&nbsp;(1.0&nbsp;-&nbsp;k)&nbsp;+&nbsp;k);<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;G1_V&nbsp;*&nbsp;G1_L;<br>
}<br>
<br>
//&nbsp;Fresnel&nbsp;(Schlick&nbsp;approximation)<br>
vec3&nbsp;F_Schlick(float&nbsp;cosTheta,&nbsp;vec3&nbsp;F0)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;F0&nbsp;+&nbsp;(1.0&nbsp;-&nbsp;F0)&nbsp;*&nbsp;pow(clamp(1.0&nbsp;-&nbsp;cosTheta,&nbsp;0.0,&nbsp;1.0),&nbsp;5.0);<br>
}<br>
<br>
//&nbsp;SSS&nbsp;Approximation&nbsp;-&nbsp;wrap&nbsp;lighting<br>
float&nbsp;wrap_diffuse(float&nbsp;NdotL,&nbsp;float&nbsp;wrap)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;max(0.0,&nbsp;(NdotL&nbsp;+&nbsp;wrap)&nbsp;/&nbsp;(1.0&nbsp;+&nbsp;wrap));<br>
}<br>
<br>
//&nbsp;Subsurface&nbsp;color&nbsp;shift<br>
vec3&nbsp;subsurface_color(vec3&nbsp;albedo)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;albedo&nbsp;*&nbsp;vec3(1.0,&nbsp;0.4,&nbsp;0.25);<br>
}<br>
<br>
void&nbsp;main()&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;N&nbsp;=&nbsp;normalize(v_normal);<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;V&nbsp;=&nbsp;normalize(get_camera_position()&nbsp;-&nbsp;v_world_pos);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Sample&nbsp;albedo<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec4&nbsp;tex_color&nbsp;=&nbsp;texture(u_albedo_texture,&nbsp;v_uv);<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;albedo&nbsp;=&nbsp;u_color.rgb&nbsp;*&nbsp;tex_color.rgb;<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;alpha&nbsp;=&nbsp;u_color.a&nbsp;*&nbsp;tex_color.a;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;metallic&nbsp;=&nbsp;u_metallic;<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;roughness&nbsp;=&nbsp;max(u_roughness,&nbsp;0.04);<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;subsurface&nbsp;=&nbsp;u_subsurface;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;F0:&nbsp;reflectance&nbsp;at&nbsp;normal&nbsp;incidence<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;F0&nbsp;=&nbsp;mix(vec3(0.04),&nbsp;albedo,&nbsp;metallic);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Ambient<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;ambient&nbsp;=&nbsp;get_ambient_color()&nbsp;*&nbsp;get_ambient_intensity()&nbsp;*&nbsp;albedo&nbsp;*&nbsp;(1.0&nbsp;-&nbsp;metallic&nbsp;*&nbsp;0.5);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;Lo&nbsp;=&nbsp;vec3(0.0);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;get_light_count();&nbsp;++i)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;L;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;attenuation&nbsp;=&nbsp;1.0;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(get_light_type(i)&nbsp;==&nbsp;LIGHT_TYPE_DIRECTIONAL)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L&nbsp;=&nbsp;normalize(-get_light_direction(i));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;to_light&nbsp;=&nbsp;get_light_position(i)&nbsp;-&nbsp;v_world_pos;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;dist&nbsp;=&nbsp;length(to_light);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L&nbsp;=&nbsp;to_light&nbsp;/&nbsp;max(dist,&nbsp;0.0001);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attenuation&nbsp;=&nbsp;compute_distance_attenuation(get_light_attenuation(i),&nbsp;get_light_range(i),&nbsp;dist);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(get_light_type(i)&nbsp;==&nbsp;LIGHT_TYPE_SPOT)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attenuation&nbsp;*=&nbsp;compute_spot_weight(get_light_direction(i),&nbsp;L,&nbsp;get_light_inner_angle(i),&nbsp;get_light_outer_angle(i));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;H&nbsp;=&nbsp;normalize(V&nbsp;+&nbsp;L);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;NdotL_raw&nbsp;=&nbsp;dot(N,&nbsp;L);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;NdotL&nbsp;=&nbsp;max(NdotL_raw,&nbsp;0.0);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;NdotV&nbsp;=&nbsp;max(dot(N,&nbsp;V),&nbsp;0.001);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;NdotH&nbsp;=&nbsp;max(dot(N,&nbsp;H),&nbsp;0.0);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;HdotV&nbsp;=&nbsp;max(dot(H,&nbsp;V),&nbsp;0.0);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Cook-Torrance&nbsp;BRDF<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;D&nbsp;=&nbsp;D_GGX(NdotH,&nbsp;roughness);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;G&nbsp;=&nbsp;G_Smith(NdotV,&nbsp;NdotL,&nbsp;roughness);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;F&nbsp;=&nbsp;F_Schlick(HdotV,&nbsp;F0);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Specular<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;numerator&nbsp;=&nbsp;D&nbsp;*&nbsp;G&nbsp;*&nbsp;F;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;denominator&nbsp;=&nbsp;4.0&nbsp;*&nbsp;NdotV&nbsp;*&nbsp;NdotL&nbsp;+&nbsp;0.0001;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;specular&nbsp;=&nbsp;numerator&nbsp;/&nbsp;denominator;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Diffuse&nbsp;with&nbsp;energy&nbsp;conservation<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;kD&nbsp;=&nbsp;(1.0&nbsp;-&nbsp;F)&nbsp;*&nbsp;(1.0&nbsp;-&nbsp;metallic);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Standard&nbsp;diffuse<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;diffuse_standard&nbsp;=&nbsp;kD&nbsp;*&nbsp;albedo;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;SSS&nbsp;diffuse:&nbsp;wrap&nbsp;lighting&nbsp;+&nbsp;color&nbsp;shift<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;wrap_amount&nbsp;=&nbsp;subsurface&nbsp;*&nbsp;0.5;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;diffuse_wrap&nbsp;=&nbsp;wrap_diffuse(NdotL_raw,&nbsp;wrap_amount);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;sss_color&nbsp;=&nbsp;subsurface_color(albedo);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Blend&nbsp;between&nbsp;standard&nbsp;and&nbsp;SSS&nbsp;based&nbsp;on&nbsp;wrap&nbsp;region<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;sss_mask&nbsp;=&nbsp;max(0.0,&nbsp;diffuse_wrap&nbsp;-&nbsp;NdotL)&nbsp;*&nbsp;2.0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;diffuse_sss&nbsp;=&nbsp;kD&nbsp;*&nbsp;mix(albedo,&nbsp;sss_color,&nbsp;sss_mask&nbsp;*&nbsp;subsurface);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Final&nbsp;diffuse:&nbsp;blend&nbsp;between&nbsp;standard&nbsp;and&nbsp;SSS<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;diffuse_final&nbsp;=&nbsp;mix(diffuse_standard&nbsp;*&nbsp;NdotL,&nbsp;diffuse_sss&nbsp;*&nbsp;diffuse_wrap,&nbsp;subsurface);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Shadow&nbsp;(for&nbsp;directional&nbsp;lights)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;shadow&nbsp;=&nbsp;1.0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(get_light_type(i)&nbsp;==&nbsp;LIGHT_TYPE_DIRECTIONAL)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shadow&nbsp;=&nbsp;compute_shadow_auto(i);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Combine<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;radiance&nbsp;=&nbsp;get_light_color(i)&nbsp;*&nbsp;get_light_intensity(i)&nbsp;*&nbsp;attenuation;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lo&nbsp;+=&nbsp;(diffuse_final&nbsp;+&nbsp;specular&nbsp;*&nbsp;NdotL)&nbsp;*&nbsp;radiance&nbsp;*&nbsp;shadow;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;color&nbsp;=&nbsp;ambient&nbsp;+&nbsp;Lo;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;HDR&nbsp;output&nbsp;(tonemapping&nbsp;applied&nbsp;in&nbsp;post-process)<br>
&nbsp;&nbsp;&nbsp;&nbsp;FragColor&nbsp;=&nbsp;vec4(color,&nbsp;alpha);<br>
}<br>
@endstage<br>
<!-- END SCAT CODE -->
</body>
</html>
