<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>examples/project2/stdlib/glsl/shadows.glsl</title>
</head>
<body>
<!-- BEGIN SCAT CODE -->
/**<br>
&nbsp;*&nbsp;Shadow&nbsp;mapping&nbsp;utilities&nbsp;for&nbsp;Termin&nbsp;engine.<br>
&nbsp;*<br>
&nbsp;*&nbsp;Usage&nbsp;in&nbsp;your&nbsp;shader:<br>
&nbsp;*&nbsp;&nbsp;&nbsp;#include&nbsp;&quot;shadows.glsl&quot;<br>
&nbsp;*<br>
&nbsp;*&nbsp;This&nbsp;file&nbsp;declares&nbsp;all&nbsp;required&nbsp;uniforms&nbsp;automatically.<br>
&nbsp;*&nbsp;The&nbsp;engine&nbsp;sets&nbsp;these&nbsp;uniforms&nbsp;via&nbsp;upload_shadow_maps_to_shader().<br>
&nbsp;*<br>
&nbsp;*&nbsp;Functions:<br>
&nbsp;*&nbsp;&nbsp;&nbsp;float&nbsp;compute_shadow(int&nbsp;light_index)&nbsp;-&nbsp;hard&nbsp;shadow&nbsp;with&nbsp;hardware&nbsp;PCF<br>
&nbsp;*&nbsp;&nbsp;&nbsp;float&nbsp;compute_shadow_pcf(int&nbsp;light_index)&nbsp;-&nbsp;5x5&nbsp;PCF&nbsp;soft&nbsp;shadow<br>
&nbsp;*&nbsp;&nbsp;&nbsp;float&nbsp;compute_shadow_poisson(int&nbsp;light_index)&nbsp;-&nbsp;Poisson&nbsp;disk&nbsp;(best&nbsp;quality)<br>
&nbsp;*&nbsp;&nbsp;&nbsp;float&nbsp;compute_shadow_cascaded(int&nbsp;light_index)&nbsp;-&nbsp;CSM&nbsp;with&nbsp;cascade&nbsp;blending<br>
&nbsp;*&nbsp;&nbsp;&nbsp;float&nbsp;compute_shadow_auto(int&nbsp;light_index)&nbsp;-&nbsp;auto-select&nbsp;based&nbsp;on&nbsp;settings<br>
&nbsp;*<br>
&nbsp;*&nbsp;Required&nbsp;varying&nbsp;(must&nbsp;be&nbsp;defined&nbsp;in&nbsp;your&nbsp;shader):<br>
&nbsp;*&nbsp;&nbsp;&nbsp;in&nbsp;vec3&nbsp;v_world_pos;<br>
&nbsp;*/<br>
<br>
#ifndef&nbsp;SHADOWS_GLSL<br>
#define&nbsp;SHADOWS_GLSL<br>
<br>
#ifndef&nbsp;MAX_SHADOW_MAPS<br>
#define&nbsp;MAX_SHADOW_MAPS&nbsp;16<br>
#endif<br>
<br>
#ifndef&nbsp;MAX_LIGHTS<br>
#define&nbsp;MAX_LIGHTS&nbsp;8<br>
#endif<br>
<br>
#ifndef&nbsp;SHADOW_BIAS<br>
#define&nbsp;SHADOW_BIAS&nbsp;0.005<br>
#endif<br>
<br>
//&nbsp;Shadow&nbsp;map&nbsp;uniforms&nbsp;(set&nbsp;by&nbsp;engine)<br>
uniform&nbsp;int&nbsp;u_shadow_map_count;<br>
uniform&nbsp;sampler2DShadow&nbsp;u_shadow_map[MAX_SHADOW_MAPS];<br>
uniform&nbsp;mat4&nbsp;u_light_space_matrix[MAX_SHADOW_MAPS];<br>
uniform&nbsp;int&nbsp;u_shadow_light_index[MAX_SHADOW_MAPS];<br>
<br>
//&nbsp;Cascade&nbsp;uniforms&nbsp;(set&nbsp;by&nbsp;engine)<br>
uniform&nbsp;int&nbsp;u_shadow_cascade_index[MAX_SHADOW_MAPS];<br>
uniform&nbsp;float&nbsp;u_shadow_split_near[MAX_SHADOW_MAPS];<br>
uniform&nbsp;float&nbsp;u_shadow_split_far[MAX_SHADOW_MAPS];<br>
<br>
//&nbsp;Per-light&nbsp;cascade&nbsp;settings&nbsp;(only&nbsp;if&nbsp;lighting.glsl&nbsp;not&nbsp;included)<br>
#ifndef&nbsp;LIGHTING_GLSL<br>
uniform&nbsp;int&nbsp;u_light_cascade_count[MAX_LIGHTS];<br>
uniform&nbsp;int&nbsp;u_light_cascade_blend[MAX_LIGHTS];<br>
uniform&nbsp;float&nbsp;u_light_blend_distance[MAX_LIGHTS];<br>
#endif<br>
<br>
//&nbsp;View&nbsp;matrix&nbsp;for&nbsp;computing&nbsp;view-space&nbsp;depth<br>
uniform&nbsp;mat4&nbsp;u_view;<br>
<br>
//&nbsp;Shadow&nbsp;settings&nbsp;accessors<br>
//&nbsp;If&nbsp;lighting.glsl&nbsp;is&nbsp;included,&nbsp;use&nbsp;its&nbsp;accessors;&nbsp;otherwise&nbsp;define&nbsp;our&nbsp;own&nbsp;uniforms<br>
<br>
#ifdef&nbsp;LIGHTING_GLSL<br>
//&nbsp;lighting.glsl&nbsp;is&nbsp;included&nbsp;-&nbsp;use&nbsp;its&nbsp;accessors<br>
int&nbsp;_get_shadow_method_val()&nbsp;{&nbsp;return&nbsp;get_shadow_method();&nbsp;}<br>
float&nbsp;_get_shadow_softness_val()&nbsp;{&nbsp;return&nbsp;get_shadow_softness();&nbsp;}<br>
float&nbsp;_get_shadow_bias_val()&nbsp;{&nbsp;return&nbsp;get_shadow_bias();&nbsp;}<br>
int&nbsp;_get_cascade_count(int&nbsp;i)&nbsp;{&nbsp;return&nbsp;get_light_cascade_count(i);&nbsp;}<br>
int&nbsp;_get_cascade_blend(int&nbsp;i)&nbsp;{&nbsp;return&nbsp;get_light_cascade_blend(i);&nbsp;}<br>
float&nbsp;_get_blend_distance(int&nbsp;i)&nbsp;{&nbsp;return&nbsp;get_light_blend_distance(i);&nbsp;}<br>
#else<br>
//&nbsp;lighting.glsl&nbsp;not&nbsp;included&nbsp;-&nbsp;define&nbsp;our&nbsp;own&nbsp;uniforms<br>
uniform&nbsp;int&nbsp;u_shadow_method;<br>
uniform&nbsp;float&nbsp;u_shadow_softness;<br>
uniform&nbsp;float&nbsp;u_shadow_bias;<br>
<br>
int&nbsp;_get_shadow_method_val()&nbsp;{&nbsp;return&nbsp;u_shadow_method;&nbsp;}<br>
float&nbsp;_get_shadow_softness_val()&nbsp;{&nbsp;return&nbsp;u_shadow_softness;&nbsp;}<br>
float&nbsp;_get_shadow_bias_val()&nbsp;{&nbsp;return&nbsp;u_shadow_bias;&nbsp;}<br>
int&nbsp;_get_cascade_count(int&nbsp;i)&nbsp;{&nbsp;return&nbsp;u_light_cascade_count[i];&nbsp;}<br>
int&nbsp;_get_cascade_blend(int&nbsp;i)&nbsp;{&nbsp;return&nbsp;u_light_cascade_blend[i];&nbsp;}<br>
float&nbsp;_get_blend_distance(int&nbsp;i)&nbsp;{&nbsp;return&nbsp;u_light_blend_distance[i];&nbsp;}<br>
#endif<br>
<br>
//&nbsp;16-sample&nbsp;Poisson&nbsp;disk&nbsp;for&nbsp;high-quality&nbsp;shadow&nbsp;sampling<br>
const&nbsp;int&nbsp;POISSON_SAMPLES&nbsp;=&nbsp;16;<br>
const&nbsp;vec2&nbsp;poissonDisk[16]&nbsp;=&nbsp;vec2[](<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec2(-0.94201624,&nbsp;-0.39906216),<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec2(&nbsp;0.94558609,&nbsp;-0.76890725),<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec2(-0.09418410,&nbsp;-0.92938870),<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec2(&nbsp;0.34495938,&nbsp;&nbsp;0.29387760),<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec2(-0.91588581,&nbsp;&nbsp;0.45771432),<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec2(-0.81544232,&nbsp;-0.87912464),<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec2(-0.38277543,&nbsp;&nbsp;0.27676845),<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec2(&nbsp;0.97484398,&nbsp;&nbsp;0.75648379),<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec2(&nbsp;0.44323325,&nbsp;-0.97511554),<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec2(&nbsp;0.53742981,&nbsp;-0.47373420),<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec2(-0.26496911,&nbsp;-0.41893023),<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec2(&nbsp;0.79197514,&nbsp;&nbsp;0.19090188),<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec2(-0.24188840,&nbsp;&nbsp;0.99706507),<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec2(-0.81409955,&nbsp;&nbsp;0.91437590),<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec2(&nbsp;0.19984126,&nbsp;&nbsp;0.78641367),<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec2(&nbsp;0.14383161,&nbsp;-0.14100790)<br>
);<br>
<br>
/**<br>
&nbsp;*&nbsp;Get&nbsp;effective&nbsp;shadow&nbsp;bias&nbsp;(uniform&nbsp;or&nbsp;fallback&nbsp;to&nbsp;define).<br>
&nbsp;*/<br>
float&nbsp;_get_shadow_bias()&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;bias&nbsp;=&nbsp;_get_shadow_bias_val();<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;bias&nbsp;&gt;&nbsp;0.0&nbsp;?&nbsp;bias&nbsp;:&nbsp;SHADOW_BIAS;<br>
}<br>
<br>
/**<br>
&nbsp;*&nbsp;Sample&nbsp;single&nbsp;shadow&nbsp;map&nbsp;at&nbsp;given&nbsp;index&nbsp;using&nbsp;selected&nbsp;method.<br>
&nbsp;*/<br>
float&nbsp;_sample_shadow_map(int&nbsp;sm,&nbsp;vec3&nbsp;world_pos,&nbsp;float&nbsp;bias)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec4&nbsp;light_space_pos&nbsp;=&nbsp;u_light_space_matrix[sm]&nbsp;*&nbsp;vec4(world_pos,&nbsp;1.0);<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;proj_coords&nbsp;=&nbsp;light_space_pos.xyz&nbsp;/&nbsp;light_space_pos.w;<br>
&nbsp;&nbsp;&nbsp;&nbsp;proj_coords&nbsp;=&nbsp;proj_coords&nbsp;*&nbsp;0.5&nbsp;+&nbsp;0.5;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Bounds&nbsp;check<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(proj_coords.x&nbsp;&lt;&nbsp;0.0&nbsp;||&nbsp;proj_coords.x&nbsp;&gt;&nbsp;1.0&nbsp;||<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proj_coords.y&nbsp;&lt;&nbsp;0.0&nbsp;||&nbsp;proj_coords.y&nbsp;&gt;&nbsp;1.0&nbsp;||<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proj_coords.z&nbsp;&lt;&nbsp;0.0&nbsp;||&nbsp;proj_coords.z&nbsp;&gt;&nbsp;1.0)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1.0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;compare_depth&nbsp;=&nbsp;proj_coords.z&nbsp;-&nbsp;bias;<br>
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;method&nbsp;=&nbsp;_get_shadow_method_val();<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;softness&nbsp;=&nbsp;max(_get_shadow_softness_val(),&nbsp;0.0);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Use&nbsp;shadow&nbsp;method<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(method&nbsp;==&nbsp;0)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Hard&nbsp;shadow<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;texture(u_shadow_map[sm],&nbsp;vec3(proj_coords.xy,&nbsp;compare_depth));<br>
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;if&nbsp;(method&nbsp;==&nbsp;2)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Poisson<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec2&nbsp;texel_size&nbsp;=&nbsp;1.0&nbsp;/&nbsp;vec2(textureSize(u_shadow_map[sm],&nbsp;0));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;radius&nbsp;=&nbsp;2.5&nbsp;*&nbsp;softness;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;shadow&nbsp;=&nbsp;0.0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;POISSON_SAMPLES;&nbsp;++i)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec2&nbsp;offset&nbsp;=&nbsp;poissonDisk[i]&nbsp;*&nbsp;texel_size&nbsp;*&nbsp;radius;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shadow&nbsp;+=&nbsp;texture(u_shadow_map[sm],&nbsp;vec3(proj_coords.xy&nbsp;+&nbsp;offset,&nbsp;compare_depth));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;shadow&nbsp;/&nbsp;float(POISSON_SAMPLES);<br>
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;PCF&nbsp;5x5<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec2&nbsp;texel_size&nbsp;=&nbsp;1.0&nbsp;/&nbsp;vec2(textureSize(u_shadow_map[sm],&nbsp;0));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;shadow&nbsp;=&nbsp;0.0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;x&nbsp;=&nbsp;-2;&nbsp;x&nbsp;&lt;=&nbsp;2;&nbsp;++x)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;y&nbsp;=&nbsp;-2;&nbsp;y&nbsp;&lt;=&nbsp;2;&nbsp;++y)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec2&nbsp;offset&nbsp;=&nbsp;vec2(float(x),&nbsp;float(y))&nbsp;*&nbsp;texel_size&nbsp;*&nbsp;softness;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shadow&nbsp;+=&nbsp;texture(u_shadow_map[sm],&nbsp;vec3(proj_coords.xy&nbsp;+&nbsp;offset,&nbsp;compare_depth));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;shadow&nbsp;/&nbsp;25.0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
}<br>
<br>
/**<br>
&nbsp;*&nbsp;Compute&nbsp;hard&nbsp;shadow&nbsp;using&nbsp;hardware&nbsp;PCF&nbsp;(sampler2DShadow).<br>
&nbsp;*&nbsp;Single&nbsp;sample&nbsp;with&nbsp;automatic&nbsp;depth&nbsp;comparison&nbsp;+&nbsp;bilinear&nbsp;filtering.<br>
&nbsp;*/<br>
float&nbsp;compute_shadow(int&nbsp;light_index)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;bias&nbsp;=&nbsp;_get_shadow_bias();<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;sm&nbsp;=&nbsp;0;&nbsp;sm&nbsp;&lt;&nbsp;u_shadow_map_count;&nbsp;++sm)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(u_shadow_light_index[sm]&nbsp;!=&nbsp;light_index)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec4&nbsp;light_space_pos&nbsp;=&nbsp;u_light_space_matrix[sm]&nbsp;*&nbsp;vec4(v_world_pos,&nbsp;1.0);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;proj_coords&nbsp;=&nbsp;light_space_pos.xyz&nbsp;/&nbsp;light_space_pos.w;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proj_coords&nbsp;=&nbsp;proj_coords&nbsp;*&nbsp;0.5&nbsp;+&nbsp;0.5;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(proj_coords.x&nbsp;&lt;&nbsp;0.0&nbsp;||&nbsp;proj_coords.x&nbsp;&gt;&nbsp;1.0&nbsp;||<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proj_coords.y&nbsp;&lt;&nbsp;0.0&nbsp;||&nbsp;proj_coords.y&nbsp;&gt;&nbsp;1.0&nbsp;||<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proj_coords.z&nbsp;&lt;&nbsp;0.0&nbsp;||&nbsp;proj_coords.z&nbsp;&gt;&nbsp;1.0)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1.0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Hardware&nbsp;PCF:&nbsp;texture()&nbsp;on&nbsp;sampler2DShadow&nbsp;does&nbsp;depth&nbsp;comparison<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;texture(u_shadow_map[sm],&nbsp;vec3(proj_coords.xy,&nbsp;proj_coords.z&nbsp;-&nbsp;bias));<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1.0;<br>
}<br>
<br>
/**<br>
&nbsp;*&nbsp;Compute&nbsp;soft&nbsp;shadow&nbsp;with&nbsp;5x5&nbsp;PCF&nbsp;grid.<br>
&nbsp;*&nbsp;25&nbsp;samples&nbsp;using&nbsp;hardware&nbsp;depth&nbsp;comparison.<br>
&nbsp;*&nbsp;Softness&nbsp;controlled&nbsp;by&nbsp;shadow_softness&nbsp;setting.<br>
&nbsp;*/<br>
float&nbsp;compute_shadow_pcf(int&nbsp;light_index)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;bias&nbsp;=&nbsp;_get_shadow_bias();<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;softness&nbsp;=&nbsp;max(_get_shadow_softness_val(),&nbsp;0.0);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;sm&nbsp;=&nbsp;0;&nbsp;sm&nbsp;&lt;&nbsp;u_shadow_map_count;&nbsp;++sm)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(u_shadow_light_index[sm]&nbsp;!=&nbsp;light_index)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec4&nbsp;light_space_pos&nbsp;=&nbsp;u_light_space_matrix[sm]&nbsp;*&nbsp;vec4(v_world_pos,&nbsp;1.0);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;proj_coords&nbsp;=&nbsp;light_space_pos.xyz&nbsp;/&nbsp;light_space_pos.w;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proj_coords&nbsp;=&nbsp;proj_coords&nbsp;*&nbsp;0.5&nbsp;+&nbsp;0.5;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(proj_coords.x&nbsp;&lt;&nbsp;0.0&nbsp;||&nbsp;proj_coords.x&nbsp;&gt;&nbsp;1.0&nbsp;||<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proj_coords.y&nbsp;&lt;&nbsp;0.0&nbsp;||&nbsp;proj_coords.y&nbsp;&gt;&nbsp;1.0&nbsp;||<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proj_coords.z&nbsp;&lt;&nbsp;0.0&nbsp;||&nbsp;proj_coords.z&nbsp;&gt;&nbsp;1.0)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1.0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec2&nbsp;texel_size&nbsp;=&nbsp;1.0&nbsp;/&nbsp;vec2(textureSize(u_shadow_map[sm],&nbsp;0));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;compare_depth&nbsp;=&nbsp;proj_coords.z&nbsp;-&nbsp;bias;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;shadow&nbsp;=&nbsp;0.0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;x&nbsp;=&nbsp;-2;&nbsp;x&nbsp;&lt;=&nbsp;2;&nbsp;++x)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;y&nbsp;=&nbsp;-2;&nbsp;y&nbsp;&lt;=&nbsp;2;&nbsp;++y)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec2&nbsp;offset&nbsp;=&nbsp;vec2(float(x),&nbsp;float(y))&nbsp;*&nbsp;texel_size&nbsp;*&nbsp;softness;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shadow&nbsp;+=&nbsp;texture(u_shadow_map[sm],&nbsp;vec3(proj_coords.xy&nbsp;+&nbsp;offset,&nbsp;compare_depth));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;shadow&nbsp;/&nbsp;25.0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1.0;<br>
}<br>
<br>
/**<br>
&nbsp;*&nbsp;Compute&nbsp;high-quality&nbsp;soft&nbsp;shadow&nbsp;with&nbsp;Poisson&nbsp;disk&nbsp;sampling.<br>
&nbsp;*&nbsp;16&nbsp;samples&nbsp;with&nbsp;better&nbsp;distribution&nbsp;than&nbsp;grid,&nbsp;reduces&nbsp;banding&nbsp;artifacts.<br>
&nbsp;*&nbsp;Softness&nbsp;controlled&nbsp;by&nbsp;shadow_softness&nbsp;setting.<br>
&nbsp;*/<br>
float&nbsp;compute_shadow_poisson(int&nbsp;light_index)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;bias&nbsp;=&nbsp;_get_shadow_bias();<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;softness&nbsp;=&nbsp;max(_get_shadow_softness_val(),&nbsp;0.0);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;sm&nbsp;=&nbsp;0;&nbsp;sm&nbsp;&lt;&nbsp;u_shadow_map_count;&nbsp;++sm)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(u_shadow_light_index[sm]&nbsp;!=&nbsp;light_index)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec4&nbsp;light_space_pos&nbsp;=&nbsp;u_light_space_matrix[sm]&nbsp;*&nbsp;vec4(v_world_pos,&nbsp;1.0);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;proj_coords&nbsp;=&nbsp;light_space_pos.xyz&nbsp;/&nbsp;light_space_pos.w;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proj_coords&nbsp;=&nbsp;proj_coords&nbsp;*&nbsp;0.5&nbsp;+&nbsp;0.5;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(proj_coords.x&nbsp;&lt;&nbsp;0.0&nbsp;||&nbsp;proj_coords.x&nbsp;&gt;&nbsp;1.0&nbsp;||<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proj_coords.y&nbsp;&lt;&nbsp;0.0&nbsp;||&nbsp;proj_coords.y&nbsp;&gt;&nbsp;1.0&nbsp;||<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proj_coords.z&nbsp;&lt;&nbsp;0.0&nbsp;||&nbsp;proj_coords.z&nbsp;&gt;&nbsp;1.0)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1.0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec2&nbsp;texel_size&nbsp;=&nbsp;1.0&nbsp;/&nbsp;vec2(textureSize(u_shadow_map[sm],&nbsp;0));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;compare_depth&nbsp;=&nbsp;proj_coords.z&nbsp;-&nbsp;bias;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;radius&nbsp;=&nbsp;2.5&nbsp;*&nbsp;softness;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;shadow&nbsp;=&nbsp;0.0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;POISSON_SAMPLES;&nbsp;++i)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec2&nbsp;offset&nbsp;=&nbsp;poissonDisk[i]&nbsp;*&nbsp;texel_size&nbsp;*&nbsp;radius;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shadow&nbsp;+=&nbsp;texture(u_shadow_map[sm],&nbsp;vec3(proj_coords.xy&nbsp;+&nbsp;offset,&nbsp;compare_depth));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;shadow&nbsp;/&nbsp;float(POISSON_SAMPLES);<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1.0;<br>
}<br>
<br>
/**<br>
&nbsp;*&nbsp;Compute&nbsp;shadow&nbsp;using&nbsp;Cascaded&nbsp;Shadow&nbsp;Maps&nbsp;(CSM).<br>
&nbsp;*&nbsp;Selects&nbsp;appropriate&nbsp;cascade&nbsp;based&nbsp;on&nbsp;view-space&nbsp;depth.<br>
&nbsp;*&nbsp;Optionally&nbsp;blends&nbsp;between&nbsp;cascades&nbsp;for&nbsp;smooth&nbsp;transitions.<br>
&nbsp;*/<br>
float&nbsp;compute_shadow_cascaded(int&nbsp;light_index)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;bias&nbsp;=&nbsp;_get_shadow_bias();<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Compute&nbsp;view-space&nbsp;depth&nbsp;(Y-forward&nbsp;convention:&nbsp;depth&nbsp;=&nbsp;view_pos.y)<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec4&nbsp;view_pos&nbsp;=&nbsp;u_view&nbsp;*&nbsp;vec4(v_world_pos,&nbsp;1.0);<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;depth&nbsp;=&nbsp;view_pos.y;&nbsp;&nbsp;//&nbsp;Y&nbsp;is&nbsp;forward&nbsp;in&nbsp;our&nbsp;convention<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;cascade_count&nbsp;=&nbsp;_get_cascade_count(light_index);<br>
&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;do_blend&nbsp;=&nbsp;_get_cascade_blend(light_index)&nbsp;!=&nbsp;0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;blend_dist&nbsp;=&nbsp;_get_blend_distance(light_index);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Find&nbsp;cascade&nbsp;that&nbsp;contains&nbsp;this&nbsp;depth<br>
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;cascade_sm&nbsp;=&nbsp;-1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;next_cascade_sm&nbsp;=&nbsp;-1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;blend_factor&nbsp;=&nbsp;0.0;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;sm&nbsp;=&nbsp;0;&nbsp;sm&nbsp;&lt;&nbsp;u_shadow_map_count;&nbsp;++sm)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(u_shadow_light_index[sm]&nbsp;!=&nbsp;light_index)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;split_near&nbsp;=&nbsp;u_shadow_split_near[sm];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;split_far&nbsp;=&nbsp;u_shadow_split_far[sm];<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(depth&nbsp;&gt;=&nbsp;split_near&nbsp;&amp;&amp;&nbsp;depth&nbsp;&lt;&nbsp;split_far)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cascade_sm&nbsp;=&nbsp;sm;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Check&nbsp;if&nbsp;in&nbsp;blend&nbsp;zone&nbsp;(near&nbsp;far&nbsp;edge)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(do_blend&nbsp;&amp;&amp;&nbsp;(split_far&nbsp;-&nbsp;depth)&nbsp;&lt;&nbsp;blend_dist)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;this_cascade_idx&nbsp;=&nbsp;u_shadow_cascade_index[sm];<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Find&nbsp;next&nbsp;cascade<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;sm2&nbsp;=&nbsp;0;&nbsp;sm2&nbsp;&lt;&nbsp;u_shadow_map_count;&nbsp;++sm2)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(u_shadow_light_index[sm2]&nbsp;!=&nbsp;light_index)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(u_shadow_cascade_index[sm2]&nbsp;==&nbsp;this_cascade_idx&nbsp;+&nbsp;1)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;next_cascade_sm&nbsp;=&nbsp;sm2;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blend_factor&nbsp;=&nbsp;1.0&nbsp;-&nbsp;(split_far&nbsp;-&nbsp;depth)&nbsp;/&nbsp;blend_dist;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;No&nbsp;cascade&nbsp;found&nbsp;-&nbsp;no&nbsp;shadow<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(cascade_sm&nbsp;&lt;&nbsp;0)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1.0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Sample&nbsp;primary&nbsp;cascade<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;shadow1&nbsp;=&nbsp;_sample_shadow_map(cascade_sm,&nbsp;v_world_pos,&nbsp;bias);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Blend&nbsp;with&nbsp;next&nbsp;cascade&nbsp;if&nbsp;needed<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(next_cascade_sm&nbsp;&gt;=&nbsp;0&nbsp;&amp;&amp;&nbsp;blend_factor&nbsp;&gt;&nbsp;0.0)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;shadow2&nbsp;=&nbsp;_sample_shadow_map(next_cascade_sm,&nbsp;v_world_pos,&nbsp;bias);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;mix(shadow1,&nbsp;shadow2,&nbsp;blend_factor);<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;shadow1;<br>
}<br>
<br>
/**<br>
&nbsp;*&nbsp;Compute&nbsp;shadow&nbsp;using&nbsp;method&nbsp;selected&nbsp;by&nbsp;shadow&nbsp;settings.<br>
&nbsp;*&nbsp;Automatically&nbsp;uses&nbsp;cascaded&nbsp;shadows&nbsp;if&nbsp;cascade_count&nbsp;&gt;&nbsp;1.<br>
&nbsp;*&nbsp;0&nbsp;=&nbsp;hard&nbsp;(single&nbsp;sample)<br>
&nbsp;*&nbsp;1&nbsp;=&nbsp;PCF&nbsp;5x5&nbsp;grid&nbsp;(default)<br>
&nbsp;*&nbsp;2&nbsp;=&nbsp;Poisson&nbsp;disk&nbsp;(16&nbsp;samples)<br>
&nbsp;*/<br>
float&nbsp;compute_shadow_auto(int&nbsp;light_index)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Check&nbsp;if&nbsp;this&nbsp;light&nbsp;uses&nbsp;cascades<br>
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;cascade_count&nbsp;=&nbsp;_get_cascade_count(light_index);<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(cascade_count&nbsp;&gt;&nbsp;1)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;compute_shadow_cascaded(light_index);<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Single&nbsp;cascade&nbsp;-&nbsp;use&nbsp;original&nbsp;methods<br>
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;method&nbsp;=&nbsp;_get_shadow_method_val();<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(method&nbsp;==&nbsp;0)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;compute_shadow(light_index);<br>
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;if&nbsp;(method&nbsp;==&nbsp;2)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;compute_shadow_poisson(light_index);<br>
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;compute_shadow_pcf(light_index);<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
}<br>
<br>
#endif&nbsp;//&nbsp;SHADOWS_GLSL<br>
<!-- END SCAT CODE -->
</body>
</html>
