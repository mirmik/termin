<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>termin/resources/stdlib/shaders/CookTorrancePBR.shader</title>
</head>
<body>
<!-- BEGIN SCAT CODE -->
@program&nbsp;CookTorrancePBR<br>
@features&nbsp;lighting_ubo<br>
<br>
//&nbsp;============================================================<br>
//&nbsp;Cook-Torrance&nbsp;PBR&nbsp;Shader<br>
//&nbsp;============================================================<br>
//<br>
//&nbsp;Physically-based&nbsp;rendering&nbsp;with&nbsp;metallic-roughness&nbsp;workflow.<br>
//<br>
//&nbsp;BRDF:&nbsp;f&nbsp;=&nbsp;kD&nbsp;*&nbsp;(albedo/PI)&nbsp;+&nbsp;(D&nbsp;*&nbsp;G&nbsp;*&nbsp;F)&nbsp;/&nbsp;(4&nbsp;*&nbsp;NdotV&nbsp;*&nbsp;NdotL)<br>
//<br>
//&nbsp;Components:<br>
//&nbsp;&nbsp;&nbsp;D&nbsp;-&nbsp;GGX/Trowbridge-Reitz&nbsp;Normal&nbsp;Distribution&nbsp;Function<br>
//&nbsp;&nbsp;&nbsp;G&nbsp;-&nbsp;Smith's&nbsp;Geometry&nbsp;Function<br>
//&nbsp;&nbsp;&nbsp;F&nbsp;-&nbsp;Fresnel-Schlick&nbsp;Approximation<br>
//<br>
//&nbsp;Features:<br>
//&nbsp;&nbsp;&nbsp;-&nbsp;Metallic-Roughness&nbsp;workflow<br>
//&nbsp;&nbsp;&nbsp;-&nbsp;Subsurface&nbsp;scattering&nbsp;approximation&nbsp;(wrap&nbsp;lighting)<br>
//&nbsp;&nbsp;&nbsp;-&nbsp;Emission&nbsp;(HDR)<br>
//&nbsp;&nbsp;&nbsp;-&nbsp;ACES&nbsp;tone&nbsp;mapping<br>
//&nbsp;&nbsp;&nbsp;-&nbsp;Shadow&nbsp;mapping&nbsp;with&nbsp;cascades<br>
//&nbsp;&nbsp;&nbsp;-&nbsp;Normal&nbsp;mapping&nbsp;with&nbsp;TBN&nbsp;matrix<br>
//<br>
//&nbsp;TODO:&nbsp;IBL&nbsp;-&nbsp;Image-Based&nbsp;Lighting&nbsp;(environment&nbsp;cubemap)<br>
//&nbsp;TODO:&nbsp;AO&nbsp;map&nbsp;(u_ao_texture)&nbsp;-&nbsp;baked&nbsp;ambient&nbsp;occlusion<br>
//&nbsp;TODO:&nbsp;Metallic/Roughness&nbsp;textures<br>
//&nbsp;TODO:&nbsp;Clearcoat&nbsp;layer<br>
//<br>
//&nbsp;============================================================<br>
<br>
@phases&nbsp;opaque,&nbsp;transparent<br>
<br>
@settings&nbsp;transparent<br>
@glDepthMask&nbsp;false<br>
@glBlend&nbsp;true<br>
@glCull&nbsp;true<br>
<br>
@property&nbsp;Color&nbsp;u_color&nbsp;=&nbsp;Color(1.0,&nbsp;1.0,&nbsp;1.0,&nbsp;1.0)<br>
@property&nbsp;Float&nbsp;u_metallic&nbsp;=&nbsp;0.0&nbsp;range(0.0,&nbsp;1.0)<br>
@property&nbsp;Float&nbsp;u_roughness&nbsp;=&nbsp;0.5&nbsp;range(0.0,&nbsp;1.0)<br>
@property&nbsp;Float&nbsp;u_subsurface&nbsp;=&nbsp;0.0&nbsp;range(0.0,&nbsp;1.0)<br>
@property&nbsp;Float&nbsp;u_diffuse_mul&nbsp;=&nbsp;1.0&nbsp;range(0.1,&nbsp;10.0)<br>
@property&nbsp;Color&nbsp;u_emission_color&nbsp;=&nbsp;Color(0.0,&nbsp;0.0,&nbsp;0.0,&nbsp;1.0)<br>
@property&nbsp;Float&nbsp;u_emission_intensity&nbsp;=&nbsp;0.0&nbsp;range(0.0,&nbsp;100.0)<br>
@property&nbsp;Texture2D&nbsp;u_albedo_texture&nbsp;=&nbsp;&quot;white&quot;<br>
@property&nbsp;Texture2D&nbsp;u_normal_texture&nbsp;=&nbsp;&quot;normal&quot;<br>
@property&nbsp;Float&nbsp;u_normal_strength&nbsp;=&nbsp;1.0&nbsp;range(0.0,&nbsp;2.0)<br>
<br>
@stage&nbsp;vertex<br>
#version&nbsp;330&nbsp;core<br>
<br>
layout(location&nbsp;=&nbsp;0)&nbsp;in&nbsp;vec3&nbsp;a_position;<br>
layout(location&nbsp;=&nbsp;1)&nbsp;in&nbsp;vec3&nbsp;a_normal;<br>
layout(location&nbsp;=&nbsp;2)&nbsp;in&nbsp;vec2&nbsp;a_uv;<br>
layout(location&nbsp;=&nbsp;3)&nbsp;in&nbsp;vec4&nbsp;a_tangent;&nbsp;&nbsp;//&nbsp;xyz&nbsp;=&nbsp;tangent,&nbsp;w&nbsp;=&nbsp;handedness<br>
<br>
uniform&nbsp;mat4&nbsp;u_model;<br>
uniform&nbsp;mat4&nbsp;u_view;<br>
uniform&nbsp;mat4&nbsp;u_projection;<br>
<br>
out&nbsp;vec3&nbsp;v_world_pos;<br>
out&nbsp;vec3&nbsp;v_normal;<br>
out&nbsp;vec2&nbsp;v_uv;<br>
out&nbsp;mat3&nbsp;v_TBN;<br>
out&nbsp;vec3&nbsp;v_tangent;<br>
<br>
void&nbsp;main()&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec4&nbsp;world&nbsp;=&nbsp;u_model&nbsp;*&nbsp;vec4(a_position,&nbsp;1.0);<br>
&nbsp;&nbsp;&nbsp;&nbsp;v_world_pos&nbsp;=&nbsp;world.xyz;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Transform&nbsp;normal&nbsp;to&nbsp;world&nbsp;space<br>
&nbsp;&nbsp;&nbsp;&nbsp;mat3&nbsp;normal_matrix&nbsp;=&nbsp;transpose(inverse(mat3(u_model)));<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;N&nbsp;=&nbsp;normalize(normal_matrix&nbsp;*&nbsp;a_normal);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Check&nbsp;if&nbsp;tangent&nbsp;data&nbsp;is&nbsp;valid&nbsp;(non-zero&nbsp;length)<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;tangent_len&nbsp;=&nbsp;length(a_tangent.xyz);<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(tangent_len&nbsp;&gt;&nbsp;0.001)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Transform&nbsp;tangent&nbsp;to&nbsp;world&nbsp;space<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;T&nbsp;=&nbsp;normalize(normal_matrix&nbsp;*&nbsp;a_tangent.xyz);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Re-orthogonalize&nbsp;T&nbsp;with&nbsp;respect&nbsp;to&nbsp;N&nbsp;(Gram-Schmidt)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T&nbsp;=&nbsp;normalize(T&nbsp;-&nbsp;dot(T,&nbsp;N)&nbsp;*&nbsp;N);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Bitangent&nbsp;=&nbsp;cross(N,&nbsp;T)&nbsp;*&nbsp;handedness<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;B&nbsp;=&nbsp;cross(N,&nbsp;T)&nbsp;*&nbsp;a_tangent.w;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;TBN&nbsp;matrix&nbsp;transforms&nbsp;from&nbsp;tangent&nbsp;space&nbsp;to&nbsp;world&nbsp;space<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v_TBN&nbsp;=&nbsp;mat3(T,&nbsp;B,&nbsp;N);<br>
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;No&nbsp;tangent&nbsp;data&nbsp;-&nbsp;set&nbsp;TBN&nbsp;to&nbsp;zero&nbsp;matrix&nbsp;(will&nbsp;be&nbsp;detected&nbsp;in&nbsp;fragment&nbsp;shader)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v_TBN&nbsp;=&nbsp;mat3(0.0);<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;v_normal&nbsp;=&nbsp;N;<br>
&nbsp;&nbsp;&nbsp;&nbsp;v_uv&nbsp;=&nbsp;a_uv;<br>
&nbsp;&nbsp;&nbsp;&nbsp;v_tangent&nbsp;=&nbsp;a_tangent.xyz;<br>
&nbsp;&nbsp;&nbsp;&nbsp;gl_Position&nbsp;=&nbsp;u_projection&nbsp;*&nbsp;u_view&nbsp;*&nbsp;world;<br>
}<br>
@endstage<br>
<br>
@stage&nbsp;fragment<br>
#version&nbsp;330&nbsp;core<br>
<br>
in&nbsp;vec3&nbsp;v_world_pos;<br>
in&nbsp;vec3&nbsp;v_normal;<br>
in&nbsp;vec2&nbsp;v_uv;<br>
in&nbsp;mat3&nbsp;v_TBN;<br>
in&nbsp;vec3&nbsp;v_tangent;<br>
<br>
#include&nbsp;&quot;lighting.glsl&quot;<br>
#include&nbsp;&quot;shadows.glsl&quot;<br>
<br>
//&nbsp;Material&nbsp;parameters<br>
uniform&nbsp;vec4&nbsp;u_color;<br>
uniform&nbsp;sampler2D&nbsp;u_albedo_texture;<br>
uniform&nbsp;sampler2D&nbsp;u_normal_texture;<br>
uniform&nbsp;float&nbsp;u_normal_strength;<br>
uniform&nbsp;float&nbsp;u_metallic;<br>
uniform&nbsp;float&nbsp;u_roughness;<br>
uniform&nbsp;float&nbsp;u_subsurface;<br>
uniform&nbsp;float&nbsp;u_diffuse_mul;<br>
<br>
//&nbsp;Emission<br>
uniform&nbsp;vec4&nbsp;u_emission_color;<br>
uniform&nbsp;float&nbsp;u_emission_intensity;<br>
<br>
out&nbsp;vec4&nbsp;FragColor;<br>
<br>
const&nbsp;float&nbsp;PI&nbsp;=&nbsp;3.14159265359;<br>
<br>
//&nbsp;==============&nbsp;PBR&nbsp;Functions&nbsp;==============<br>
<br>
//&nbsp;Normal&nbsp;Distribution&nbsp;Function&nbsp;(GGX/Trowbridge-Reitz)<br>
//&nbsp;Models&nbsp;microfacet&nbsp;distribution&nbsp;on&nbsp;the&nbsp;surface<br>
float&nbsp;D_GGX(float&nbsp;NdotH,&nbsp;float&nbsp;roughness)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;a&nbsp;=&nbsp;roughness&nbsp;*&nbsp;roughness;<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;a2&nbsp;=&nbsp;a&nbsp;*&nbsp;a;<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;denom&nbsp;=&nbsp;NdotH&nbsp;*&nbsp;NdotH&nbsp;*&nbsp;(a2&nbsp;-&nbsp;1.0)&nbsp;+&nbsp;1.0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;a2&nbsp;/&nbsp;(PI&nbsp;*&nbsp;denom&nbsp;*&nbsp;denom);<br>
}<br>
<br>
//&nbsp;Geometry&nbsp;Function&nbsp;(Smith's&nbsp;method&nbsp;with&nbsp;GGX)<br>
//&nbsp;Models&nbsp;microfacet&nbsp;self-shadowing<br>
float&nbsp;G_Smith(float&nbsp;NdotV,&nbsp;float&nbsp;NdotL,&nbsp;float&nbsp;roughness)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;r&nbsp;=&nbsp;roughness&nbsp;+&nbsp;1.0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;k&nbsp;=&nbsp;(r&nbsp;*&nbsp;r)&nbsp;/&nbsp;8.0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;G1_V&nbsp;=&nbsp;NdotV&nbsp;/&nbsp;(NdotV&nbsp;*&nbsp;(1.0&nbsp;-&nbsp;k)&nbsp;+&nbsp;k);<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;G1_L&nbsp;=&nbsp;NdotL&nbsp;/&nbsp;(NdotL&nbsp;*&nbsp;(1.0&nbsp;-&nbsp;k)&nbsp;+&nbsp;k);<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;G1_V&nbsp;*&nbsp;G1_L;<br>
}<br>
<br>
//&nbsp;Fresnel&nbsp;(Schlick&nbsp;approximation)<br>
//&nbsp;Models&nbsp;increased&nbsp;reflectance&nbsp;at&nbsp;grazing&nbsp;angles<br>
vec3&nbsp;F_Schlick(float&nbsp;cosTheta,&nbsp;vec3&nbsp;F0)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;F0&nbsp;+&nbsp;(1.0&nbsp;-&nbsp;F0)&nbsp;*&nbsp;pow(clamp(1.0&nbsp;-&nbsp;cosTheta,&nbsp;0.0,&nbsp;1.0),&nbsp;5.0);<br>
}<br>
<br>
//&nbsp;==============&nbsp;SSS&nbsp;Approximation&nbsp;==============<br>
<br>
//&nbsp;Wrap&nbsp;lighting:&nbsp;softens&nbsp;the&nbsp;terminator<br>
float&nbsp;wrap_diffuse(float&nbsp;NdotL,&nbsp;float&nbsp;wrap)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;max(0.0,&nbsp;(NdotL&nbsp;+&nbsp;wrap)&nbsp;/&nbsp;(1.0&nbsp;+&nbsp;wrap));<br>
}<br>
<br>
//&nbsp;Subsurface&nbsp;color&nbsp;shift&nbsp;(warm&nbsp;tones&nbsp;for&nbsp;skin)<br>
vec3&nbsp;subsurface_color(vec3&nbsp;albedo)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;albedo&nbsp;*&nbsp;vec3(1.0,&nbsp;0.4,&nbsp;0.25);<br>
}<br>
<br>
//&nbsp;==============&nbsp;Normal&nbsp;Mapping&nbsp;==============<br>
<br>
vec3&nbsp;get_normal_from_map()&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Sample&nbsp;normal&nbsp;map&nbsp;(stored&nbsp;in&nbsp;tangent&nbsp;space)<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;normal_sample&nbsp;=&nbsp;texture(u_normal_texture,&nbsp;v_uv).rgb;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Convert&nbsp;from&nbsp;[0,1]&nbsp;to&nbsp;[-1,1]&nbsp;range<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;tangent_normal&nbsp;=&nbsp;normal_sample&nbsp;*&nbsp;2.0&nbsp;-&nbsp;1.0;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Apply&nbsp;normal&nbsp;strength&nbsp;(blend&nbsp;between&nbsp;(0,0,1)&nbsp;and&nbsp;sampled&nbsp;normal)<br>
&nbsp;&nbsp;&nbsp;&nbsp;tangent_normal.xy&nbsp;*=&nbsp;u_normal_strength;<br>
&nbsp;&nbsp;&nbsp;&nbsp;tangent_normal&nbsp;=&nbsp;normalize(tangent_normal);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Transform&nbsp;from&nbsp;tangent&nbsp;space&nbsp;to&nbsp;world&nbsp;space&nbsp;using&nbsp;TBN&nbsp;matrix<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;normalize(v_TBN&nbsp;*&nbsp;tangent_normal);<br>
}<br>
<br>
//&nbsp;==============&nbsp;Main&nbsp;==============<br>
<br>
void&nbsp;main()&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Get&nbsp;normal&nbsp;from&nbsp;normal&nbsp;map&nbsp;if&nbsp;available,&nbsp;otherwise&nbsp;use&nbsp;vertex&nbsp;normal<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Note:&nbsp;If&nbsp;mesh&nbsp;has&nbsp;no&nbsp;tangents,&nbsp;v_TBN&nbsp;will&nbsp;be&nbsp;invalid&nbsp;-&nbsp;we&nbsp;detect&nbsp;this<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;by&nbsp;checking&nbsp;if&nbsp;the&nbsp;TBN&nbsp;columns&nbsp;are&nbsp;valid&nbsp;(non-zero&nbsp;length)<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;N;<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;tbn_valid&nbsp;=&nbsp;length(v_TBN[0])&nbsp;*&nbsp;length(v_TBN[1])&nbsp;*&nbsp;length(v_TBN[2]);<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(tbn_valid&nbsp;&gt;&nbsp;0.001&nbsp;&amp;&amp;&nbsp;u_normal_strength&nbsp;&gt;&nbsp;0.0)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;N&nbsp;=&nbsp;get_normal_from_map();<br>
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;N&nbsp;=&nbsp;normalize(v_normal);<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;V&nbsp;=&nbsp;normalize(get_camera_position()&nbsp;-&nbsp;v_world_pos);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;//&nbsp;DEBUG<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;vec3&nbsp;normals_by_map&nbsp;=&nbsp;texture(u_normal_texture,&nbsp;v_uv).rgb;<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;vec3&nbsp;bitangent&nbsp;=&nbsp;normalize(v_TBN[1]);<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;vec3&nbsp;normal&nbsp;=&nbsp;normalize(v_TBN[2]);<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;//FragColor&nbsp;=&nbsp;vec4(normals_by_map,&nbsp;1.0);<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;FragColor&nbsp;=&nbsp;vec4(v_tangent&nbsp;*&nbsp;0.5&nbsp;+&nbsp;0.5,&nbsp;1.0);<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;return;<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;//&nbsp;DEBUG<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Sample&nbsp;albedo<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec4&nbsp;tex_color&nbsp;=&nbsp;texture(u_albedo_texture,&nbsp;v_uv);<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;albedo&nbsp;=&nbsp;u_color.rgb&nbsp;*&nbsp;tex_color.rgb;<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;alpha&nbsp;=&nbsp;u_color.a&nbsp;*&nbsp;tex_color.a;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;metallic&nbsp;=&nbsp;u_metallic;<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;roughness&nbsp;=&nbsp;max(u_roughness,&nbsp;0.04);<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;subsurface&nbsp;=&nbsp;u_subsurface;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;F0:&nbsp;reflectance&nbsp;at&nbsp;normal&nbsp;incidence<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Dielectrics&nbsp;~0.04,&nbsp;metals&nbsp;use&nbsp;albedo<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;F0&nbsp;=&nbsp;mix(vec3(0.04),&nbsp;albedo,&nbsp;metallic);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Ambient&nbsp;term<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;TODO:&nbsp;Replace&nbsp;with&nbsp;IBL&nbsp;(irradiance&nbsp;map)<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;ambient&nbsp;=&nbsp;get_ambient_color()&nbsp;*&nbsp;get_ambient_intensity()&nbsp;*&nbsp;albedo&nbsp;*&nbsp;(1.0&nbsp;-&nbsp;metallic&nbsp;*&nbsp;0.5);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;Lo&nbsp;=&nbsp;vec3(0.0);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;get_light_count();&nbsp;++i)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;L;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;attenuation&nbsp;=&nbsp;1.0;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(get_light_type(i)&nbsp;==&nbsp;LIGHT_TYPE_DIRECTIONAL)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L&nbsp;=&nbsp;normalize(-get_light_direction(i));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;to_light&nbsp;=&nbsp;get_light_position(i)&nbsp;-&nbsp;v_world_pos;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;dist&nbsp;=&nbsp;length(to_light);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L&nbsp;=&nbsp;to_light&nbsp;/&nbsp;max(dist,&nbsp;0.0001);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attenuation&nbsp;=&nbsp;compute_distance_attenuation(get_light_attenuation(i),&nbsp;get_light_range(i),&nbsp;dist);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(get_light_type(i)&nbsp;==&nbsp;LIGHT_TYPE_SPOT)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attenuation&nbsp;*=&nbsp;compute_spot_weight(get_light_direction(i),&nbsp;L,&nbsp;get_light_inner_angle(i),&nbsp;get_light_outer_angle(i));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;H&nbsp;=&nbsp;normalize(V&nbsp;+&nbsp;L);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;NdotL_raw&nbsp;=&nbsp;dot(N,&nbsp;L);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;NdotL&nbsp;=&nbsp;max(NdotL_raw,&nbsp;0.0);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;NdotV&nbsp;=&nbsp;max(dot(N,&nbsp;V),&nbsp;0.001);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;NdotH&nbsp;=&nbsp;max(dot(N,&nbsp;H),&nbsp;0.0);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;HdotV&nbsp;=&nbsp;max(dot(H,&nbsp;V),&nbsp;0.0);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Cook-Torrance&nbsp;specular&nbsp;BRDF<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;D&nbsp;=&nbsp;D_GGX(NdotH,&nbsp;roughness);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;G&nbsp;=&nbsp;G_Smith(NdotV,&nbsp;NdotL,&nbsp;roughness);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;F&nbsp;=&nbsp;F_Schlick(HdotV,&nbsp;F0);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;numerator&nbsp;=&nbsp;D&nbsp;*&nbsp;G&nbsp;*&nbsp;F;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;denominator&nbsp;=&nbsp;4.0&nbsp;*&nbsp;NdotV&nbsp;*&nbsp;NdotL&nbsp;+&nbsp;0.0001;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;specular&nbsp;=&nbsp;numerator&nbsp;/&nbsp;denominator;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Diffuse&nbsp;with&nbsp;energy&nbsp;conservation<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Metals&nbsp;have&nbsp;no&nbsp;diffuse,&nbsp;energy&nbsp;reflected&nbsp;=&nbsp;F<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;kD&nbsp;=&nbsp;(1.0&nbsp;-&nbsp;F)&nbsp;*&nbsp;(1.0&nbsp;-&nbsp;metallic);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Standard&nbsp;Lambertian&nbsp;diffuse<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;diffuse_standard&nbsp;=&nbsp;kD&nbsp;*&nbsp;albedo&nbsp;/&nbsp;PI&nbsp;*&nbsp;u_diffuse_mul;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;SSS:&nbsp;wrap&nbsp;lighting&nbsp;+&nbsp;color&nbsp;shift<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;wrap_amount&nbsp;=&nbsp;subsurface&nbsp;*&nbsp;0.5;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;diffuse_wrap&nbsp;=&nbsp;wrap_diffuse(NdotL_raw,&nbsp;wrap_amount);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;sss_color&nbsp;=&nbsp;subsurface_color(albedo);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;sss_mask&nbsp;=&nbsp;max(0.0,&nbsp;diffuse_wrap&nbsp;-&nbsp;NdotL)&nbsp;*&nbsp;2.0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;diffuse_sss&nbsp;=&nbsp;kD&nbsp;*&nbsp;mix(albedo,&nbsp;sss_color,&nbsp;sss_mask&nbsp;*&nbsp;subsurface)&nbsp;/&nbsp;PI&nbsp;*&nbsp;u_diffuse_mul;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Blend&nbsp;standard&nbsp;and&nbsp;SSS&nbsp;diffuse<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;diffuse_final&nbsp;=&nbsp;mix(diffuse_standard&nbsp;*&nbsp;NdotL,&nbsp;diffuse_sss&nbsp;*&nbsp;diffuse_wrap,&nbsp;subsurface);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Shadow<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;shadow&nbsp;=&nbsp;1.0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(get_light_type(i)&nbsp;==&nbsp;LIGHT_TYPE_DIRECTIONAL)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shadow&nbsp;=&nbsp;compute_shadow_auto(i);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Combine<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;radiance&nbsp;=&nbsp;get_light_color(i)&nbsp;*&nbsp;get_light_intensity(i)&nbsp;*&nbsp;attenuation;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lo&nbsp;+=&nbsp;(diffuse_final&nbsp;+&nbsp;specular&nbsp;*&nbsp;NdotL)&nbsp;*&nbsp;radiance&nbsp;*&nbsp;shadow;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;color&nbsp;=&nbsp;ambient&nbsp;+&nbsp;Lo;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Emission&nbsp;(HDR&nbsp;-&nbsp;will&nbsp;be&nbsp;tonemapped&nbsp;in&nbsp;post-process)<br>
&nbsp;&nbsp;&nbsp;&nbsp;color&nbsp;+=&nbsp;u_emission_color.rgb&nbsp;*&nbsp;u_emission_intensity;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;FragColor&nbsp;=&nbsp;vec4(color,&nbsp;alpha);<br>
}<br>
@endstage<br>
<br>
//&nbsp;============================================================<br>
//&nbsp;Shadow&nbsp;caster&nbsp;phase<br>
//&nbsp;============================================================<br>
<br>
@phase&nbsp;shadow<br>
@priority&nbsp;0<br>
@glDepthTest&nbsp;true<br>
@glDepthMask&nbsp;true<br>
@glCull&nbsp;true<br>
<br>
@stage&nbsp;vertex<br>
#version&nbsp;330&nbsp;core<br>
<br>
layout(location&nbsp;=&nbsp;0)&nbsp;in&nbsp;vec3&nbsp;a_position;<br>
<br>
uniform&nbsp;mat4&nbsp;u_model;<br>
uniform&nbsp;mat4&nbsp;u_view;<br>
uniform&nbsp;mat4&nbsp;u_projection;<br>
<br>
void&nbsp;main()&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;gl_Position&nbsp;=&nbsp;u_projection&nbsp;*&nbsp;u_view&nbsp;*&nbsp;u_model&nbsp;*&nbsp;vec4(a_position,&nbsp;1.0);<br>
}<br>
@endstage<br>
<br>
@stage&nbsp;fragment<br>
#version&nbsp;330&nbsp;core<br>
<br>
out&nbsp;vec4&nbsp;FragColor;<br>
<br>
void&nbsp;main()&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;FragColor&nbsp;=&nbsp;vec4(gl_FragCoord.z,&nbsp;0.0,&nbsp;0.0,&nbsp;1.0);<br>
}<br>
@endstage<br>
<br>
@endphase<br>
<!-- END SCAT CODE -->
</body>
</html>
