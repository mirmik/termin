<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>termin/navmesh/contour_extraction.py</title>
</head>
<body>
<!-- BEGIN SCAT CODE -->
&quot;&quot;&quot;<br>
Извлечение&nbsp;контуров&nbsp;из&nbsp;воксельных&nbsp;регионов.<br>
<br>
Алгоритмы&nbsp;для&nbsp;нахождения&nbsp;внешнего&nbsp;контура&nbsp;и&nbsp;дырок.<br>
Алгоритмы&nbsp;для&nbsp;вычисления&nbsp;distance&nbsp;field.<br>
&quot;&quot;&quot;<br>
<br>
from&nbsp;__future__&nbsp;import&nbsp;annotations<br>
<br>
from&nbsp;collections&nbsp;import&nbsp;deque<br>
from&nbsp;dataclasses&nbsp;import&nbsp;dataclass<br>
import&nbsp;heapq<br>
import&nbsp;math<br>
import&nbsp;numpy&nbsp;as&nbsp;np<br>
<br>
from&nbsp;termin.navmesh.triangulation&nbsp;import&nbsp;build_2d_basis<br>
<br>
<br>
def&nbsp;compute_distance_field_3d(<br>
&nbsp;&nbsp;&nbsp;&nbsp;voxels:&nbsp;set[tuple[int,&nbsp;int,&nbsp;int]],<br>
)&nbsp;-&gt;&nbsp;dict[tuple[int,&nbsp;int,&nbsp;int],&nbsp;float]:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Вычислить&nbsp;distance&nbsp;field&nbsp;для&nbsp;набора&nbsp;вокселей&nbsp;в&nbsp;3D.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Расстояние&nbsp;=&nbsp;кратчайший&nbsp;путь&nbsp;до&nbsp;границы&nbsp;(вокселя&nbsp;с&nbsp;пустым&nbsp;соседом).<br>
&nbsp;&nbsp;&nbsp;&nbsp;Использует&nbsp;Dijkstra&nbsp;с&nbsp;весами&nbsp;рёбер&nbsp;(1.0&nbsp;для&nbsp;осевых,&nbsp;sqrt(2)&nbsp;для&nbsp;диагональных).<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;voxels:&nbsp;Набор&nbsp;координат&nbsp;вокселей.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{(vx,&nbsp;vy,&nbsp;vz):&nbsp;distance}&nbsp;для&nbsp;каждого&nbsp;вокселя.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Граничные&nbsp;воксели&nbsp;имеют&nbsp;distance&nbsp;=&nbsp;0.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;voxels:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;{}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;sqrt2&nbsp;=&nbsp;math.sqrt(2)<br>
&nbsp;&nbsp;&nbsp;&nbsp;sqrt3&nbsp;=&nbsp;math.sqrt(3)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;6-связность&nbsp;для&nbsp;определения&nbsp;границы<br>
&nbsp;&nbsp;&nbsp;&nbsp;cardinal_6&nbsp;=&nbsp;[<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1,&nbsp;0,&nbsp;0),&nbsp;(-1,&nbsp;0,&nbsp;0),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(0,&nbsp;1,&nbsp;0),&nbsp;(0,&nbsp;-1,&nbsp;0),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(0,&nbsp;0,&nbsp;1),&nbsp;(0,&nbsp;0,&nbsp;-1),<br>
&nbsp;&nbsp;&nbsp;&nbsp;]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;26-связность&nbsp;с&nbsp;весами&nbsp;для&nbsp;распространения<br>
&nbsp;&nbsp;&nbsp;&nbsp;directions_26:&nbsp;list[tuple[int,&nbsp;int,&nbsp;int,&nbsp;float]]&nbsp;=&nbsp;[]<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;dx&nbsp;in&nbsp;(-1,&nbsp;0,&nbsp;1):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;dy&nbsp;in&nbsp;(-1,&nbsp;0,&nbsp;1):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;dz&nbsp;in&nbsp;(-1,&nbsp;0,&nbsp;1):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;dx&nbsp;==&nbsp;0&nbsp;and&nbsp;dy&nbsp;==&nbsp;0&nbsp;and&nbsp;dz&nbsp;==&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count&nbsp;=&nbsp;abs(dx)&nbsp;+&nbsp;abs(dy)&nbsp;+&nbsp;abs(dz)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;count&nbsp;==&nbsp;1:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;weight&nbsp;=&nbsp;1.0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif&nbsp;count&nbsp;==&nbsp;2:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;weight&nbsp;=&nbsp;sqrt2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;weight&nbsp;=&nbsp;sqrt3<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;directions_26.append((dx,&nbsp;dy,&nbsp;dz,&nbsp;weight))<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;distance:&nbsp;dict[tuple[int,&nbsp;int,&nbsp;int],&nbsp;float]&nbsp;=&nbsp;{v:&nbsp;float('inf')&nbsp;for&nbsp;v&nbsp;in&nbsp;voxels}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Находим&nbsp;граничные&nbsp;воксели&nbsp;(имеют&nbsp;пустого&nbsp;соседа&nbsp;по&nbsp;6-связности)<br>
&nbsp;&nbsp;&nbsp;&nbsp;heap:&nbsp;list[tuple[float,&nbsp;tuple[int,&nbsp;int,&nbsp;int]]]&nbsp;=&nbsp;[]<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;voxel&nbsp;in&nbsp;voxels:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx,&nbsp;vy,&nbsp;vz&nbsp;=&nbsp;voxel<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is_boundary&nbsp;=&nbsp;False<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;dx,&nbsp;dy,&nbsp;dz&nbsp;in&nbsp;cardinal_6:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbor&nbsp;=&nbsp;(vx&nbsp;+&nbsp;dx,&nbsp;vy&nbsp;+&nbsp;dy,&nbsp;vz&nbsp;+&nbsp;dz)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;neighbor&nbsp;not&nbsp;in&nbsp;voxels:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is_boundary&nbsp;=&nbsp;True<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;is_boundary:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;distance[voxel]&nbsp;=&nbsp;0.0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;heapq.heappush(heap,&nbsp;(0.0,&nbsp;voxel))<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Dijkstra&nbsp;от&nbsp;границы&nbsp;внутрь<br>
&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;heap:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dist,&nbsp;voxel&nbsp;=&nbsp;heapq.heappop(heap)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;dist&nbsp;&gt;&nbsp;distance[voxel]:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx,&nbsp;vy,&nbsp;vz&nbsp;=&nbsp;voxel<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;dx,&nbsp;dy,&nbsp;dz,&nbsp;weight&nbsp;in&nbsp;directions_26:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbor&nbsp;=&nbsp;(vx&nbsp;+&nbsp;dx,&nbsp;vy&nbsp;+&nbsp;dy,&nbsp;vz&nbsp;+&nbsp;dz)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;neighbor&nbsp;not&nbsp;in&nbsp;voxels:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_dist&nbsp;=&nbsp;dist&nbsp;+&nbsp;weight<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;new_dist&nbsp;&lt;&nbsp;distance[neighbor]:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;distance[neighbor]&nbsp;=&nbsp;new_dist<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;heapq.heappush(heap,&nbsp;(new_dist,&nbsp;neighbor))<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;distance<br>
<br>
<br>
def&nbsp;compute_distance_field_2d(<br>
&nbsp;&nbsp;&nbsp;&nbsp;mask:&nbsp;np.ndarray,<br>
)&nbsp;-&gt;&nbsp;np.ndarray:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Вычислить&nbsp;distance&nbsp;field&nbsp;для&nbsp;2D&nbsp;бинарной&nbsp;маски.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Расстояние&nbsp;=&nbsp;кратчайший&nbsp;путь&nbsp;до&nbsp;границы&nbsp;через&nbsp;заполненные&nbsp;ячейки.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Использует&nbsp;Dijkstra&nbsp;с&nbsp;весами&nbsp;рёбер.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mask:&nbsp;2D&nbsp;массив&nbsp;(height,&nbsp;width),&nbsp;1&nbsp;=&nbsp;занято,&nbsp;0&nbsp;=&nbsp;пусто.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2D&nbsp;массив&nbsp;той&nbsp;же&nbsp;формы&nbsp;с&nbsp;расстояниями&nbsp;(float32).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Пустые&nbsp;ячейки&nbsp;имеют&nbsp;distance&nbsp;=&nbsp;0.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Граничные&nbsp;заполненные&nbsp;ячейки&nbsp;имеют&nbsp;distance&nbsp;=&nbsp;0.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Внутренние&nbsp;ячейки&nbsp;имеют&nbsp;distance&nbsp;&gt;&nbsp;0.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;import&nbsp;heapq<br>
&nbsp;&nbsp;&nbsp;&nbsp;import&nbsp;math<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;height,&nbsp;width&nbsp;=&nbsp;mask.shape<br>
&nbsp;&nbsp;&nbsp;&nbsp;distance&nbsp;=&nbsp;np.full((height,&nbsp;width),&nbsp;np.inf,&nbsp;dtype=np.float32)<br>
&nbsp;&nbsp;&nbsp;&nbsp;distance[mask&nbsp;==&nbsp;0]&nbsp;=&nbsp;0.0<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;8-связность&nbsp;с&nbsp;весами<br>
&nbsp;&nbsp;&nbsp;&nbsp;sqrt2&nbsp;=&nbsp;math.sqrt(2)<br>
&nbsp;&nbsp;&nbsp;&nbsp;directions&nbsp;=&nbsp;[<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;(du,&nbsp;dv,&nbsp;weight)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1,&nbsp;0,&nbsp;1.0),&nbsp;(-1,&nbsp;0,&nbsp;1.0),&nbsp;(0,&nbsp;1,&nbsp;1.0),&nbsp;(0,&nbsp;-1,&nbsp;1.0),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1,&nbsp;1,&nbsp;sqrt2),&nbsp;(1,&nbsp;-1,&nbsp;sqrt2),&nbsp;(-1,&nbsp;1,&nbsp;sqrt2),&nbsp;(-1,&nbsp;-1,&nbsp;sqrt2),<br>
&nbsp;&nbsp;&nbsp;&nbsp;]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;4-связность&nbsp;для&nbsp;определения&nbsp;границы<br>
&nbsp;&nbsp;&nbsp;&nbsp;cardinal&nbsp;=&nbsp;[(1,&nbsp;0),&nbsp;(-1,&nbsp;0),&nbsp;(0,&nbsp;1),&nbsp;(0,&nbsp;-1)]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Priority&nbsp;queue:&nbsp;(distance,&nbsp;u,&nbsp;v)<br>
&nbsp;&nbsp;&nbsp;&nbsp;heap:&nbsp;list[tuple[float,&nbsp;int,&nbsp;int]]&nbsp;=&nbsp;[]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Находим&nbsp;граничные&nbsp;ячейки&nbsp;(заполненные&nbsp;с&nbsp;пустым&nbsp;соседом)<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;v&nbsp;in&nbsp;range(height):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;u&nbsp;in&nbsp;range(width):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;mask[v,&nbsp;u]&nbsp;==&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is_boundary&nbsp;=&nbsp;False<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;du,&nbsp;dv&nbsp;in&nbsp;cardinal:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nu,&nbsp;nv&nbsp;=&nbsp;u&nbsp;+&nbsp;du,&nbsp;v&nbsp;+&nbsp;dv<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;nu&nbsp;&lt;&nbsp;0&nbsp;or&nbsp;nu&nbsp;&gt;=&nbsp;width&nbsp;or&nbsp;nv&nbsp;&lt;&nbsp;0&nbsp;or&nbsp;nv&nbsp;&gt;=&nbsp;height:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is_boundary&nbsp;=&nbsp;True<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;mask[nv,&nbsp;nu]&nbsp;==&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is_boundary&nbsp;=&nbsp;True<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;is_boundary:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;distance[v,&nbsp;u]&nbsp;=&nbsp;0.0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;heapq.heappush(heap,&nbsp;(0.0,&nbsp;u,&nbsp;v))<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Dijkstra&nbsp;от&nbsp;границы&nbsp;внутрь<br>
&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;heap:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dist,&nbsp;u,&nbsp;v&nbsp;=&nbsp;heapq.heappop(heap)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;du,&nbsp;dv,&nbsp;weight&nbsp;in&nbsp;directions:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nu,&nbsp;nv&nbsp;=&nbsp;u&nbsp;+&nbsp;du,&nbsp;v&nbsp;+&nbsp;dv<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;0&nbsp;&lt;=&nbsp;nu&nbsp;&lt;&nbsp;width&nbsp;and&nbsp;0&nbsp;&lt;=&nbsp;nv&nbsp;&lt;&nbsp;height:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;mask[nv,&nbsp;nu]&nbsp;==&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_dist&nbsp;=&nbsp;dist&nbsp;+&nbsp;weight<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;new_dist&nbsp;&lt;&nbsp;distance[nv,&nbsp;nu]:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;distance[nv,&nbsp;nu]&nbsp;=&nbsp;new_dist<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;heapq.heappush(heap,&nbsp;(new_dist,&nbsp;nu,&nbsp;nv))<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Заменяем&nbsp;inf&nbsp;на&nbsp;0&nbsp;для&nbsp;незаполненных&nbsp;ячеек<br>
&nbsp;&nbsp;&nbsp;&nbsp;distance[np.isinf(distance)]&nbsp;=&nbsp;0.0<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;distance<br>
<br>
<br>
def&nbsp;smooth_distance_field_2d(<br>
&nbsp;&nbsp;&nbsp;&nbsp;distance_field:&nbsp;np.ndarray,<br>
&nbsp;&nbsp;&nbsp;&nbsp;mask:&nbsp;np.ndarray,<br>
&nbsp;&nbsp;&nbsp;&nbsp;iterations:&nbsp;int&nbsp;=&nbsp;1,<br>
)&nbsp;-&gt;&nbsp;np.ndarray:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Сгладить&nbsp;distance&nbsp;field&nbsp;усреднением&nbsp;по&nbsp;соседям.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Применяет&nbsp;mean&nbsp;filter&nbsp;только&nbsp;к&nbsp;заполненным&nbsp;ячейкам.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Сглаживание&nbsp;убирает&nbsp;мелкие&nbsp;локальные&nbsp;максимумы&nbsp;на&nbsp;хребтах.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;distance_field:&nbsp;2D&nbsp;массив&nbsp;расстояний.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mask:&nbsp;2D&nbsp;бинарная&nbsp;маска&nbsp;(1&nbsp;=&nbsp;занято).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iterations:&nbsp;Количество&nbsp;итераций&nbsp;сглаживания.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Сглаженный&nbsp;distance&nbsp;field.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;height,&nbsp;width&nbsp;=&nbsp;distance_field.shape<br>
&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;distance_field.copy()<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;8-связность<br>
&nbsp;&nbsp;&nbsp;&nbsp;directions&nbsp;=&nbsp;[<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1,&nbsp;0),&nbsp;(-1,&nbsp;0),&nbsp;(0,&nbsp;1),&nbsp;(0,&nbsp;-1),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1,&nbsp;1),&nbsp;(1,&nbsp;-1),&nbsp;(-1,&nbsp;1),&nbsp;(-1,&nbsp;-1),<br>
&nbsp;&nbsp;&nbsp;&nbsp;]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;_&nbsp;in&nbsp;range(int(iterations)):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_result&nbsp;=&nbsp;result.copy()<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;v&nbsp;in&nbsp;range(height):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;u&nbsp;in&nbsp;range(width):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;mask[v,&nbsp;u]&nbsp;==&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Собираем&nbsp;значения&nbsp;соседей<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;total&nbsp;=&nbsp;result[v,&nbsp;u]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count&nbsp;=&nbsp;1<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;du,&nbsp;dv&nbsp;in&nbsp;directions:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nu,&nbsp;nv&nbsp;=&nbsp;u&nbsp;+&nbsp;du,&nbsp;v&nbsp;+&nbsp;dv<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;0&nbsp;&lt;=&nbsp;nu&nbsp;&lt;&nbsp;width&nbsp;and&nbsp;0&nbsp;&lt;=&nbsp;nv&nbsp;&lt;&nbsp;height:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;mask[nv,&nbsp;nu]&nbsp;==&nbsp;1:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;total&nbsp;+=&nbsp;result[nv,&nbsp;nu]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count&nbsp;+=&nbsp;1<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_result[v,&nbsp;u]&nbsp;=&nbsp;total&nbsp;/&nbsp;count<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;new_result<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result<br>
<br>
<br>
def&nbsp;find_distance_field_peaks_2d(<br>
&nbsp;&nbsp;&nbsp;&nbsp;distance_field:&nbsp;np.ndarray,<br>
&nbsp;&nbsp;&nbsp;&nbsp;debug:&nbsp;bool&nbsp;=&nbsp;False,<br>
)&nbsp;-&gt;&nbsp;tuple[set[tuple[int,&nbsp;int]],&nbsp;list[tuple[int,&nbsp;int]]]:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Найти&nbsp;локальные&nbsp;максимумы&nbsp;в&nbsp;2D&nbsp;distance&nbsp;field.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Пик&nbsp;—&nbsp;это&nbsp;ячейка,&nbsp;значение&nbsp;которой&nbsp;&gt;=&nbsp;всех&nbsp;8&nbsp;соседей.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Для&nbsp;plateau&nbsp;выбирается&nbsp;один&nbsp;представитель&nbsp;(центр&nbsp;масс).<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;distance_field:&nbsp;2D&nbsp;массив&nbsp;расстояний&nbsp;(float).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug:&nbsp;Выводить&nbsp;отладочную&nbsp;информацию.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(all_local_maxima,&nbsp;plateau_peaks):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;all_local_maxima:&nbsp;Все&nbsp;локальные&nbsp;максимумы&nbsp;(до&nbsp;фильтрации&nbsp;плато).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plateau_peaks:&nbsp;По&nbsp;одному&nbsp;пику&nbsp;на&nbsp;каждое&nbsp;плато.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;height,&nbsp;width&nbsp;=&nbsp;distance_field.shape<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;8-связность<br>
&nbsp;&nbsp;&nbsp;&nbsp;directions&nbsp;=&nbsp;[<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1,&nbsp;0),&nbsp;(-1,&nbsp;0),&nbsp;(0,&nbsp;1),&nbsp;(0,&nbsp;-1),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1,&nbsp;1),&nbsp;(1,&nbsp;-1),&nbsp;(-1,&nbsp;1),&nbsp;(-1,&nbsp;-1),<br>
&nbsp;&nbsp;&nbsp;&nbsp;]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Находим&nbsp;все&nbsp;ячейки,&nbsp;которые&nbsp;являются&nbsp;локальными&nbsp;максимумами&nbsp;или&nbsp;частью&nbsp;plateau<br>
&nbsp;&nbsp;&nbsp;&nbsp;peak_candidates:&nbsp;set[tuple[int,&nbsp;int]]&nbsp;=&nbsp;set()<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;v&nbsp;in&nbsp;range(height):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;u&nbsp;in&nbsp;range(width):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dist&nbsp;=&nbsp;distance_field[v,&nbsp;u]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;dist&nbsp;&lt;=&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is_peak&nbsp;=&nbsp;True<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;du,&nbsp;dv&nbsp;in&nbsp;directions:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nu,&nbsp;nv&nbsp;=&nbsp;u&nbsp;+&nbsp;du,&nbsp;v&nbsp;+&nbsp;dv<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;0&nbsp;&lt;=&nbsp;nu&nbsp;&lt;&nbsp;width&nbsp;and&nbsp;0&nbsp;&lt;=&nbsp;nv&nbsp;&lt;&nbsp;height:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;distance_field[nv,&nbsp;nu]&nbsp;&gt;&nbsp;dist:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is_peak&nbsp;=&nbsp;False<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;is_peak:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;peak_candidates.add((u,&nbsp;v))<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;debug:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(f&quot;&nbsp;&nbsp;&nbsp;&nbsp;peaks:&nbsp;candidates={len(peak_candidates)}&quot;)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;peak_candidates:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;set(),&nbsp;[]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Группируем&nbsp;соседние&nbsp;peak_candidates&nbsp;с&nbsp;близким&nbsp;distance&nbsp;(plateaus)<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Порог&nbsp;для&nbsp;&quot;одинакового&quot;&nbsp;distance&nbsp;—&nbsp;разница&nbsp;меньше&nbsp;0.5&nbsp;ячейки<br>
&nbsp;&nbsp;&nbsp;&nbsp;visited:&nbsp;set[tuple[int,&nbsp;int]]&nbsp;=&nbsp;set()<br>
&nbsp;&nbsp;&nbsp;&nbsp;peaks:&nbsp;list[tuple[int,&nbsp;int]]&nbsp;=&nbsp;[]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;start&nbsp;in&nbsp;peak_candidates:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;start&nbsp;in&nbsp;visited:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;BFS&nbsp;для&nbsp;нахождения&nbsp;plateau<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plateau:&nbsp;list[tuple[int,&nbsp;int]]&nbsp;=&nbsp;[]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queue&nbsp;=&nbsp;deque([start])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;visited.add(start)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plateau_dist&nbsp;=&nbsp;distance_field[start[1],&nbsp;start[0]]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;queue:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u,&nbsp;v&nbsp;=&nbsp;queue.popleft()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plateau.append((u,&nbsp;v))<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;du,&nbsp;dv&nbsp;in&nbsp;directions:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nu,&nbsp;nv&nbsp;=&nbsp;u&nbsp;+&nbsp;du,&nbsp;v&nbsp;+&nbsp;dv<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbor&nbsp;=&nbsp;(nu,&nbsp;nv)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;neighbor&nbsp;in&nbsp;peak_candidates&nbsp;and&nbsp;neighbor&nbsp;not&nbsp;in&nbsp;visited:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Близкий&nbsp;distance&nbsp;(часть&nbsp;того&nbsp;же&nbsp;plateau)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;abs(distance_field[nv,&nbsp;nu]&nbsp;-&nbsp;plateau_dist)&nbsp;&lt;&nbsp;0.5:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;visited.add(neighbor)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queue.append(neighbor)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Выбираем&nbsp;центр&nbsp;масс&nbsp;plateau&nbsp;как&nbsp;представителя<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;plateau:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;center_u&nbsp;=&nbsp;sum(p[0]&nbsp;for&nbsp;p&nbsp;in&nbsp;plateau)&nbsp;//&nbsp;len(plateau)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;center_v&nbsp;=&nbsp;sum(p[1]&nbsp;for&nbsp;p&nbsp;in&nbsp;plateau)&nbsp;//&nbsp;len(plateau)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Находим&nbsp;ближайшую&nbsp;ячейку&nbsp;plateau&nbsp;к&nbsp;центру<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;best&nbsp;=&nbsp;min(plateau,&nbsp;key=lambda&nbsp;p:&nbsp;(p[0]&nbsp;-&nbsp;center_u)&nbsp;**&nbsp;2&nbsp;+&nbsp;(p[1]&nbsp;-&nbsp;center_v)&nbsp;**&nbsp;2)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;peaks.append(best)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;debug:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(f&quot;&nbsp;&nbsp;&nbsp;&nbsp;plateau:&nbsp;size={len(plateau)},&nbsp;dist={plateau_dist:.2f},&nbsp;peak={best}&quot;)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;debug:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(f&quot;&nbsp;&nbsp;&nbsp;&nbsp;peaks:&nbsp;final={len(peaks)}&quot;)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;peak_candidates,&nbsp;peaks<br>
<br>
<br>
@dataclass<br>
class&nbsp;Watershed2DResult:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Результат&nbsp;watershed&nbsp;в&nbsp;2D.&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;labels:&nbsp;np.ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;num_regions:&nbsp;int<br>
&nbsp;&nbsp;&nbsp;&nbsp;smoothed_distance_field:&nbsp;np.ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;all_local_maxima:&nbsp;set[tuple[int,&nbsp;int]]<br>
&nbsp;&nbsp;&nbsp;&nbsp;peaks:&nbsp;list[tuple[int,&nbsp;int]]<br>
<br>
<br>
def&nbsp;watershed_split_2d(<br>
&nbsp;&nbsp;&nbsp;&nbsp;mask:&nbsp;np.ndarray,<br>
&nbsp;&nbsp;&nbsp;&nbsp;distance_field:&nbsp;np.ndarray,<br>
&nbsp;&nbsp;&nbsp;&nbsp;smoothing:&nbsp;int&nbsp;=&nbsp;0,<br>
)&nbsp;-&gt;&nbsp;Watershed2DResult:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Разбить&nbsp;2D&nbsp;маску&nbsp;на&nbsp;под-регионы&nbsp;с&nbsp;помощью&nbsp;watershed.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mask:&nbsp;2D&nbsp;бинарная&nbsp;маска&nbsp;(1&nbsp;=&nbsp;занято,&nbsp;0&nbsp;=&nbsp;пусто).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;distance_field:&nbsp;2D&nbsp;distance&nbsp;field&nbsp;для&nbsp;маски&nbsp;(float).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;smoothing:&nbsp;Количество&nbsp;итераций&nbsp;сглаживания&nbsp;distance&nbsp;field.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Watershed2DResult&nbsp;с&nbsp;labels,&nbsp;smoothed_df,&nbsp;peaks&nbsp;и&nbsp;т.д.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;height,&nbsp;width&nbsp;=&nbsp;mask.shape<br>
&nbsp;&nbsp;&nbsp;&nbsp;labels&nbsp;=&nbsp;np.zeros((height,&nbsp;width),&nbsp;dtype=np.int32)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Сглаживание&nbsp;distance&nbsp;field&nbsp;для&nbsp;устранения&nbsp;ложных&nbsp;пиков&nbsp;на&nbsp;хребтах<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;smoothing&nbsp;&gt;&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;smoothed_df&nbsp;=&nbsp;smooth_distance_field_2d(distance_field,&nbsp;mask,&nbsp;smoothing)<br>
&nbsp;&nbsp;&nbsp;&nbsp;else:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;smoothed_df&nbsp;=&nbsp;distance_field.copy()<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;print(f&quot;&nbsp;&nbsp;watershed:&nbsp;mask&nbsp;{width}x{height},&nbsp;smoothing={smoothing}&quot;)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Находим&nbsp;пики<br>
&nbsp;&nbsp;&nbsp;&nbsp;all_local_maxima,&nbsp;peaks&nbsp;=&nbsp;find_distance_field_peaks_2d(smoothed_df)<br>
&nbsp;&nbsp;&nbsp;&nbsp;print(f&quot;&nbsp;&nbsp;watershed:&nbsp;found&nbsp;{len(peaks)}&nbsp;peaks,&nbsp;{len(all_local_maxima)}&nbsp;local&nbsp;maxima&quot;)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;peaks:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Нет&nbsp;пиков&nbsp;—&nbsp;весь&nbsp;регион&nbsp;как&nbsp;один<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;labels[mask&nbsp;==&nbsp;1]&nbsp;=&nbsp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Watershed2DResult(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;labels=labels,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num_regions=1,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;smoothed_distance_field=smoothed_df,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;all_local_maxima=all_local_maxima,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;peaks=peaks,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Присваиваем&nbsp;пикам&nbsp;метки<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;idx,&nbsp;(pu,&nbsp;pv)&nbsp;in&nbsp;enumerate(peaks):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;labels[pv,&nbsp;pu]&nbsp;=&nbsp;idx&nbsp;+&nbsp;1<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;4-связность&nbsp;для&nbsp;flooding<br>
&nbsp;&nbsp;&nbsp;&nbsp;directions&nbsp;=&nbsp;[(1,&nbsp;0),&nbsp;(-1,&nbsp;0),&nbsp;(0,&nbsp;1),&nbsp;(0,&nbsp;-1)]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;BFS&nbsp;для&nbsp;равномерного&nbsp;роста&nbsp;всех&nbsp;регионов<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Все&nbsp;регионы&nbsp;растут&nbsp;на&nbsp;один&nbsp;слой&nbsp;за&nbsp;итерацию<br>
&nbsp;&nbsp;&nbsp;&nbsp;frontier:&nbsp;list[tuple[int,&nbsp;int]]&nbsp;=&nbsp;list(peaks)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;frontier:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;next_frontier:&nbsp;list[tuple[int,&nbsp;int]]&nbsp;=&nbsp;[]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;u,&nbsp;v&nbsp;in&nbsp;frontier:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current_label&nbsp;=&nbsp;labels[v,&nbsp;u]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;du,&nbsp;dv&nbsp;in&nbsp;directions:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nu,&nbsp;nv&nbsp;=&nbsp;u&nbsp;+&nbsp;du,&nbsp;v&nbsp;+&nbsp;dv<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;0&nbsp;&lt;=&nbsp;nu&nbsp;&lt;&nbsp;width&nbsp;and&nbsp;0&nbsp;&lt;=&nbsp;nv&nbsp;&lt;&nbsp;height:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;mask[nv,&nbsp;nu]&nbsp;==&nbsp;1&nbsp;and&nbsp;labels[nv,&nbsp;nu]&nbsp;==&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;labels[nv,&nbsp;nu]&nbsp;=&nbsp;current_label<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;next_frontier.append((nu,&nbsp;nv))<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;frontier&nbsp;=&nbsp;next_frontier<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Перенумеруем&nbsp;метки<br>
&nbsp;&nbsp;&nbsp;&nbsp;unique_labels&nbsp;=&nbsp;sorted(set(labels.flat)&nbsp;-&nbsp;{0})<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;len(unique_labels)&nbsp;!=&nbsp;len(peaks):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(f&quot;&nbsp;&nbsp;watershed:&nbsp;WARNING&nbsp;peaks={len(peaks)},&nbsp;but&nbsp;unique_labels={len(unique_labels)}&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;idx,&nbsp;(pu,&nbsp;pv)&nbsp;in&nbsp;enumerate(peaks):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;label&nbsp;=&nbsp;idx&nbsp;+&nbsp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count&nbsp;=&nbsp;int(np.sum(labels&nbsp;==&nbsp;label))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(f&quot;&nbsp;&nbsp;&nbsp;&nbsp;peak&nbsp;{idx}:&nbsp;({pu},&nbsp;{pv})&nbsp;-&gt;&nbsp;label&nbsp;{label},&nbsp;count={count}&quot;)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;label_remap&nbsp;=&nbsp;{old:&nbsp;new&nbsp;for&nbsp;new,&nbsp;old&nbsp;in&nbsp;enumerate(unique_labels,&nbsp;1)}<br>
&nbsp;&nbsp;&nbsp;&nbsp;label_remap[0]&nbsp;=&nbsp;0<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;new_labels&nbsp;=&nbsp;np.zeros_like(labels)<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;old,&nbsp;new&nbsp;in&nbsp;label_remap.items():<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_labels[labels&nbsp;==&nbsp;old]&nbsp;=&nbsp;new<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Watershed2DResult(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;labels=new_labels,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num_regions=len(unique_labels),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;smoothed_distance_field=smoothed_df,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;all_local_maxima=all_local_maxima,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;peaks=peaks,<br>
&nbsp;&nbsp;&nbsp;&nbsp;)<br>
<br>
<br>
@dataclass<br>
class&nbsp;WatershedResult:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Результат&nbsp;watershed&nbsp;разбиения&nbsp;региона.&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;sub_regions:&nbsp;list[list[tuple[int,&nbsp;int,&nbsp;int]]]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Список&nbsp;под-регионов.&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;distance_field:&nbsp;dict[tuple[int,&nbsp;int,&nbsp;int],&nbsp;float]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Distance&nbsp;field&nbsp;(voxel&nbsp;-&gt;&nbsp;distance).&nbsp;Сглаженный&nbsp;если&nbsp;smoothing&nbsp;&gt;&nbsp;0.&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;peaks:&nbsp;set[tuple[int,&nbsp;int,&nbsp;int]]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Пики&nbsp;(локальные&nbsp;максимумы&nbsp;после&nbsp;plateau&nbsp;фильтрации).&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;all_local_maxima:&nbsp;set[tuple[int,&nbsp;int,&nbsp;int]]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Все&nbsp;локальные&nbsp;максимумы&nbsp;(до&nbsp;plateau&nbsp;фильтрации).&quot;&quot;&quot;<br>
<br>
<br>
def&nbsp;watershed_split_region(<br>
&nbsp;&nbsp;&nbsp;&nbsp;region_voxels:&nbsp;list[tuple[int,&nbsp;int,&nbsp;int]],<br>
&nbsp;&nbsp;&nbsp;&nbsp;region_normal:&nbsp;np.ndarray,<br>
&nbsp;&nbsp;&nbsp;&nbsp;cell_size:&nbsp;float,<br>
&nbsp;&nbsp;&nbsp;&nbsp;origin:&nbsp;np.ndarray,<br>
&nbsp;&nbsp;&nbsp;&nbsp;smoothing:&nbsp;int&nbsp;=&nbsp;0,<br>
)&nbsp;-&gt;&nbsp;WatershedResult:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Разбить&nbsp;регион&nbsp;на&nbsp;под-регионы&nbsp;с&nbsp;помощью&nbsp;watershed.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;region_voxels:&nbsp;Список&nbsp;вокселей&nbsp;региона.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;region_normal:&nbsp;Нормаль&nbsp;региона.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cell_size:&nbsp;Размер&nbsp;вокселя.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;origin:&nbsp;Начало&nbsp;координат.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;smoothing:&nbsp;Количество&nbsp;итераций&nbsp;сглаживания&nbsp;distance&nbsp;field.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WatershedResult&nbsp;с&nbsp;под-регионами&nbsp;и&nbsp;промежуточными&nbsp;данными.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Вспомогательная&nbsp;функция&nbsp;для&nbsp;конвертации&nbsp;2D&nbsp;точек&nbsp;в&nbsp;3D&nbsp;воксели<br>
&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;map_2d_to_3d(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;points_2d,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid_2d_to_voxels:&nbsp;dict[tuple[int,&nbsp;int],&nbsp;list[tuple[int,&nbsp;int,&nbsp;int]]],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offset_u:&nbsp;int,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offset_v:&nbsp;int,<br>
&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;-&gt;&nbsp;set[tuple[int,&nbsp;int,&nbsp;int]]:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result:&nbsp;set[tuple[int,&nbsp;int,&nbsp;int]]&nbsp;=&nbsp;set()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(pu,&nbsp;pv)&nbsp;in&nbsp;points_2d:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid_u&nbsp;=&nbsp;pu&nbsp;-&nbsp;offset_u<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid_v&nbsp;=&nbsp;pv&nbsp;-&nbsp;offset_v<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(grid_u,&nbsp;grid_v)&nbsp;in&nbsp;grid_2d_to_voxels:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;voxel&nbsp;in&nbsp;grid_2d_to_voxels[(grid_u,&nbsp;grid_v)]:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.add(voxel)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Пустой&nbsp;результат&nbsp;для&nbsp;граничных&nbsp;случаев<br>
&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;empty_result()&nbsp;-&gt;&nbsp;WatershedResult:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;WatershedResult(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sub_regions=[region_voxels],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;distance_field={v:&nbsp;0.0&nbsp;for&nbsp;v&nbsp;in&nbsp;region_voxels},<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;peaks=set(),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;all_local_maxima=set(),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;len(region_voxels)&nbsp;&lt;&nbsp;2:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;empty_result()<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Строим&nbsp;2D&nbsp;проекцию<br>
&nbsp;&nbsp;&nbsp;&nbsp;u_axis,&nbsp;v_axis&nbsp;=&nbsp;build_2d_basis(region_normal)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;centers_3d&nbsp;=&nbsp;np.array([<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;origin&nbsp;+&nbsp;(np.array(v)&nbsp;+&nbsp;0.5)&nbsp;*&nbsp;cell_size<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;v&nbsp;in&nbsp;region_voxels<br>
&nbsp;&nbsp;&nbsp;&nbsp;],&nbsp;dtype=np.float32)<br>
&nbsp;&nbsp;&nbsp;&nbsp;centroid&nbsp;=&nbsp;centers_3d.mean(axis=0)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Проецируем&nbsp;воксели<br>
&nbsp;&nbsp;&nbsp;&nbsp;voxel_to_2d:&nbsp;dict[tuple[int,&nbsp;int,&nbsp;int],&nbsp;tuple[int,&nbsp;int]]&nbsp;=&nbsp;{}<br>
&nbsp;&nbsp;&nbsp;&nbsp;grid_2d_to_voxels:&nbsp;dict[tuple[int,&nbsp;int],&nbsp;list[tuple[int,&nbsp;int,&nbsp;int]]]&nbsp;=&nbsp;{}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;voxel&nbsp;in&nbsp;region_voxels:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx,&nbsp;vy,&nbsp;vz&nbsp;=&nbsp;voxel<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;world_pos&nbsp;=&nbsp;origin&nbsp;+&nbsp;(np.array([vx,&nbsp;vy,&nbsp;vz])&nbsp;+&nbsp;0.5)&nbsp;*&nbsp;cell_size<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rel_pos&nbsp;=&nbsp;world_pos&nbsp;-&nbsp;centroid<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u&nbsp;=&nbsp;float(np.dot(rel_pos,&nbsp;u_axis))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v&nbsp;=&nbsp;float(np.dot(rel_pos,&nbsp;v_axis))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid_u&nbsp;=&nbsp;_round_half_up(u&nbsp;/&nbsp;cell_size)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid_v&nbsp;=&nbsp;_round_half_up(v&nbsp;/&nbsp;cell_size)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;voxel_to_2d[voxel]&nbsp;=&nbsp;(grid_u,&nbsp;grid_v)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(grid_u,&nbsp;grid_v)&nbsp;not&nbsp;in&nbsp;grid_2d_to_voxels:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid_2d_to_voxels[(grid_u,&nbsp;grid_v)]&nbsp;=&nbsp;[]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid_2d_to_voxels[(grid_u,&nbsp;grid_v)].append(voxel)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Связность&nbsp;через&nbsp;Bresenham<br>
&nbsp;&nbsp;&nbsp;&nbsp;region_set&nbsp;=&nbsp;set(region_voxels)<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;voxel&nbsp;in&nbsp;region_voxels:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx,&nbsp;vy,&nbsp;vz&nbsp;=&nbsp;voxel<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;dx&nbsp;in&nbsp;(-1,&nbsp;0,&nbsp;1):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;dy&nbsp;in&nbsp;(-1,&nbsp;0,&nbsp;1):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;dz&nbsp;in&nbsp;(-1,&nbsp;0,&nbsp;1):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;dx&nbsp;==&nbsp;0&nbsp;and&nbsp;dy&nbsp;==&nbsp;0&nbsp;and&nbsp;dz&nbsp;==&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbor&nbsp;=&nbsp;(vx&nbsp;+&nbsp;dx,&nbsp;vy&nbsp;+&nbsp;dy,&nbsp;vz&nbsp;+&nbsp;dz)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;neighbor&nbsp;in&nbsp;region_set&nbsp;and&nbsp;neighbor&nbsp;&gt;&nbsp;voxel:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u1,&nbsp;v1&nbsp;=&nbsp;voxel_to_2d[voxel]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u2,&nbsp;v2&nbsp;=&nbsp;voxel_to_2d[neighbor]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line_cells&nbsp;=&nbsp;bresenham_line(u1,&nbsp;v1,&nbsp;u2,&nbsp;v2)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;cell&nbsp;in&nbsp;line_cells:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;cell&nbsp;not&nbsp;in&nbsp;grid_2d_to_voxels:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid_2d_to_voxels[cell]&nbsp;=&nbsp;[voxel]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Создаём&nbsp;маску<br>
&nbsp;&nbsp;&nbsp;&nbsp;all_2d&nbsp;=&nbsp;list(grid_2d_to_voxels.keys())<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;all_2d:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;empty_result()<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;min_u&nbsp;=&nbsp;min(p[0]&nbsp;for&nbsp;p&nbsp;in&nbsp;all_2d)<br>
&nbsp;&nbsp;&nbsp;&nbsp;max_u&nbsp;=&nbsp;max(p[0]&nbsp;for&nbsp;p&nbsp;in&nbsp;all_2d)<br>
&nbsp;&nbsp;&nbsp;&nbsp;min_v&nbsp;=&nbsp;min(p[1]&nbsp;for&nbsp;p&nbsp;in&nbsp;all_2d)<br>
&nbsp;&nbsp;&nbsp;&nbsp;max_v&nbsp;=&nbsp;max(p[1]&nbsp;for&nbsp;p&nbsp;in&nbsp;all_2d)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;width&nbsp;=&nbsp;max_u&nbsp;-&nbsp;min_u&nbsp;+&nbsp;3<br>
&nbsp;&nbsp;&nbsp;&nbsp;height&nbsp;=&nbsp;max_v&nbsp;-&nbsp;min_v&nbsp;+&nbsp;3<br>
&nbsp;&nbsp;&nbsp;&nbsp;offset_u&nbsp;=&nbsp;-min_u&nbsp;+&nbsp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;offset_v&nbsp;=&nbsp;-min_v&nbsp;+&nbsp;1<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;mask&nbsp;=&nbsp;np.zeros((height,&nbsp;width),&nbsp;dtype=np.uint8)<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(gu,&nbsp;gv)&nbsp;in&nbsp;all_2d:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mask[gv&nbsp;+&nbsp;offset_v,&nbsp;gu&nbsp;+&nbsp;offset_u]&nbsp;=&nbsp;1<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Distance&nbsp;field<br>
&nbsp;&nbsp;&nbsp;&nbsp;distance_field_2d&nbsp;=&nbsp;compute_distance_field_2d(mask)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Watershed&nbsp;(возвращает&nbsp;сглаженный&nbsp;df&nbsp;и&nbsp;пики)<br>
&nbsp;&nbsp;&nbsp;&nbsp;ws_result&nbsp;=&nbsp;watershed_split_2d(mask,&nbsp;distance_field_2d,&nbsp;smoothing)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Конвертируем&nbsp;2D&nbsp;distance&nbsp;field&nbsp;в&nbsp;3D<br>
&nbsp;&nbsp;&nbsp;&nbsp;distance_field_3d:&nbsp;dict[tuple[int,&nbsp;int,&nbsp;int],&nbsp;float]&nbsp;=&nbsp;{}<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;voxel&nbsp;in&nbsp;region_voxels:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid_u,&nbsp;grid_v&nbsp;=&nbsp;voxel_to_2d[voxel]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mask_u&nbsp;=&nbsp;grid_u&nbsp;+&nbsp;offset_u<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mask_v&nbsp;=&nbsp;grid_v&nbsp;+&nbsp;offset_v<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;0&nbsp;&lt;=&nbsp;mask_u&nbsp;&lt;&nbsp;width&nbsp;and&nbsp;0&nbsp;&lt;=&nbsp;mask_v&nbsp;&lt;&nbsp;height:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;distance_field_3d[voxel]&nbsp;=&nbsp;float(ws_result.smoothed_distance_field[mask_v,&nbsp;mask_u])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;distance_field_3d[voxel]&nbsp;=&nbsp;0.0<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Конвертируем&nbsp;пики&nbsp;в&nbsp;3D<br>
&nbsp;&nbsp;&nbsp;&nbsp;peaks_3d&nbsp;=&nbsp;map_2d_to_3d(ws_result.peaks,&nbsp;grid_2d_to_voxels,&nbsp;offset_u,&nbsp;offset_v)<br>
&nbsp;&nbsp;&nbsp;&nbsp;all_local_maxima_3d&nbsp;=&nbsp;map_2d_to_3d(ws_result.all_local_maxima,&nbsp;grid_2d_to_voxels,&nbsp;offset_u,&nbsp;offset_v)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;ws_result.num_regions&nbsp;&lt;=&nbsp;1:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;WatershedResult(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sub_regions=[region_voxels],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;distance_field=distance_field_3d,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;peaks=peaks_3d,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;all_local_maxima=all_local_maxima_3d,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Собираем&nbsp;воксели&nbsp;по&nbsp;меткам<br>
&nbsp;&nbsp;&nbsp;&nbsp;sub_regions:&nbsp;dict[int,&nbsp;list[tuple[int,&nbsp;int,&nbsp;int]]]&nbsp;=&nbsp;{i:&nbsp;[]&nbsp;for&nbsp;i&nbsp;in&nbsp;range(1,&nbsp;ws_result.num_regions&nbsp;+&nbsp;1)}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;voxel&nbsp;in&nbsp;region_voxels:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid_u,&nbsp;grid_v&nbsp;=&nbsp;voxel_to_2d[voxel]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mask_u&nbsp;=&nbsp;grid_u&nbsp;+&nbsp;offset_u<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mask_v&nbsp;=&nbsp;grid_v&nbsp;+&nbsp;offset_v<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;0&nbsp;&lt;=&nbsp;mask_u&nbsp;&lt;&nbsp;width&nbsp;and&nbsp;0&nbsp;&lt;=&nbsp;mask_v&nbsp;&lt;&nbsp;height:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;label&nbsp;=&nbsp;ws_result.labels[mask_v,&nbsp;mask_u]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;label&nbsp;&gt;&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sub_regions[label].append(voxel)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;result_regions&nbsp;=&nbsp;[voxels&nbsp;for&nbsp;voxels&nbsp;in&nbsp;sub_regions.values()&nbsp;if&nbsp;voxels]<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;result_regions:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result_regions&nbsp;=&nbsp;[region_voxels]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;WatershedResult(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sub_regions=result_regions,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;distance_field=distance_field_3d,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;peaks=peaks_3d,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;all_local_maxima=all_local_maxima_3d,<br>
&nbsp;&nbsp;&nbsp;&nbsp;)<br>
<br>
<br>
def&nbsp;find_peaks_for_region(<br>
&nbsp;&nbsp;&nbsp;&nbsp;region_voxels:&nbsp;list[tuple[int,&nbsp;int,&nbsp;int]],<br>
&nbsp;&nbsp;&nbsp;&nbsp;region_normal:&nbsp;np.ndarray,<br>
&nbsp;&nbsp;&nbsp;&nbsp;cell_size:&nbsp;float,<br>
&nbsp;&nbsp;&nbsp;&nbsp;origin:&nbsp;np.ndarray,<br>
&nbsp;&nbsp;&nbsp;&nbsp;smoothing:&nbsp;int&nbsp;=&nbsp;0,<br>
&nbsp;&nbsp;&nbsp;&nbsp;debug:&nbsp;bool&nbsp;=&nbsp;False,<br>
)&nbsp;-&gt;&nbsp;tuple[set[tuple[int,&nbsp;int,&nbsp;int]],&nbsp;set[tuple[int,&nbsp;int,&nbsp;int]]]:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Найти&nbsp;локальные&nbsp;максимумы&nbsp;distance&nbsp;field&nbsp;для&nbsp;региона.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Возвращает&nbsp;два&nbsp;множества&nbsp;3D&nbsp;вокселей.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;region_voxels:&nbsp;Список&nbsp;вокселей&nbsp;региона.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;region_normal:&nbsp;Нормаль&nbsp;региона.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cell_size:&nbsp;Размер&nbsp;вокселя.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;origin:&nbsp;Начало&nbsp;координат.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;smoothing:&nbsp;Количество&nbsp;итераций&nbsp;сглаживания&nbsp;distance&nbsp;field.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(all_local_maxima,&nbsp;plateau_peaks):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;all_local_maxima:&nbsp;Все&nbsp;локальные&nbsp;максимумы.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plateau_peaks:&nbsp;По&nbsp;одному&nbsp;на&nbsp;плато.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;len(region_voxels)&nbsp;&lt;&nbsp;1:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;set(),&nbsp;set()<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Строим&nbsp;локальную&nbsp;2D&nbsp;систему&nbsp;координат<br>
&nbsp;&nbsp;&nbsp;&nbsp;u_axis,&nbsp;v_axis&nbsp;=&nbsp;build_2d_basis(region_normal)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Центроид&nbsp;региона<br>
&nbsp;&nbsp;&nbsp;&nbsp;centers_3d&nbsp;=&nbsp;np.array([<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;origin&nbsp;+&nbsp;(np.array(v)&nbsp;+&nbsp;0.5)&nbsp;*&nbsp;cell_size<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;v&nbsp;in&nbsp;region_voxels<br>
&nbsp;&nbsp;&nbsp;&nbsp;],&nbsp;dtype=np.float32)<br>
&nbsp;&nbsp;&nbsp;&nbsp;centroid&nbsp;=&nbsp;centers_3d.mean(axis=0)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Проецируем&nbsp;воксели&nbsp;на&nbsp;2D<br>
&nbsp;&nbsp;&nbsp;&nbsp;voxel_to_2d:&nbsp;dict[tuple[int,&nbsp;int,&nbsp;int],&nbsp;tuple[int,&nbsp;int]]&nbsp;=&nbsp;{}<br>
&nbsp;&nbsp;&nbsp;&nbsp;grid_2d_to_voxels:&nbsp;dict[tuple[int,&nbsp;int],&nbsp;list[tuple[int,&nbsp;int,&nbsp;int]]]&nbsp;=&nbsp;{}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;voxel&nbsp;in&nbsp;region_voxels:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx,&nbsp;vy,&nbsp;vz&nbsp;=&nbsp;voxel<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;world_pos&nbsp;=&nbsp;origin&nbsp;+&nbsp;(np.array([vx,&nbsp;vy,&nbsp;vz])&nbsp;+&nbsp;0.5)&nbsp;*&nbsp;cell_size<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rel_pos&nbsp;=&nbsp;world_pos&nbsp;-&nbsp;centroid<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u&nbsp;=&nbsp;float(np.dot(rel_pos,&nbsp;u_axis))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v&nbsp;=&nbsp;float(np.dot(rel_pos,&nbsp;v_axis))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid_u&nbsp;=&nbsp;_round_half_up(u&nbsp;/&nbsp;cell_size)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid_v&nbsp;=&nbsp;_round_half_up(v&nbsp;/&nbsp;cell_size)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;voxel_to_2d[voxel]&nbsp;=&nbsp;(grid_u,&nbsp;grid_v)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(grid_u,&nbsp;grid_v)&nbsp;not&nbsp;in&nbsp;grid_2d_to_voxels:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid_2d_to_voxels[(grid_u,&nbsp;grid_v)]&nbsp;=&nbsp;[]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid_2d_to_voxels[(grid_u,&nbsp;grid_v)].append(voxel)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Bresenham&nbsp;для&nbsp;связности<br>
&nbsp;&nbsp;&nbsp;&nbsp;region_set&nbsp;=&nbsp;set(region_voxels)<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;voxel&nbsp;in&nbsp;region_voxels:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx,&nbsp;vy,&nbsp;vz&nbsp;=&nbsp;voxel<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;dx&nbsp;in&nbsp;(-1,&nbsp;0,&nbsp;1):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;dy&nbsp;in&nbsp;(-1,&nbsp;0,&nbsp;1):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;dz&nbsp;in&nbsp;(-1,&nbsp;0,&nbsp;1):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;dx&nbsp;==&nbsp;0&nbsp;and&nbsp;dy&nbsp;==&nbsp;0&nbsp;and&nbsp;dz&nbsp;==&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbor&nbsp;=&nbsp;(vx&nbsp;+&nbsp;dx,&nbsp;vy&nbsp;+&nbsp;dy,&nbsp;vz&nbsp;+&nbsp;dz)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;neighbor&nbsp;in&nbsp;region_set&nbsp;and&nbsp;neighbor&nbsp;&gt;&nbsp;voxel:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u1,&nbsp;v1&nbsp;=&nbsp;voxel_to_2d[voxel]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u2,&nbsp;v2&nbsp;=&nbsp;voxel_to_2d[neighbor]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line_cells&nbsp;=&nbsp;bresenham_line(u1,&nbsp;v1,&nbsp;u2,&nbsp;v2)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;cell&nbsp;in&nbsp;line_cells:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;cell&nbsp;not&nbsp;in&nbsp;grid_2d_to_voxels:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid_2d_to_voxels[cell]&nbsp;=&nbsp;[voxel]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Создаём&nbsp;маску<br>
&nbsp;&nbsp;&nbsp;&nbsp;all_2d&nbsp;=&nbsp;list(grid_2d_to_voxels.keys())<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;all_2d:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;set(),&nbsp;set()<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;min_u&nbsp;=&nbsp;min(p[0]&nbsp;for&nbsp;p&nbsp;in&nbsp;all_2d)<br>
&nbsp;&nbsp;&nbsp;&nbsp;max_u&nbsp;=&nbsp;max(p[0]&nbsp;for&nbsp;p&nbsp;in&nbsp;all_2d)<br>
&nbsp;&nbsp;&nbsp;&nbsp;min_v&nbsp;=&nbsp;min(p[1]&nbsp;for&nbsp;p&nbsp;in&nbsp;all_2d)<br>
&nbsp;&nbsp;&nbsp;&nbsp;max_v&nbsp;=&nbsp;max(p[1]&nbsp;for&nbsp;p&nbsp;in&nbsp;all_2d)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;width&nbsp;=&nbsp;max_u&nbsp;-&nbsp;min_u&nbsp;+&nbsp;3<br>
&nbsp;&nbsp;&nbsp;&nbsp;height&nbsp;=&nbsp;max_v&nbsp;-&nbsp;min_v&nbsp;+&nbsp;3<br>
&nbsp;&nbsp;&nbsp;&nbsp;offset_u&nbsp;=&nbsp;-min_u&nbsp;+&nbsp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;offset_v&nbsp;=&nbsp;-min_v&nbsp;+&nbsp;1<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;mask&nbsp;=&nbsp;np.zeros((height,&nbsp;width),&nbsp;dtype=np.uint8)<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(gu,&nbsp;gv)&nbsp;in&nbsp;all_2d:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mask[gv&nbsp;+&nbsp;offset_v,&nbsp;gu&nbsp;+&nbsp;offset_u]&nbsp;=&nbsp;1<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Distance&nbsp;field&nbsp;в&nbsp;2D<br>
&nbsp;&nbsp;&nbsp;&nbsp;distance_2d&nbsp;=&nbsp;compute_distance_field_2d(mask)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Сглаживание&nbsp;для&nbsp;устранения&nbsp;ложных&nbsp;пиков&nbsp;на&nbsp;хребтах<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;smoothing&nbsp;&gt;&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;distance_2d&nbsp;=&nbsp;smooth_distance_field_2d(distance_2d,&nbsp;mask,&nbsp;smoothing)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;debug:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max_dist&nbsp;=&nbsp;float(np.max(distance_2d))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(f&quot;&nbsp;&nbsp;region:&nbsp;voxels={len(region_voxels)},&nbsp;mask={width}x{height},&nbsp;max_dist={max_dist:.2f},&nbsp;smoothing={smoothing}&quot;)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Находим&nbsp;пики&nbsp;в&nbsp;2D<br>
&nbsp;&nbsp;&nbsp;&nbsp;all_maxima_2d,&nbsp;plateau_peaks_2d&nbsp;=&nbsp;find_distance_field_peaks_2d(distance_2d,&nbsp;debug=debug)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Маппим&nbsp;пики&nbsp;обратно&nbsp;в&nbsp;3D&nbsp;воксели<br>
&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;map_2d_to_3d(points_2d):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result:&nbsp;set[tuple[int,&nbsp;int,&nbsp;int]]&nbsp;=&nbsp;set()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(pu,&nbsp;pv)&nbsp;in&nbsp;points_2d:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid_u&nbsp;=&nbsp;pu&nbsp;-&nbsp;offset_u<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid_v&nbsp;=&nbsp;pv&nbsp;-&nbsp;offset_v<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(grid_u,&nbsp;grid_v)&nbsp;in&nbsp;grid_2d_to_voxels:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;voxel&nbsp;in&nbsp;grid_2d_to_voxels[(grid_u,&nbsp;grid_v)]:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.add(voxel)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;all_maxima_voxels&nbsp;=&nbsp;map_2d_to_3d(all_maxima_2d)<br>
&nbsp;&nbsp;&nbsp;&nbsp;plateau_peaks_voxels&nbsp;=&nbsp;map_2d_to_3d(plateau_peaks_2d)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;all_maxima_voxels,&nbsp;plateau_peaks_voxels<br>
<br>
<br>
def&nbsp;compute_distance_field_for_region(<br>
&nbsp;&nbsp;&nbsp;&nbsp;region_voxels:&nbsp;list[tuple[int,&nbsp;int,&nbsp;int]],<br>
&nbsp;&nbsp;&nbsp;&nbsp;region_normal:&nbsp;np.ndarray,<br>
&nbsp;&nbsp;&nbsp;&nbsp;cell_size:&nbsp;float,<br>
&nbsp;&nbsp;&nbsp;&nbsp;origin:&nbsp;np.ndarray,<br>
)&nbsp;-&gt;&nbsp;dict[tuple[int,&nbsp;int,&nbsp;int],&nbsp;float]:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Вычислить&nbsp;distance&nbsp;field&nbsp;для&nbsp;региона.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Проецирует&nbsp;регион&nbsp;на&nbsp;2D,&nbsp;вычисляет&nbsp;distance&nbsp;field,<br>
&nbsp;&nbsp;&nbsp;&nbsp;и&nbsp;возвращает&nbsp;маппинг&nbsp;3D&nbsp;воксель&nbsp;-&gt;&nbsp;расстояние.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;region_voxels:&nbsp;Список&nbsp;вокселей&nbsp;региона&nbsp;(vx,&nbsp;vy,&nbsp;vz).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;region_normal:&nbsp;Нормаль&nbsp;региона.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cell_size:&nbsp;Размер&nbsp;вокселя.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;origin:&nbsp;Начало&nbsp;координат&nbsp;сетки.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{(vx,&nbsp;vy,&nbsp;vz):&nbsp;distance}&nbsp;для&nbsp;каждого&nbsp;вокселя&nbsp;региона.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;len(region_voxels)&nbsp;&lt;&nbsp;1:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;{}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Строим&nbsp;локальную&nbsp;2D&nbsp;систему&nbsp;координат<br>
&nbsp;&nbsp;&nbsp;&nbsp;u_axis,&nbsp;v_axis&nbsp;=&nbsp;build_2d_basis(region_normal)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Центроид&nbsp;региона<br>
&nbsp;&nbsp;&nbsp;&nbsp;centers_3d&nbsp;=&nbsp;np.array([<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;origin&nbsp;+&nbsp;(np.array(v)&nbsp;+&nbsp;0.5)&nbsp;*&nbsp;cell_size<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;v&nbsp;in&nbsp;region_voxels<br>
&nbsp;&nbsp;&nbsp;&nbsp;],&nbsp;dtype=np.float32)<br>
&nbsp;&nbsp;&nbsp;&nbsp;centroid&nbsp;=&nbsp;centers_3d.mean(axis=0)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Проецируем&nbsp;воксели&nbsp;на&nbsp;2D<br>
&nbsp;&nbsp;&nbsp;&nbsp;voxel_to_2d:&nbsp;dict[tuple[int,&nbsp;int,&nbsp;int],&nbsp;tuple[int,&nbsp;int]]&nbsp;=&nbsp;{}<br>
&nbsp;&nbsp;&nbsp;&nbsp;grid_2d_to_voxels:&nbsp;dict[tuple[int,&nbsp;int],&nbsp;list[tuple[int,&nbsp;int,&nbsp;int]]]&nbsp;=&nbsp;{}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;voxel&nbsp;in&nbsp;region_voxels:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx,&nbsp;vy,&nbsp;vz&nbsp;=&nbsp;voxel<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;world_pos&nbsp;=&nbsp;origin&nbsp;+&nbsp;(np.array([vx,&nbsp;vy,&nbsp;vz])&nbsp;+&nbsp;0.5)&nbsp;*&nbsp;cell_size<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rel_pos&nbsp;=&nbsp;world_pos&nbsp;-&nbsp;centroid<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u&nbsp;=&nbsp;float(np.dot(rel_pos,&nbsp;u_axis))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v&nbsp;=&nbsp;float(np.dot(rel_pos,&nbsp;v_axis))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid_u&nbsp;=&nbsp;_round_half_up(u&nbsp;/&nbsp;cell_size)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid_v&nbsp;=&nbsp;_round_half_up(v&nbsp;/&nbsp;cell_size)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;voxel_to_2d[voxel]&nbsp;=&nbsp;(grid_u,&nbsp;grid_v)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(grid_u,&nbsp;grid_v)&nbsp;not&nbsp;in&nbsp;grid_2d_to_voxels:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid_2d_to_voxels[(grid_u,&nbsp;grid_v)]&nbsp;=&nbsp;[]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid_2d_to_voxels[(grid_u,&nbsp;grid_v)].append(voxel)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Находим&nbsp;соседей&nbsp;в&nbsp;3D&nbsp;и&nbsp;рисуем&nbsp;линии&nbsp;Брезенхема&nbsp;в&nbsp;2D<br>
&nbsp;&nbsp;&nbsp;&nbsp;region_set&nbsp;=&nbsp;set(region_voxels)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;voxel&nbsp;in&nbsp;region_voxels:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx,&nbsp;vy,&nbsp;vz&nbsp;=&nbsp;voxel<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;dx&nbsp;in&nbsp;(-1,&nbsp;0,&nbsp;1):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;dy&nbsp;in&nbsp;(-1,&nbsp;0,&nbsp;1):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;dz&nbsp;in&nbsp;(-1,&nbsp;0,&nbsp;1):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;dx&nbsp;==&nbsp;0&nbsp;and&nbsp;dy&nbsp;==&nbsp;0&nbsp;and&nbsp;dz&nbsp;==&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbor&nbsp;=&nbsp;(vx&nbsp;+&nbsp;dx,&nbsp;vy&nbsp;+&nbsp;dy,&nbsp;vz&nbsp;+&nbsp;dz)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;neighbor&nbsp;in&nbsp;region_set&nbsp;and&nbsp;neighbor&nbsp;&gt;&nbsp;voxel:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u1,&nbsp;v1&nbsp;=&nbsp;voxel_to_2d[voxel]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u2,&nbsp;v2&nbsp;=&nbsp;voxel_to_2d[neighbor]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line_cells&nbsp;=&nbsp;bresenham_line(u1,&nbsp;v1,&nbsp;u2,&nbsp;v2)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;cell&nbsp;in&nbsp;line_cells:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;cell&nbsp;not&nbsp;in&nbsp;grid_2d_to_voxels:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid_2d_to_voxels[cell]&nbsp;=&nbsp;[voxel]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Создаём&nbsp;бинарную&nbsp;маску<br>
&nbsp;&nbsp;&nbsp;&nbsp;all_2d&nbsp;=&nbsp;list(grid_2d_to_voxels.keys())<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;all_2d:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;{}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;min_u&nbsp;=&nbsp;min(p[0]&nbsp;for&nbsp;p&nbsp;in&nbsp;all_2d)<br>
&nbsp;&nbsp;&nbsp;&nbsp;max_u&nbsp;=&nbsp;max(p[0]&nbsp;for&nbsp;p&nbsp;in&nbsp;all_2d)<br>
&nbsp;&nbsp;&nbsp;&nbsp;min_v&nbsp;=&nbsp;min(p[1]&nbsp;for&nbsp;p&nbsp;in&nbsp;all_2d)<br>
&nbsp;&nbsp;&nbsp;&nbsp;max_v&nbsp;=&nbsp;max(p[1]&nbsp;for&nbsp;p&nbsp;in&nbsp;all_2d)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;width&nbsp;=&nbsp;max_u&nbsp;-&nbsp;min_u&nbsp;+&nbsp;3<br>
&nbsp;&nbsp;&nbsp;&nbsp;height&nbsp;=&nbsp;max_v&nbsp;-&nbsp;min_v&nbsp;+&nbsp;3<br>
&nbsp;&nbsp;&nbsp;&nbsp;offset_u&nbsp;=&nbsp;-min_u&nbsp;+&nbsp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;offset_v&nbsp;=&nbsp;-min_v&nbsp;+&nbsp;1<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;mask&nbsp;=&nbsp;np.zeros((height,&nbsp;width),&nbsp;dtype=np.uint8)<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(gu,&nbsp;gv)&nbsp;in&nbsp;all_2d:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mask[gv&nbsp;+&nbsp;offset_v,&nbsp;gu&nbsp;+&nbsp;offset_u]&nbsp;=&nbsp;1<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Вычисляем&nbsp;distance&nbsp;field&nbsp;в&nbsp;2D<br>
&nbsp;&nbsp;&nbsp;&nbsp;distance_2d&nbsp;=&nbsp;compute_distance_field_2d(mask)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Конвертируем&nbsp;обратно&nbsp;в&nbsp;3D<br>
&nbsp;&nbsp;&nbsp;&nbsp;result:&nbsp;dict[tuple[int,&nbsp;int,&nbsp;int],&nbsp;float]&nbsp;=&nbsp;{}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;voxel&nbsp;in&nbsp;region_voxels:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid_u,&nbsp;grid_v&nbsp;=&nbsp;voxel_to_2d[voxel]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mask_u&nbsp;=&nbsp;grid_u&nbsp;+&nbsp;offset_u<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mask_v&nbsp;=&nbsp;grid_v&nbsp;+&nbsp;offset_v<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;0&nbsp;&lt;=&nbsp;mask_u&nbsp;&lt;&nbsp;width&nbsp;and&nbsp;0&nbsp;&lt;=&nbsp;mask_v&nbsp;&lt;&nbsp;height:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result[voxel]&nbsp;=&nbsp;float(distance_2d[mask_v,&nbsp;mask_u])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result[voxel]&nbsp;=&nbsp;0.0<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result<br>
<br>
<br>
@dataclass<br>
class&nbsp;EdgeContourResult:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Результат&nbsp;извлечения&nbsp;контуров&nbsp;по&nbsp;рёбрам.&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;outer:&nbsp;list[tuple[float,&nbsp;float]]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Внешний&nbsp;контур&nbsp;(вершины&nbsp;на&nbsp;углах&nbsp;ячеек).&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;holes:&nbsp;list[list[tuple[float,&nbsp;float]]]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Дырки&nbsp;(вершины&nbsp;на&nbsp;углах&nbsp;ячеек).&quot;&quot;&quot;<br>
<br>
<br>
def&nbsp;_round_half_up(x:&nbsp;float)&nbsp;-&gt;&nbsp;int:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Round&nbsp;to&nbsp;nearest&nbsp;integer,&nbsp;with&nbsp;.5&nbsp;rounding&nbsp;up&nbsp;(away&nbsp;from&nbsp;zero&nbsp;for&nbsp;positive).&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;int(math.floor(x&nbsp;+&nbsp;0.5))<br>
<br>
<br>
def&nbsp;create_2d_label_map(<br>
&nbsp;&nbsp;&nbsp;&nbsp;regions:&nbsp;list[tuple[list[tuple[int,&nbsp;int,&nbsp;int]],&nbsp;np.ndarray]],<br>
&nbsp;&nbsp;&nbsp;&nbsp;cell_size:&nbsp;float,<br>
&nbsp;&nbsp;&nbsp;&nbsp;origin:&nbsp;np.ndarray,<br>
)&nbsp;-&gt;&nbsp;tuple[np.ndarray,&nbsp;dict[tuple[int,&nbsp;int],&nbsp;int],&nbsp;int,&nbsp;int,&nbsp;np.ndarray,&nbsp;np.ndarray]:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Создать&nbsp;2D&nbsp;карту&nbsp;меток&nbsp;из&nbsp;списка&nbsp;регионов.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Все&nbsp;регионы&nbsp;проецируются&nbsp;в&nbsp;единую&nbsp;2D&nbsp;систему&nbsp;координат.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Каждая&nbsp;ячейка&nbsp;получает&nbsp;ID&nbsp;региона,&nbsp;которому&nbsp;принадлежит.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;regions:&nbsp;Список&nbsp;(voxels,&nbsp;normal)&nbsp;для&nbsp;каждого&nbsp;региона.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cell_size:&nbsp;Размер&nbsp;вокселя.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;origin:&nbsp;Начало&nbsp;координат&nbsp;сетки.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(labels,&nbsp;cell_to_region,&nbsp;width,&nbsp;height,&nbsp;u_axis,&nbsp;v_axis):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;labels:&nbsp;2D&nbsp;массив&nbsp;меток&nbsp;(height,&nbsp;width).&nbsp;0&nbsp;=&nbsp;пусто,&nbsp;1+&nbsp;=&nbsp;region_id&nbsp;+&nbsp;1.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cell_to_region:&nbsp;mapping&nbsp;(grid_u,&nbsp;grid_v)&nbsp;-&gt;&nbsp;region_id.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width,&nbsp;height:&nbsp;размеры&nbsp;массива.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u_axis,&nbsp;v_axis:&nbsp;базис&nbsp;2D&nbsp;проекции.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;regions:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;np.array([]),&nbsp;{},&nbsp;0,&nbsp;0,&nbsp;np.array([1,&nbsp;0,&nbsp;0]),&nbsp;np.array([0,&nbsp;1,&nbsp;0])<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Используем&nbsp;нормаль&nbsp;первого&nbsp;региона&nbsp;для&nbsp;построения&nbsp;общего&nbsp;базиса<br>
&nbsp;&nbsp;&nbsp;&nbsp;_,&nbsp;first_normal&nbsp;=&nbsp;regions[0]<br>
&nbsp;&nbsp;&nbsp;&nbsp;u_axis,&nbsp;v_axis&nbsp;=&nbsp;build_2d_basis(first_normal)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Собираем&nbsp;все&nbsp;воксели&nbsp;всех&nbsp;регионов&nbsp;и&nbsp;вычисляем&nbsp;общий&nbsp;центроид<br>
&nbsp;&nbsp;&nbsp;&nbsp;all_voxels:&nbsp;list[tuple[int,&nbsp;int,&nbsp;int]]&nbsp;=&nbsp;[]<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;voxels,&nbsp;_&nbsp;in&nbsp;regions:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;all_voxels.extend(voxels)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;all_voxels:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;np.array([]),&nbsp;{},&nbsp;0,&nbsp;0,&nbsp;u_axis,&nbsp;v_axis<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Общий&nbsp;центроид<br>
&nbsp;&nbsp;&nbsp;&nbsp;centers_3d&nbsp;=&nbsp;np.array([<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;origin&nbsp;+&nbsp;(np.array(v)&nbsp;+&nbsp;0.5)&nbsp;*&nbsp;cell_size<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;v&nbsp;in&nbsp;all_voxels<br>
&nbsp;&nbsp;&nbsp;&nbsp;],&nbsp;dtype=np.float32)<br>
&nbsp;&nbsp;&nbsp;&nbsp;centroid&nbsp;=&nbsp;centers_3d.mean(axis=0)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Проецируем&nbsp;все&nbsp;воксели&nbsp;и&nbsp;определяем&nbsp;размеры&nbsp;сетки<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Используем&nbsp;floor-based&nbsp;rounding&nbsp;чтобы&nbsp;избежать&nbsp;коллизий&nbsp;от&nbsp;banker's&nbsp;rounding<br>
&nbsp;&nbsp;&nbsp;&nbsp;all_2d:&nbsp;list[tuple[int,&nbsp;int]]&nbsp;=&nbsp;[]<br>
&nbsp;&nbsp;&nbsp;&nbsp;voxel_to_2d:&nbsp;dict[tuple[int,&nbsp;int,&nbsp;int],&nbsp;tuple[int,&nbsp;int]]&nbsp;=&nbsp;{}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;voxel&nbsp;in&nbsp;all_voxels:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx,&nbsp;vy,&nbsp;vz&nbsp;=&nbsp;voxel<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;world_pos&nbsp;=&nbsp;origin&nbsp;+&nbsp;(np.array([vx,&nbsp;vy,&nbsp;vz])&nbsp;+&nbsp;0.5)&nbsp;*&nbsp;cell_size<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rel_pos&nbsp;=&nbsp;world_pos&nbsp;-&nbsp;centroid<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u&nbsp;=&nbsp;float(np.dot(rel_pos,&nbsp;u_axis))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v&nbsp;=&nbsp;float(np.dot(rel_pos,&nbsp;v_axis))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid_u&nbsp;=&nbsp;_round_half_up(u&nbsp;/&nbsp;cell_size)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid_v&nbsp;=&nbsp;_round_half_up(v&nbsp;/&nbsp;cell_size)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;voxel_to_2d[voxel]&nbsp;=&nbsp;(grid_u,&nbsp;grid_v)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;all_2d.append((grid_u,&nbsp;grid_v))<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;all_2d:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;np.array([]),&nbsp;{},&nbsp;0,&nbsp;0,&nbsp;u_axis,&nbsp;v_axis<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;min_u&nbsp;=&nbsp;min(p[0]&nbsp;for&nbsp;p&nbsp;in&nbsp;all_2d)<br>
&nbsp;&nbsp;&nbsp;&nbsp;max_u&nbsp;=&nbsp;max(p[0]&nbsp;for&nbsp;p&nbsp;in&nbsp;all_2d)<br>
&nbsp;&nbsp;&nbsp;&nbsp;min_v&nbsp;=&nbsp;min(p[1]&nbsp;for&nbsp;p&nbsp;in&nbsp;all_2d)<br>
&nbsp;&nbsp;&nbsp;&nbsp;max_v&nbsp;=&nbsp;max(p[1]&nbsp;for&nbsp;p&nbsp;in&nbsp;all_2d)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Добавляем&nbsp;padding&nbsp;для&nbsp;корректной&nbsp;обработки&nbsp;границ<br>
&nbsp;&nbsp;&nbsp;&nbsp;width&nbsp;=&nbsp;max_u&nbsp;-&nbsp;min_u&nbsp;+&nbsp;3<br>
&nbsp;&nbsp;&nbsp;&nbsp;height&nbsp;=&nbsp;max_v&nbsp;-&nbsp;min_v&nbsp;+&nbsp;3<br>
&nbsp;&nbsp;&nbsp;&nbsp;offset_u&nbsp;=&nbsp;-min_u&nbsp;+&nbsp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;offset_v&nbsp;=&nbsp;-min_v&nbsp;+&nbsp;1<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Создаём&nbsp;массив&nbsp;меток&nbsp;(0&nbsp;=&nbsp;пусто)<br>
&nbsp;&nbsp;&nbsp;&nbsp;labels&nbsp;=&nbsp;np.zeros((height,&nbsp;width),&nbsp;dtype=np.int32)<br>
&nbsp;&nbsp;&nbsp;&nbsp;cell_to_region:&nbsp;dict[tuple[int,&nbsp;int],&nbsp;int]&nbsp;=&nbsp;{}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Заполняем&nbsp;метки:&nbsp;каждый&nbsp;воксель&nbsp;принадлежит&nbsp;одному&nbsp;региону<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Если&nbsp;воксель&nbsp;принадлежит&nbsp;нескольким&nbsp;регионам,&nbsp;берём&nbsp;первый<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;region_idx,&nbsp;(voxels,&nbsp;_)&nbsp;in&nbsp;enumerate(regions):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;region_id&nbsp;=&nbsp;region_idx&nbsp;+&nbsp;1&nbsp;&nbsp;#&nbsp;1-based&nbsp;region&nbsp;IDs<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;voxel&nbsp;in&nbsp;voxels:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;voxel&nbsp;not&nbsp;in&nbsp;voxel_to_2d:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid_u,&nbsp;grid_v&nbsp;=&nbsp;voxel_to_2d[voxel]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mask_u&nbsp;=&nbsp;grid_u&nbsp;+&nbsp;offset_u<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mask_v&nbsp;=&nbsp;grid_v&nbsp;+&nbsp;offset_v<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Первый&nbsp;регион&nbsp;выигрывает&nbsp;(или&nbsp;можно&nbsp;выбрать&nbsp;по&nbsp;другому&nbsp;критерию)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;labels[mask_v,&nbsp;mask_u]&nbsp;==&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;labels[mask_v,&nbsp;mask_u]&nbsp;=&nbsp;region_id<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cell_to_region[(mask_u,&nbsp;mask_v)]&nbsp;=&nbsp;region_idx<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;labels,&nbsp;cell_to_region,&nbsp;width,&nbsp;height,&nbsp;u_axis,&nbsp;v_axis<br>
<br>
<br>
def&nbsp;extract_edge_contour_for_region(<br>
&nbsp;&nbsp;&nbsp;&nbsp;labels:&nbsp;np.ndarray,<br>
&nbsp;&nbsp;&nbsp;&nbsp;region_id:&nbsp;int,<br>
)&nbsp;-&gt;&nbsp;EdgeContourResult:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Извлечь&nbsp;контуры&nbsp;региона&nbsp;по&nbsp;рёбрам&nbsp;ячеек.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Контур&nbsp;идёт&nbsp;по&nbsp;границам&nbsp;между&nbsp;ячейками&nbsp;с&nbsp;разными&nbsp;метками.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Вершины&nbsp;находятся&nbsp;на&nbsp;углах&nbsp;ячеек&nbsp;(не&nbsp;центрах).<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;labels:&nbsp;2D&nbsp;массив&nbsp;меток&nbsp;(height,&nbsp;width).&nbsp;0&nbsp;=&nbsp;пусто.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;region_id:&nbsp;ID&nbsp;региона&nbsp;(1-based).<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeContourResult&nbsp;с&nbsp;внешним&nbsp;контуром&nbsp;и&nbsp;дырками.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;height,&nbsp;width&nbsp;=&nbsp;labels.shape<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Собираем&nbsp;все&nbsp;рёбра,&nbsp;где&nbsp;region_id&nbsp;граничит&nbsp;с&nbsp;другим&nbsp;значением<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Ребро&nbsp;между&nbsp;ячейками&nbsp;(u,&nbsp;v)&nbsp;и&nbsp;(u+1,&nbsp;v)&nbsp;-&nbsp;вертикальное<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Ребро&nbsp;между&nbsp;ячейками&nbsp;(u,&nbsp;v)&nbsp;и&nbsp;(u,&nbsp;v+1)&nbsp;-&nbsp;горизонтальное<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Каждое&nbsp;ребро&nbsp;описывается&nbsp;двумя&nbsp;концами&nbsp;(координаты&nbsp;углов)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Рёбра&nbsp;храним&nbsp;как:&nbsp;((x1,&nbsp;y1),&nbsp;(x2,&nbsp;y2))&nbsp;где&nbsp;координаты&nbsp;-&nbsp;углы&nbsp;ячеек<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Углы&nbsp;ячейки&nbsp;(u,&nbsp;v):&nbsp;(u,&nbsp;v),&nbsp;(u+1,&nbsp;v),&nbsp;(u,&nbsp;v+1),&nbsp;(u+1,&nbsp;v+1)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;edges:&nbsp;set[tuple[tuple[float,&nbsp;float],&nbsp;tuple[float,&nbsp;float]]]&nbsp;=&nbsp;set()<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;v&nbsp;in&nbsp;range(height):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;u&nbsp;in&nbsp;range(width):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;labels[v,&nbsp;u]&nbsp;!=&nbsp;region_id:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Проверяем&nbsp;4&nbsp;соседа&nbsp;и&nbsp;добавляем&nbsp;рёбра&nbsp;где&nbsp;граница<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Правый&nbsp;сосед&nbsp;(u+1,&nbsp;v)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;u&nbsp;+&nbsp;1&nbsp;&gt;=&nbsp;width&nbsp;or&nbsp;labels[v,&nbsp;u&nbsp;+&nbsp;1]&nbsp;!=&nbsp;region_id:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Вертикальное&nbsp;ребро&nbsp;справа&nbsp;от&nbsp;(u,&nbsp;v)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Углы:&nbsp;(u+1,&nbsp;v)&nbsp;-&gt;&nbsp;(u+1,&nbsp;v+1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge&nbsp;=&nbsp;((u&nbsp;+&nbsp;1.0,&nbsp;v),&nbsp;(u&nbsp;+&nbsp;1.0,&nbsp;v&nbsp;+&nbsp;1.0))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edges.add(edge)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Левый&nbsp;сосед&nbsp;(u-1,&nbsp;v)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;u&nbsp;-&nbsp;1&nbsp;&lt;&nbsp;0&nbsp;or&nbsp;labels[v,&nbsp;u&nbsp;-&nbsp;1]&nbsp;!=&nbsp;region_id:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Вертикальное&nbsp;ребро&nbsp;слева&nbsp;от&nbsp;(u,&nbsp;v)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Углы:&nbsp;(u,&nbsp;v+1)&nbsp;-&gt;&nbsp;(u,&nbsp;v)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge&nbsp;=&nbsp;((u,&nbsp;v&nbsp;+&nbsp;1.0),&nbsp;(u,&nbsp;v))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edges.add(edge)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Нижний&nbsp;сосед&nbsp;(u,&nbsp;v+1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;v&nbsp;+&nbsp;1&nbsp;&gt;=&nbsp;height&nbsp;or&nbsp;labels[v&nbsp;+&nbsp;1,&nbsp;u]&nbsp;!=&nbsp;region_id:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Горизонтальное&nbsp;ребро&nbsp;снизу&nbsp;от&nbsp;(u,&nbsp;v)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Углы:&nbsp;(u+1,&nbsp;v+1)&nbsp;-&gt;&nbsp;(u,&nbsp;v+1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge&nbsp;=&nbsp;((u&nbsp;+&nbsp;1.0,&nbsp;v&nbsp;+&nbsp;1.0),&nbsp;(u,&nbsp;v&nbsp;+&nbsp;1.0))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edges.add(edge)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Верхний&nbsp;сосед&nbsp;(u,&nbsp;v-1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;v&nbsp;-&nbsp;1&nbsp;&lt;&nbsp;0&nbsp;or&nbsp;labels[v&nbsp;-&nbsp;1,&nbsp;u]&nbsp;!=&nbsp;region_id:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Горизонтальное&nbsp;ребро&nbsp;сверху&nbsp;от&nbsp;(u,&nbsp;v)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Углы:&nbsp;(u,&nbsp;v)&nbsp;-&gt;&nbsp;(u+1,&nbsp;v)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge&nbsp;=&nbsp;((u,&nbsp;v),&nbsp;(u&nbsp;+&nbsp;1.0,&nbsp;v))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edges.add(edge)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;edges:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;EdgeContourResult(outer=[],&nbsp;holes=[])<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Строим&nbsp;граф:&nbsp;vertex&nbsp;-&gt;&nbsp;list&nbsp;of&nbsp;outgoing&nbsp;edges<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Каждое&nbsp;ребро&nbsp;ориентировано&nbsp;так,&nbsp;что&nbsp;регион&nbsp;справа&nbsp;(внешний&nbsp;контур&nbsp;CCW)<br>
&nbsp;&nbsp;&nbsp;&nbsp;graph:&nbsp;dict[tuple[float,&nbsp;float],&nbsp;list[tuple[float,&nbsp;float]]]&nbsp;=&nbsp;{}<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(start,&nbsp;end)&nbsp;in&nbsp;edges:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;start&nbsp;not&nbsp;in&nbsp;graph:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;graph[start]&nbsp;=&nbsp;[]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;graph[start].append(end)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Находим&nbsp;все&nbsp;замкнутые&nbsp;контуры<br>
&nbsp;&nbsp;&nbsp;&nbsp;contours:&nbsp;list[list[tuple[float,&nbsp;float]]]&nbsp;=&nbsp;[]<br>
&nbsp;&nbsp;&nbsp;&nbsp;used_edges:&nbsp;set[tuple[tuple[float,&nbsp;float],&nbsp;tuple[float,&nbsp;float]]]&nbsp;=&nbsp;set()<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;start_vertex&nbsp;in&nbsp;graph:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;next_vertex&nbsp;in&nbsp;graph[start_vertex]:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge&nbsp;=&nbsp;(start_vertex,&nbsp;next_vertex)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;edge&nbsp;in&nbsp;used_edges:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Обходим&nbsp;контур<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;contour:&nbsp;list[tuple[float,&nbsp;float]]&nbsp;=&nbsp;[start_vertex]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current&nbsp;=&nbsp;next_vertex<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prev&nbsp;=&nbsp;start_vertex<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;current&nbsp;!=&nbsp;start_vertex:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;contour.append(current)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;used_edges.add((prev,&nbsp;current))<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Находим&nbsp;следующее&nbsp;ребро<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;current&nbsp;not&nbsp;in&nbsp;graph:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;candidates&nbsp;=&nbsp;graph[current]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Выбираем&nbsp;ребро,&nbsp;поворачивая&nbsp;максимально&nbsp;вправо<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;(для&nbsp;CCW&nbsp;обхода&nbsp;внешнего&nbsp;контура)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;next_edge&nbsp;=&nbsp;_select_rightmost_edge(prev,&nbsp;current,&nbsp;candidates)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;next_edge&nbsp;is&nbsp;None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prev&nbsp;=&nbsp;current<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current&nbsp;=&nbsp;next_edge<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;current&nbsp;==&nbsp;start_vertex:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;used_edges.add((prev,&nbsp;current))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;contours.append(contour)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;contours:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;EdgeContourResult(outer=[],&nbsp;holes=[])<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Определяем&nbsp;какой&nbsp;контур&nbsp;внешний&nbsp;(максимальная&nbsp;площадь,&nbsp;положительная)<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;и&nbsp;какие&nbsp;-&nbsp;дырки&nbsp;(отрицательная&nbsp;площадь)<br>
&nbsp;&nbsp;&nbsp;&nbsp;outer:&nbsp;list[tuple[float,&nbsp;float]]&nbsp;=&nbsp;[]<br>
&nbsp;&nbsp;&nbsp;&nbsp;holes:&nbsp;list[list[tuple[float,&nbsp;float]]]&nbsp;=&nbsp;[]<br>
&nbsp;&nbsp;&nbsp;&nbsp;max_area&nbsp;=&nbsp;float('-inf')<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;contour&nbsp;in&nbsp;contours:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;area&nbsp;=&nbsp;_signed_area_contour(contour)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;area&nbsp;&gt;&nbsp;max_area:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;outer:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Предыдущий&nbsp;outer&nbsp;становится&nbsp;дыркой<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;holes.append(outer)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outer&nbsp;=&nbsp;contour<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max_area&nbsp;=&nbsp;area<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;holes.append(contour)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Внешний&nbsp;контур&nbsp;должен&nbsp;быть&nbsp;CCW&nbsp;(положительная&nbsp;площадь)<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;_signed_area_contour(outer)&nbsp;&lt;&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outer&nbsp;=&nbsp;list(reversed(outer))<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Дырки&nbsp;должны&nbsp;быть&nbsp;CW&nbsp;(отрицательная&nbsp;площадь)<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i&nbsp;in&nbsp;range(len(holes)):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;_signed_area_contour(holes[i])&nbsp;&gt;&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;holes[i]&nbsp;=&nbsp;list(reversed(holes[i]))<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;EdgeContourResult(outer=outer,&nbsp;holes=holes)<br>
<br>
<br>
def&nbsp;_select_rightmost_edge(<br>
&nbsp;&nbsp;&nbsp;&nbsp;prev:&nbsp;tuple[float,&nbsp;float],<br>
&nbsp;&nbsp;&nbsp;&nbsp;current:&nbsp;tuple[float,&nbsp;float],<br>
&nbsp;&nbsp;&nbsp;&nbsp;candidates:&nbsp;list[tuple[float,&nbsp;float]],<br>
)&nbsp;-&gt;&nbsp;tuple[float,&nbsp;float]&nbsp;|&nbsp;None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Выбрать&nbsp;следующее&nbsp;ребро,&nbsp;поворачивая&nbsp;максимально&nbsp;вправо.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Это&nbsp;обеспечивает&nbsp;CCW&nbsp;обход&nbsp;внешнего&nbsp;контура.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;candidates:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;None<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;len(candidates)&nbsp;==&nbsp;1:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;candidates[0]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Вектор&nbsp;прихода<br>
&nbsp;&nbsp;&nbsp;&nbsp;dx_in&nbsp;=&nbsp;current[0]&nbsp;-&nbsp;prev[0]<br>
&nbsp;&nbsp;&nbsp;&nbsp;dy_in&nbsp;=&nbsp;current[1]&nbsp;-&nbsp;prev[1]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;best_candidate&nbsp;=&nbsp;None<br>
&nbsp;&nbsp;&nbsp;&nbsp;best_angle&nbsp;=&nbsp;float('-inf')<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;candidate&nbsp;in&nbsp;candidates:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;candidate&nbsp;==&nbsp;prev:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Вектор&nbsp;ухода<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dx_out&nbsp;=&nbsp;candidate[0]&nbsp;-&nbsp;current[0]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dy_out&nbsp;=&nbsp;candidate[1]&nbsp;-&nbsp;current[1]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Угол&nbsp;поворота&nbsp;(отрицательный&nbsp;=&nbsp;вправо)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Используем&nbsp;atan2&nbsp;для&nbsp;определения&nbsp;угла&nbsp;между&nbsp;векторами<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cross&nbsp;=&nbsp;dx_in&nbsp;*&nbsp;dy_out&nbsp;-&nbsp;dy_in&nbsp;*&nbsp;dx_out&nbsp;&nbsp;#&nbsp;z-компонента&nbsp;векторного&nbsp;произведения<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dot&nbsp;=&nbsp;dx_in&nbsp;*&nbsp;dx_out&nbsp;+&nbsp;dy_in&nbsp;*&nbsp;dy_out<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;angle&nbsp;=&nbsp;math.atan2(cross,&nbsp;dot)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Для&nbsp;&quot;правого&nbsp;поворота&quot;&nbsp;выбираем&nbsp;минимальный&nbsp;угол&nbsp;(наиболее&nbsp;отрицательный)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Но&nbsp;для&nbsp;CCW&nbsp;обхода&nbsp;нам&nbsp;нужен&nbsp;&quot;левый&nbsp;поворот&quot;&nbsp;-&nbsp;максимальный&nbsp;угол<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;angle&nbsp;&gt;&nbsp;best_angle:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;best_angle&nbsp;=&nbsp;angle<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;best_candidate&nbsp;=&nbsp;candidate<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;best_candidate<br>
<br>
<br>
def&nbsp;_signed_area_contour(contour:&nbsp;list[tuple[float,&nbsp;float]])&nbsp;-&gt;&nbsp;float:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Вычислить&nbsp;знаковую&nbsp;площадь&nbsp;контура&nbsp;(положительная&nbsp;=&nbsp;CCW).&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;len(contour)&nbsp;&lt;&nbsp;3:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0.0<br>
&nbsp;&nbsp;&nbsp;&nbsp;area&nbsp;=&nbsp;0.0<br>
&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;=&nbsp;len(contour)<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i&nbsp;in&nbsp;range(n):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;=&nbsp;(i&nbsp;+&nbsp;1)&nbsp;%&nbsp;n<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;area&nbsp;+=&nbsp;contour[i][0]&nbsp;*&nbsp;contour[j][1]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;area&nbsp;-=&nbsp;contour[j][0]&nbsp;*&nbsp;contour[i][1]<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;area&nbsp;/&nbsp;2.0<br>
<br>
<br>
def&nbsp;extract_edge_contours_from_regions(<br>
&nbsp;&nbsp;&nbsp;&nbsp;regions:&nbsp;list[tuple[list[tuple[int,&nbsp;int,&nbsp;int]],&nbsp;np.ndarray]],<br>
&nbsp;&nbsp;&nbsp;&nbsp;cell_size:&nbsp;float,<br>
&nbsp;&nbsp;&nbsp;&nbsp;origin:&nbsp;np.ndarray,<br>
)&nbsp;-&gt;&nbsp;list[EdgeContourResult]:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Извлечь&nbsp;edge-based&nbsp;контуры&nbsp;для&nbsp;всех&nbsp;регионов.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Все&nbsp;регионы&nbsp;проецируются&nbsp;в&nbsp;единую&nbsp;2D&nbsp;систему&nbsp;координат,<br>
&nbsp;&nbsp;&nbsp;&nbsp;затем&nbsp;контуры&nbsp;извлекаются&nbsp;по&nbsp;рёбрам&nbsp;между&nbsp;ячейками.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;regions:&nbsp;Список&nbsp;(voxels,&nbsp;normal)&nbsp;для&nbsp;каждого&nbsp;региона.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cell_size:&nbsp;Размер&nbsp;вокселя.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;origin:&nbsp;Начало&nbsp;координат&nbsp;сетки.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Список&nbsp;EdgeContourResult&nbsp;для&nbsp;каждого&nbsp;региона.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;regions:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;[]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;labels,&nbsp;_,&nbsp;_,&nbsp;_,&nbsp;_,&nbsp;_&nbsp;=&nbsp;create_2d_label_map(regions,&nbsp;cell_size,&nbsp;origin)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;results:&nbsp;list[EdgeContourResult]&nbsp;=&nbsp;[]<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;region_idx&nbsp;in&nbsp;range(len(regions)):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;region_id&nbsp;=&nbsp;region_idx&nbsp;+&nbsp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;extract_edge_contour_for_region(labels,&nbsp;region_id)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;results.append(result)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;results<br>
<br>
<br>
@dataclass<br>
class&nbsp;SharedLabelMap:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Общая&nbsp;карта&nbsp;меток&nbsp;для&nbsp;группы&nbsp;регионов.&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;labels:&nbsp;np.ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;2D&nbsp;массив&nbsp;меток&nbsp;(height,&nbsp;width).&nbsp;0&nbsp;=&nbsp;пусто,&nbsp;1+&nbsp;=&nbsp;region_id&nbsp;+&nbsp;1.&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;width:&nbsp;int<br>
&nbsp;&nbsp;&nbsp;&nbsp;height:&nbsp;int<br>
&nbsp;&nbsp;&nbsp;&nbsp;offset_u:&nbsp;int<br>
&nbsp;&nbsp;&nbsp;&nbsp;offset_v:&nbsp;int<br>
&nbsp;&nbsp;&nbsp;&nbsp;u_axis:&nbsp;np.ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;v_axis:&nbsp;np.ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;centroid:&nbsp;np.ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;cell_size:&nbsp;float<br>
<br>
<br>
def&nbsp;create_shared_label_map(<br>
&nbsp;&nbsp;&nbsp;&nbsp;regions:&nbsp;list[tuple[list[tuple[int,&nbsp;int,&nbsp;int]],&nbsp;np.ndarray]],<br>
&nbsp;&nbsp;&nbsp;&nbsp;cell_size:&nbsp;float,<br>
&nbsp;&nbsp;&nbsp;&nbsp;origin:&nbsp;np.ndarray,<br>
)&nbsp;-&gt;&nbsp;SharedLabelMap&nbsp;|&nbsp;None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Создать&nbsp;общую&nbsp;карту&nbsp;меток&nbsp;для&nbsp;группы&nbsp;регионов.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;regions:&nbsp;Список&nbsp;(voxels,&nbsp;normal)&nbsp;для&nbsp;каждого&nbsp;региона.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cell_size:&nbsp;Размер&nbsp;вокселя.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;origin:&nbsp;Начало&nbsp;координат&nbsp;сетки.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SharedLabelMap&nbsp;или&nbsp;None&nbsp;если&nbsp;регионы&nbsp;пусты.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;labels,&nbsp;_,&nbsp;width,&nbsp;height,&nbsp;u_axis,&nbsp;v_axis&nbsp;=&nbsp;create_2d_label_map(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;regions,&nbsp;cell_size,&nbsp;origin<br>
&nbsp;&nbsp;&nbsp;&nbsp;)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;labels.size&nbsp;==&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;None<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Вычисляем&nbsp;offset&nbsp;и&nbsp;centroid<br>
&nbsp;&nbsp;&nbsp;&nbsp;all_voxels:&nbsp;list[tuple[int,&nbsp;int,&nbsp;int]]&nbsp;=&nbsp;[]<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;voxels,&nbsp;_&nbsp;in&nbsp;regions:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;all_voxels.extend(voxels)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;all_voxels:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;None<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;centers_3d&nbsp;=&nbsp;np.array([<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;origin&nbsp;+&nbsp;(np.array(v)&nbsp;+&nbsp;0.5)&nbsp;*&nbsp;cell_size<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;v&nbsp;in&nbsp;all_voxels<br>
&nbsp;&nbsp;&nbsp;&nbsp;],&nbsp;dtype=np.float32)<br>
&nbsp;&nbsp;&nbsp;&nbsp;centroid&nbsp;=&nbsp;centers_3d.mean(axis=0)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Находим&nbsp;offset<br>
&nbsp;&nbsp;&nbsp;&nbsp;all_2d:&nbsp;list[tuple[int,&nbsp;int]]&nbsp;=&nbsp;[]<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;voxel&nbsp;in&nbsp;all_voxels:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx,&nbsp;vy,&nbsp;vz&nbsp;=&nbsp;voxel<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;world_pos&nbsp;=&nbsp;origin&nbsp;+&nbsp;(np.array([vx,&nbsp;vy,&nbsp;vz])&nbsp;+&nbsp;0.5)&nbsp;*&nbsp;cell_size<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rel_pos&nbsp;=&nbsp;world_pos&nbsp;-&nbsp;centroid<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u&nbsp;=&nbsp;float(np.dot(rel_pos,&nbsp;u_axis))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v&nbsp;=&nbsp;float(np.dot(rel_pos,&nbsp;v_axis))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid_u&nbsp;=&nbsp;_round_half_up(u&nbsp;/&nbsp;cell_size)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid_v&nbsp;=&nbsp;_round_half_up(v&nbsp;/&nbsp;cell_size)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;all_2d.append((grid_u,&nbsp;grid_v))<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;min_u&nbsp;=&nbsp;min(p[0]&nbsp;for&nbsp;p&nbsp;in&nbsp;all_2d)<br>
&nbsp;&nbsp;&nbsp;&nbsp;min_v&nbsp;=&nbsp;min(p[1]&nbsp;for&nbsp;p&nbsp;in&nbsp;all_2d)<br>
&nbsp;&nbsp;&nbsp;&nbsp;offset_u&nbsp;=&nbsp;-min_u&nbsp;+&nbsp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;offset_v&nbsp;=&nbsp;-min_v&nbsp;+&nbsp;1<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;SharedLabelMap(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;labels=labels,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width=width,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;height=height,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offset_u=offset_u,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offset_v=offset_v,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u_axis=u_axis,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v_axis=v_axis,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;centroid=centroid,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cell_size=cell_size,<br>
&nbsp;&nbsp;&nbsp;&nbsp;)<br>
<br>
<br>
def&nbsp;extract_edge_contour_from_shared_map(<br>
&nbsp;&nbsp;&nbsp;&nbsp;shared_map:&nbsp;SharedLabelMap,<br>
&nbsp;&nbsp;&nbsp;&nbsp;region_id:&nbsp;int,<br>
)&nbsp;-&gt;&nbsp;tuple[np.ndarray,&nbsp;list[np.ndarray]]:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Извлечь&nbsp;edge-based&nbsp;контуры&nbsp;для&nbsp;региона&nbsp;из&nbsp;общей&nbsp;карты&nbsp;меток.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shared_map:&nbsp;Общая&nbsp;карта&nbsp;меток.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;region_id:&nbsp;ID&nbsp;региона&nbsp;(0-based&nbsp;index).<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(outer_2d,&nbsp;holes_2d):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outer_2d:&nbsp;np.ndarray&nbsp;shape&nbsp;(N,&nbsp;2)&nbsp;—&nbsp;внешний&nbsp;контур&nbsp;в&nbsp;2D<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;holes_2d:&nbsp;list[np.ndarray]&nbsp;—&nbsp;дырки&nbsp;в&nbsp;2D<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;region_id&nbsp;в&nbsp;labels&nbsp;1-based<br>
&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;extract_edge_contour_for_region(shared_map.labels,&nbsp;region_id&nbsp;+&nbsp;1)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;result.outer:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;np.array([]).reshape(0,&nbsp;2),&nbsp;[]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;corner_to_2d(corner:&nbsp;tuple[float,&nbsp;float])&nbsp;-&gt;&nbsp;tuple[float,&nbsp;float]:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Преобразовать&nbsp;координату&nbsp;угла&nbsp;в&nbsp;label&nbsp;map&nbsp;в&nbsp;2D&nbsp;координаты&nbsp;плоскости.&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mask_u,&nbsp;mask_v&nbsp;=&nbsp;corner<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid_u&nbsp;=&nbsp;mask_u&nbsp;-&nbsp;shared_map.offset_u<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid_v&nbsp;=&nbsp;mask_v&nbsp;-&nbsp;shared_map.offset_v<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u_2d&nbsp;=&nbsp;grid_u&nbsp;*&nbsp;shared_map.cell_size<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v_2d&nbsp;=&nbsp;grid_v&nbsp;*&nbsp;shared_map.cell_size<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(u_2d,&nbsp;v_2d)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Преобразуем&nbsp;внешний&nbsp;контур<br>
&nbsp;&nbsp;&nbsp;&nbsp;outer_2d_list&nbsp;=&nbsp;[corner_to_2d(corner)&nbsp;for&nbsp;corner&nbsp;in&nbsp;result.outer]<br>
&nbsp;&nbsp;&nbsp;&nbsp;outer_2d&nbsp;=&nbsp;np.array(outer_2d_list,&nbsp;dtype=np.float32)&nbsp;if&nbsp;outer_2d_list&nbsp;else&nbsp;np.array([]).reshape(0,&nbsp;2)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Преобразуем&nbsp;дырки<br>
&nbsp;&nbsp;&nbsp;&nbsp;holes_2d:&nbsp;list[np.ndarray]&nbsp;=&nbsp;[]<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;hole&nbsp;in&nbsp;result.holes:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hole_2d_list&nbsp;=&nbsp;[corner_to_2d(corner)&nbsp;for&nbsp;corner&nbsp;in&nbsp;hole]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;hole_2d_list:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;holes_2d.append(np.array(hole_2d_list,&nbsp;dtype=np.float32))<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;outer_2d,&nbsp;holes_2d<br>
<br>
<br>
def&nbsp;extract_edge_contour_single_region(<br>
&nbsp;&nbsp;&nbsp;&nbsp;region_voxels:&nbsp;list[tuple[int,&nbsp;int,&nbsp;int]],<br>
&nbsp;&nbsp;&nbsp;&nbsp;region_normal:&nbsp;np.ndarray,<br>
&nbsp;&nbsp;&nbsp;&nbsp;cell_size:&nbsp;float,<br>
&nbsp;&nbsp;&nbsp;&nbsp;origin:&nbsp;np.ndarray,<br>
)&nbsp;-&gt;&nbsp;tuple[np.ndarray,&nbsp;list[np.ndarray]]:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Извлечь&nbsp;edge-based&nbsp;контуры&nbsp;для&nbsp;одного&nbsp;региона.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Возвращает&nbsp;контуры&nbsp;в&nbsp;2D&nbsp;координатах&nbsp;(после&nbsp;проекции&nbsp;на&nbsp;плоскость).<br>
&nbsp;&nbsp;&nbsp;&nbsp;Вершины&nbsp;находятся&nbsp;на&nbsp;углах&nbsp;ячеек.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;region_voxels:&nbsp;Список&nbsp;вокселей&nbsp;региона&nbsp;(vx,&nbsp;vy,&nbsp;vz).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;region_normal:&nbsp;Нормаль&nbsp;региона.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cell_size:&nbsp;Размер&nbsp;вокселя.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;origin:&nbsp;Начало&nbsp;координат&nbsp;сетки.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(outer_2d,&nbsp;holes_2d):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outer_2d:&nbsp;np.ndarray&nbsp;shape&nbsp;(N,&nbsp;2)&nbsp;—&nbsp;внешний&nbsp;контур&nbsp;в&nbsp;2D<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;holes_2d:&nbsp;list[np.ndarray]&nbsp;—&nbsp;дырки&nbsp;в&nbsp;2D<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;len(region_voxels)&nbsp;&lt;&nbsp;1:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;np.array([]).reshape(0,&nbsp;2),&nbsp;[]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Создаём&nbsp;shared&nbsp;map&nbsp;для&nbsp;одного&nbsp;региона<br>
&nbsp;&nbsp;&nbsp;&nbsp;regions&nbsp;=&nbsp;[(region_voxels,&nbsp;region_normal)]<br>
&nbsp;&nbsp;&nbsp;&nbsp;shared_map&nbsp;=&nbsp;create_shared_label_map(regions,&nbsp;cell_size,&nbsp;origin)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;shared_map&nbsp;is&nbsp;None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;np.array([]).reshape(0,&nbsp;2),&nbsp;[]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;extract_edge_contour_from_shared_map(shared_map,&nbsp;region_id=0)<br>
<br>
<br>
def&nbsp;bresenham_line(x0:&nbsp;int,&nbsp;y0:&nbsp;int,&nbsp;x1:&nbsp;int,&nbsp;y1:&nbsp;int)&nbsp;-&gt;&nbsp;list[tuple[int,&nbsp;int]]:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Алгоритм&nbsp;Брезенхема&nbsp;для&nbsp;рисования&nbsp;линии&nbsp;между&nbsp;двумя&nbsp;точками.&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;cells:&nbsp;list[tuple[int,&nbsp;int]]&nbsp;=&nbsp;[]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;dx&nbsp;=&nbsp;abs(x1&nbsp;-&nbsp;x0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;dy&nbsp;=&nbsp;abs(y1&nbsp;-&nbsp;y0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;sx&nbsp;=&nbsp;1&nbsp;if&nbsp;x0&nbsp;&lt;&nbsp;x1&nbsp;else&nbsp;-1<br>
&nbsp;&nbsp;&nbsp;&nbsp;sy&nbsp;=&nbsp;1&nbsp;if&nbsp;y0&nbsp;&lt;&nbsp;y1&nbsp;else&nbsp;-1<br>
&nbsp;&nbsp;&nbsp;&nbsp;err&nbsp;=&nbsp;dx&nbsp;-&nbsp;dy<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;x,&nbsp;y&nbsp;=&nbsp;x0,&nbsp;y0<br>
&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;True:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cells.append((x,&nbsp;y))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;x&nbsp;==&nbsp;x1&nbsp;and&nbsp;y&nbsp;==&nbsp;y1:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e2&nbsp;=&nbsp;2&nbsp;*&nbsp;err<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;e2&nbsp;&gt;&nbsp;-dy:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err&nbsp;-=&nbsp;dy<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;+=&nbsp;sx<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;e2&nbsp;&lt;&nbsp;dx:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err&nbsp;+=&nbsp;dx<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;+=&nbsp;sy<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;cells<br>
<br>
<br>
def&nbsp;order_contour(<br>
&nbsp;&nbsp;&nbsp;&nbsp;cells:&nbsp;list[tuple[int,&nbsp;int]],<br>
&nbsp;&nbsp;&nbsp;&nbsp;directions:&nbsp;list[tuple[int,&nbsp;int]],<br>
)&nbsp;-&gt;&nbsp;list[tuple[int,&nbsp;int]]:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Упорядочить&nbsp;ячейки&nbsp;контура&nbsp;обходом&nbsp;по&nbsp;периметру.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cells:&nbsp;Неупорядоченный&nbsp;список&nbsp;ячеек&nbsp;контура.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;directions:&nbsp;Направления&nbsp;для&nbsp;8-связности.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Упорядоченный&nbsp;список&nbsp;ячеек&nbsp;(обход&nbsp;по&nbsp;часовой&nbsp;стрелке).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;len(cells)&nbsp;&lt;=&nbsp;2:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;cells<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;cell_set&nbsp;=&nbsp;set(cells)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Начинаем&nbsp;с&nbsp;самой&nbsp;верхней-левой&nbsp;ячейки<br>
&nbsp;&nbsp;&nbsp;&nbsp;start&nbsp;=&nbsp;min(cells,&nbsp;key=lambda&nbsp;c:&nbsp;(c[1],&nbsp;c[0]))<br>
&nbsp;&nbsp;&nbsp;&nbsp;ordered:&nbsp;list[tuple[int,&nbsp;int]]&nbsp;=&nbsp;[start]<br>
&nbsp;&nbsp;&nbsp;&nbsp;visited:&nbsp;set[tuple[int,&nbsp;int]]&nbsp;=&nbsp;{start}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;current&nbsp;=&nbsp;start<br>
&nbsp;&nbsp;&nbsp;&nbsp;last_dir&nbsp;=&nbsp;4&nbsp;&nbsp;#&nbsp;Пришли&nbsp;с&nbsp;запада<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;True:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;found&nbsp;=&nbsp;False<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;search_start&nbsp;=&nbsp;(last_dir&nbsp;+&nbsp;5)&nbsp;%&nbsp;8<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i&nbsp;in&nbsp;range(8):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dir_idx&nbsp;=&nbsp;(search_start&nbsp;+&nbsp;i)&nbsp;%&nbsp;8<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;du,&nbsp;dv&nbsp;=&nbsp;directions[dir_idx]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbor&nbsp;=&nbsp;(current[0]&nbsp;+&nbsp;du,&nbsp;current[1]&nbsp;+&nbsp;dv)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;neighbor&nbsp;in&nbsp;cell_set&nbsp;and&nbsp;neighbor&nbsp;not&nbsp;in&nbsp;visited:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ordered.append(neighbor)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;visited.add(neighbor)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current&nbsp;=&nbsp;neighbor<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;last_dir&nbsp;=&nbsp;dir_idx<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;found&nbsp;=&nbsp;True<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;found:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i&nbsp;in&nbsp;range(8):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dir_idx&nbsp;=&nbsp;(search_start&nbsp;+&nbsp;i)&nbsp;%&nbsp;8<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;du,&nbsp;dv&nbsp;=&nbsp;directions[dir_idx]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbor&nbsp;=&nbsp;(current[0]&nbsp;+&nbsp;du,&nbsp;current[1]&nbsp;+&nbsp;dv)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;neighbor&nbsp;==&nbsp;start:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;ordered<br>
<br>
<br>
def&nbsp;extract_contours_from_mask(<br>
&nbsp;&nbsp;&nbsp;&nbsp;mask:&nbsp;np.ndarray<br>
)&nbsp;-&gt;&nbsp;tuple[list[tuple[int,&nbsp;int]],&nbsp;list[list[tuple[int,&nbsp;int]]]]:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Извлечь&nbsp;внешний&nbsp;и&nbsp;внутренние&nbsp;контуры&nbsp;из&nbsp;бинарной&nbsp;маски.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Алгоритм:<br>
&nbsp;&nbsp;&nbsp;&nbsp;1.&nbsp;Flood&nbsp;fill&nbsp;от&nbsp;края&nbsp;—&nbsp;помечаем&nbsp;&quot;внешнюю&nbsp;пустоту&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;2.&nbsp;Граничные&nbsp;ячейки&nbsp;=&nbsp;заполненные&nbsp;с&nbsp;пустым&nbsp;соседом<br>
&nbsp;&nbsp;&nbsp;&nbsp;3.&nbsp;Outer&nbsp;=&nbsp;граничные,&nbsp;соседствующие&nbsp;с&nbsp;внешней&nbsp;пустотой<br>
&nbsp;&nbsp;&nbsp;&nbsp;4.&nbsp;Inner&nbsp;=&nbsp;граничные,&nbsp;соседствующие&nbsp;с&nbsp;внутренней&nbsp;пустотой<br>
&nbsp;&nbsp;&nbsp;&nbsp;5.&nbsp;Разделить&nbsp;inner&nbsp;на&nbsp;связные&nbsp;компоненты<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mask:&nbsp;2D&nbsp;массив&nbsp;(height,&nbsp;width),&nbsp;1&nbsp;=&nbsp;занято,&nbsp;0&nbsp;=&nbsp;пусто.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(outer_contour,&nbsp;holes)&nbsp;-&nbsp;внешний&nbsp;контур&nbsp;и&nbsp;список&nbsp;дырок.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;height,&nbsp;width&nbsp;=&nbsp;mask.shape<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;8-связность&nbsp;для&nbsp;обхода&nbsp;контура<br>
&nbsp;&nbsp;&nbsp;&nbsp;directions&nbsp;=&nbsp;[<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1,&nbsp;0),&nbsp;(1,&nbsp;1),&nbsp;(0,&nbsp;1),&nbsp;(-1,&nbsp;1),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-1,&nbsp;0),&nbsp;(-1,&nbsp;-1),&nbsp;(0,&nbsp;-1),&nbsp;(1,&nbsp;-1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;4-связность&nbsp;для&nbsp;flood&nbsp;fill&nbsp;(чтобы&nbsp;диагональные&nbsp;проходы&nbsp;не&nbsp;&quot;заливали&quot;&nbsp;дырки)<br>
&nbsp;&nbsp;&nbsp;&nbsp;cardinal_directions_ff&nbsp;=&nbsp;[(1,&nbsp;0),&nbsp;(0,&nbsp;1),&nbsp;(-1,&nbsp;0),&nbsp;(0,&nbsp;-1)]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Шаг&nbsp;1:&nbsp;Flood&nbsp;fill&nbsp;от&nbsp;края&nbsp;—&nbsp;помечаем&nbsp;внешнюю&nbsp;пустоту<br>
&nbsp;&nbsp;&nbsp;&nbsp;external&nbsp;=&nbsp;np.zeros_like(mask,&nbsp;dtype=np.uint8)<br>
&nbsp;&nbsp;&nbsp;&nbsp;queue&nbsp;=&nbsp;deque()<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Добавляем&nbsp;все&nbsp;пустые&nbsp;ячейки&nbsp;на&nbsp;краях<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;u&nbsp;in&nbsp;range(width):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;mask[0,&nbsp;u]&nbsp;==&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queue.append((u,&nbsp;0))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;external[0,&nbsp;u]&nbsp;=&nbsp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;mask[height&nbsp;-&nbsp;1,&nbsp;u]&nbsp;==&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queue.append((u,&nbsp;height&nbsp;-&nbsp;1))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;external[height&nbsp;-&nbsp;1,&nbsp;u]&nbsp;=&nbsp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;v&nbsp;in&nbsp;range(height):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;mask[v,&nbsp;0]&nbsp;==&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queue.append((0,&nbsp;v))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;external[v,&nbsp;0]&nbsp;=&nbsp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;mask[v,&nbsp;width&nbsp;-&nbsp;1]&nbsp;==&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queue.append((width&nbsp;-&nbsp;1,&nbsp;v))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;external[v,&nbsp;width&nbsp;-&nbsp;1]&nbsp;=&nbsp;1<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Flood&nbsp;fill&nbsp;с&nbsp;4-связностью<br>
&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;queue:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u,&nbsp;v&nbsp;=&nbsp;queue.popleft()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;du,&nbsp;dv&nbsp;in&nbsp;cardinal_directions_ff:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nu,&nbsp;nv&nbsp;=&nbsp;u&nbsp;+&nbsp;du,&nbsp;v&nbsp;+&nbsp;dv<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;0&nbsp;&lt;=&nbsp;nu&nbsp;&lt;&nbsp;width&nbsp;and&nbsp;0&nbsp;&lt;=&nbsp;nv&nbsp;&lt;&nbsp;height:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;mask[nv,&nbsp;nu]&nbsp;==&nbsp;0&nbsp;and&nbsp;external[nv,&nbsp;nu]&nbsp;==&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;external[nv,&nbsp;nu]&nbsp;=&nbsp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queue.append((nu,&nbsp;nv))<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Шаг&nbsp;2-4:&nbsp;Классифицируем&nbsp;граничные&nbsp;ячейки<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Используем&nbsp;4-связность&nbsp;для&nbsp;определения&nbsp;границы&nbsp;(только&nbsp;кардинальные&nbsp;направления)<br>
&nbsp;&nbsp;&nbsp;&nbsp;cardinal_directions&nbsp;=&nbsp;[(1,&nbsp;0),&nbsp;(0,&nbsp;1),&nbsp;(-1,&nbsp;0),&nbsp;(0,&nbsp;-1)]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;outer_cells:&nbsp;list[tuple[int,&nbsp;int]]&nbsp;=&nbsp;[]<br>
&nbsp;&nbsp;&nbsp;&nbsp;inner_cells:&nbsp;list[tuple[int,&nbsp;int]]&nbsp;=&nbsp;[]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;v&nbsp;in&nbsp;range(height):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;u&nbsp;in&nbsp;range(width):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;mask[v,&nbsp;u]&nbsp;==&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;has_external_neighbor&nbsp;=&nbsp;False<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;has_internal_neighbor&nbsp;=&nbsp;False<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;du,&nbsp;dv&nbsp;in&nbsp;cardinal_directions:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nu,&nbsp;nv&nbsp;=&nbsp;u&nbsp;+&nbsp;du,&nbsp;v&nbsp;+&nbsp;dv<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;nu&nbsp;&lt;&nbsp;0&nbsp;or&nbsp;nu&nbsp;&gt;=&nbsp;width&nbsp;or&nbsp;nv&nbsp;&lt;&nbsp;0&nbsp;or&nbsp;nv&nbsp;&gt;=&nbsp;height:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;has_external_neighbor&nbsp;=&nbsp;True<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif&nbsp;mask[nv,&nbsp;nu]&nbsp;==&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;external[nv,&nbsp;nu]&nbsp;==&nbsp;1:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;has_external_neighbor&nbsp;=&nbsp;True<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;has_internal_neighbor&nbsp;=&nbsp;True<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;has_external_neighbor:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outer_cells.append((u,&nbsp;v))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif&nbsp;has_internal_neighbor:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inner_cells.append((u,&nbsp;v))<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Шаг&nbsp;5:&nbsp;Разделить&nbsp;inner&nbsp;на&nbsp;связные&nbsp;компоненты<br>
&nbsp;&nbsp;&nbsp;&nbsp;holes:&nbsp;list[list[tuple[int,&nbsp;int]]]&nbsp;=&nbsp;[]<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;inner_cells:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inner_set&nbsp;=&nbsp;set(inner_cells)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;visited:&nbsp;set[tuple[int,&nbsp;int]]&nbsp;=&nbsp;set()<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;start&nbsp;in&nbsp;inner_cells:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;start&nbsp;in&nbsp;visited:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;BFS&nbsp;для&nbsp;связной&nbsp;компоненты<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;component:&nbsp;list[tuple[int,&nbsp;int]]&nbsp;=&nbsp;[]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q&nbsp;=&nbsp;deque([start])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;visited.add(start)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;q:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u,&nbsp;v&nbsp;=&nbsp;q.popleft()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;component.append((u,&nbsp;v))<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;du,&nbsp;dv&nbsp;in&nbsp;directions:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbor&nbsp;=&nbsp;(u&nbsp;+&nbsp;du,&nbsp;v&nbsp;+&nbsp;dv)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;neighbor&nbsp;in&nbsp;inner_set&nbsp;and&nbsp;neighbor&nbsp;not&nbsp;in&nbsp;visited:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;visited.add(neighbor)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q.append(neighbor)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;component:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;holes.append(component)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Шаг&nbsp;6:&nbsp;Упорядочить&nbsp;контуры<br>
&nbsp;&nbsp;&nbsp;&nbsp;outer_ordered&nbsp;=&nbsp;order_contour(outer_cells,&nbsp;directions)<br>
&nbsp;&nbsp;&nbsp;&nbsp;holes_ordered&nbsp;=&nbsp;[order_contour(h,&nbsp;directions)&nbsp;for&nbsp;h&nbsp;in&nbsp;holes]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;outer_ordered,&nbsp;holes_ordered<br>
<br>
<br>
def&nbsp;extract_contours_from_region(<br>
&nbsp;&nbsp;&nbsp;&nbsp;region_voxels:&nbsp;list[tuple[int,&nbsp;int,&nbsp;int]],<br>
&nbsp;&nbsp;&nbsp;&nbsp;region_normal:&nbsp;np.ndarray,<br>
&nbsp;&nbsp;&nbsp;&nbsp;cell_size:&nbsp;float,<br>
&nbsp;&nbsp;&nbsp;&nbsp;origin:&nbsp;np.ndarray,<br>
)&nbsp;-&gt;&nbsp;tuple[list[tuple[int,&nbsp;int,&nbsp;int]],&nbsp;list[list[tuple[int,&nbsp;int,&nbsp;int]]]]:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Извлечь&nbsp;внешний&nbsp;и&nbsp;внутренние&nbsp;контуры&nbsp;из&nbsp;региона.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;region_voxels:&nbsp;Список&nbsp;вокселей&nbsp;региона&nbsp;(vx,&nbsp;vy,&nbsp;vz).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;region_normal:&nbsp;Нормаль&nbsp;региона.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cell_size:&nbsp;Размер&nbsp;вокселя.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;origin:&nbsp;Начало&nbsp;координат&nbsp;сетки.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(outer_contour,&nbsp;holes)&nbsp;-&nbsp;внешний&nbsp;контур&nbsp;и&nbsp;список&nbsp;дырок.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;len(region_voxels)&nbsp;&lt;&nbsp;3:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;list(region_voxels),&nbsp;[]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Строим&nbsp;локальную&nbsp;2D&nbsp;систему&nbsp;координат<br>
&nbsp;&nbsp;&nbsp;&nbsp;u_axis,&nbsp;v_axis&nbsp;=&nbsp;build_2d_basis(region_normal)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Центроид&nbsp;региона<br>
&nbsp;&nbsp;&nbsp;&nbsp;centers_3d&nbsp;=&nbsp;np.array([<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;origin&nbsp;+&nbsp;(np.array(v)&nbsp;+&nbsp;0.5)&nbsp;*&nbsp;cell_size<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;v&nbsp;in&nbsp;region_voxels<br>
&nbsp;&nbsp;&nbsp;&nbsp;],&nbsp;dtype=np.float32)<br>
&nbsp;&nbsp;&nbsp;&nbsp;centroid&nbsp;=&nbsp;centers_3d.mean(axis=0)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Проецируем&nbsp;воксели&nbsp;на&nbsp;2D<br>
&nbsp;&nbsp;&nbsp;&nbsp;voxel_to_2d_float:&nbsp;dict[tuple[int,&nbsp;int,&nbsp;int],&nbsp;tuple[float,&nbsp;float]]&nbsp;=&nbsp;{}<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;voxel&nbsp;in&nbsp;region_voxels:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx,&nbsp;vy,&nbsp;vz&nbsp;=&nbsp;voxel<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;world_pos&nbsp;=&nbsp;origin&nbsp;+&nbsp;(np.array([vx,&nbsp;vy,&nbsp;vz])&nbsp;+&nbsp;0.5)&nbsp;*&nbsp;cell_size<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rel_pos&nbsp;=&nbsp;world_pos&nbsp;-&nbsp;centroid<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u&nbsp;=&nbsp;float(np.dot(rel_pos,&nbsp;u_axis))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v&nbsp;=&nbsp;float(np.dot(rel_pos,&nbsp;v_axis))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;voxel_to_2d_float[voxel]&nbsp;=&nbsp;(u,&nbsp;v)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Квантизируем&nbsp;и&nbsp;строим&nbsp;маппинг<br>
&nbsp;&nbsp;&nbsp;&nbsp;voxel_to_2d:&nbsp;dict[tuple[int,&nbsp;int,&nbsp;int],&nbsp;tuple[int,&nbsp;int]]&nbsp;=&nbsp;{}<br>
&nbsp;&nbsp;&nbsp;&nbsp;grid_2d_to_voxels:&nbsp;dict[tuple[int,&nbsp;int],&nbsp;list[tuple[int,&nbsp;int,&nbsp;int]]]&nbsp;=&nbsp;{}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;voxel,&nbsp;(u,&nbsp;v)&nbsp;in&nbsp;voxel_to_2d_float.items():<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid_u&nbsp;=&nbsp;_round_half_up(u&nbsp;/&nbsp;cell_size)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid_v&nbsp;=&nbsp;_round_half_up(v&nbsp;/&nbsp;cell_size)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;voxel_to_2d[voxel]&nbsp;=&nbsp;(grid_u,&nbsp;grid_v)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(grid_u,&nbsp;grid_v)&nbsp;not&nbsp;in&nbsp;grid_2d_to_voxels:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid_2d_to_voxels[(grid_u,&nbsp;grid_v)]&nbsp;=&nbsp;[]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid_2d_to_voxels[(grid_u,&nbsp;grid_v)].append(voxel)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Находим&nbsp;соседей&nbsp;в&nbsp;3D&nbsp;и&nbsp;рисуем&nbsp;линии&nbsp;Брезенхема&nbsp;в&nbsp;2D<br>
&nbsp;&nbsp;&nbsp;&nbsp;region_set&nbsp;=&nbsp;set(region_voxels)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;voxel&nbsp;in&nbsp;region_voxels:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx,&nbsp;vy,&nbsp;vz&nbsp;=&nbsp;voxel<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;dx&nbsp;in&nbsp;(-1,&nbsp;0,&nbsp;1):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;dy&nbsp;in&nbsp;(-1,&nbsp;0,&nbsp;1):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;dz&nbsp;in&nbsp;(-1,&nbsp;0,&nbsp;1):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;dx&nbsp;==&nbsp;0&nbsp;and&nbsp;dy&nbsp;==&nbsp;0&nbsp;and&nbsp;dz&nbsp;==&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbor&nbsp;=&nbsp;(vx&nbsp;+&nbsp;dx,&nbsp;vy&nbsp;+&nbsp;dy,&nbsp;vz&nbsp;+&nbsp;dz)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;neighbor&nbsp;in&nbsp;region_set&nbsp;and&nbsp;neighbor&nbsp;&gt;&nbsp;voxel:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u1,&nbsp;v1&nbsp;=&nbsp;voxel_to_2d[voxel]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u2,&nbsp;v2&nbsp;=&nbsp;voxel_to_2d[neighbor]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line_cells&nbsp;=&nbsp;bresenham_line(u1,&nbsp;v1,&nbsp;u2,&nbsp;v2)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;cell&nbsp;in&nbsp;line_cells:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;cell&nbsp;not&nbsp;in&nbsp;grid_2d_to_voxels:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid_2d_to_voxels[cell]&nbsp;=&nbsp;[voxel]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Создаём&nbsp;бинарную&nbsp;маску<br>
&nbsp;&nbsp;&nbsp;&nbsp;all_2d&nbsp;=&nbsp;list(grid_2d_to_voxels.keys())<br>
&nbsp;&nbsp;&nbsp;&nbsp;min_u&nbsp;=&nbsp;min(p[0]&nbsp;for&nbsp;p&nbsp;in&nbsp;all_2d)<br>
&nbsp;&nbsp;&nbsp;&nbsp;max_u&nbsp;=&nbsp;max(p[0]&nbsp;for&nbsp;p&nbsp;in&nbsp;all_2d)<br>
&nbsp;&nbsp;&nbsp;&nbsp;min_v&nbsp;=&nbsp;min(p[1]&nbsp;for&nbsp;p&nbsp;in&nbsp;all_2d)<br>
&nbsp;&nbsp;&nbsp;&nbsp;max_v&nbsp;=&nbsp;max(p[1]&nbsp;for&nbsp;p&nbsp;in&nbsp;all_2d)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;width&nbsp;=&nbsp;max_u&nbsp;-&nbsp;min_u&nbsp;+&nbsp;3<br>
&nbsp;&nbsp;&nbsp;&nbsp;height&nbsp;=&nbsp;max_v&nbsp;-&nbsp;min_v&nbsp;+&nbsp;3<br>
&nbsp;&nbsp;&nbsp;&nbsp;offset_u&nbsp;=&nbsp;-min_u&nbsp;+&nbsp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;offset_v&nbsp;=&nbsp;-min_v&nbsp;+&nbsp;1<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;mask&nbsp;=&nbsp;np.zeros((height,&nbsp;width),&nbsp;dtype=np.uint8)<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(gu,&nbsp;gv)&nbsp;in&nbsp;all_2d:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mask[gv&nbsp;+&nbsp;offset_v,&nbsp;gu&nbsp;+&nbsp;offset_u]&nbsp;=&nbsp;1<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Извлекаем&nbsp;контуры&nbsp;из&nbsp;маски<br>
&nbsp;&nbsp;&nbsp;&nbsp;outer_2d,&nbsp;holes_2d&nbsp;=&nbsp;extract_contours_from_mask(mask)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Конвертируем&nbsp;2D&nbsp;контуры&nbsp;обратно&nbsp;в&nbsp;воксели<br>
&nbsp;&nbsp;&nbsp;&nbsp;outer_contour:&nbsp;list[tuple[int,&nbsp;int,&nbsp;int]]&nbsp;=&nbsp;[]<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(cu,&nbsp;cv)&nbsp;in&nbsp;outer_2d:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid_u&nbsp;=&nbsp;cu&nbsp;-&nbsp;offset_u<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid_v&nbsp;=&nbsp;cv&nbsp;-&nbsp;offset_v<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(grid_u,&nbsp;grid_v)&nbsp;in&nbsp;grid_2d_to_voxels:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outer_contour.append(grid_2d_to_voxels[(grid_u,&nbsp;grid_v)][0])<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;holes:&nbsp;list[list[tuple[int,&nbsp;int,&nbsp;int]]]&nbsp;=&nbsp;[]<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;hole_2d&nbsp;in&nbsp;holes_2d:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hole_voxels:&nbsp;list[tuple[int,&nbsp;int,&nbsp;int]]&nbsp;=&nbsp;[]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(cu,&nbsp;cv)&nbsp;in&nbsp;hole_2d:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid_u&nbsp;=&nbsp;cu&nbsp;-&nbsp;offset_u<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid_v&nbsp;=&nbsp;cv&nbsp;-&nbsp;offset_v<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(grid_u,&nbsp;grid_v)&nbsp;in&nbsp;grid_2d_to_voxels:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hole_voxels.append(grid_2d_to_voxels[(grid_u,&nbsp;grid_v)][0])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;hole_voxels:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;holes.append(hole_voxels)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;outer_contour,&nbsp;holes<br>
<!-- END SCAT CODE -->
</body>
</html>
