<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>termin/navmesh/triangulation.py</title>
</head>
<body>
<!-- BEGIN SCAT CODE -->
&quot;&quot;&quot;<br>
Триангуляция&nbsp;полигонов&nbsp;для&nbsp;NavMesh.<br>
<br>
Включает&nbsp;Ear&nbsp;Clipping,&nbsp;Douglas-Peucker&nbsp;и&nbsp;объединение&nbsp;дырок&nbsp;через&nbsp;bridge.<br>
&quot;&quot;&quot;<br>
<br>
from&nbsp;__future__&nbsp;import&nbsp;annotations<br>
<br>
import&nbsp;numpy&nbsp;as&nbsp;np<br>
<br>
<br>
def&nbsp;signed_area_2d(polygon:&nbsp;np.ndarray)&nbsp;-&gt;&nbsp;float:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Вычислить&nbsp;знаковую&nbsp;площадь&nbsp;полигона&nbsp;(положительная&nbsp;для&nbsp;CCW).&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;=&nbsp;len(polygon)<br>
&nbsp;&nbsp;&nbsp;&nbsp;area&nbsp;=&nbsp;0.0<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i&nbsp;in&nbsp;range(n):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;=&nbsp;(i&nbsp;+&nbsp;1)&nbsp;%&nbsp;n<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;area&nbsp;+=&nbsp;polygon[i][0]&nbsp;*&nbsp;polygon[j][1]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;area&nbsp;-=&nbsp;polygon[j][0]&nbsp;*&nbsp;polygon[i][1]<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;area&nbsp;/&nbsp;2.0<br>
<br>
<br>
def&nbsp;is_convex_2d(<br>
&nbsp;&nbsp;&nbsp;&nbsp;prev_p:&nbsp;np.ndarray,<br>
&nbsp;&nbsp;&nbsp;&nbsp;curr_p:&nbsp;np.ndarray,<br>
&nbsp;&nbsp;&nbsp;&nbsp;next_p:&nbsp;np.ndarray,<br>
&nbsp;&nbsp;&nbsp;&nbsp;ccw:&nbsp;bool,<br>
&nbsp;&nbsp;&nbsp;&nbsp;epsilon:&nbsp;float&nbsp;=&nbsp;1e-10,<br>
)&nbsp;-&gt;&nbsp;bool:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Проверить,&nbsp;является&nbsp;ли&nbsp;вершина&nbsp;выпуклой.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Почти&nbsp;коллинеарные&nbsp;вершины&nbsp;(cross&nbsp;≈&nbsp;0)&nbsp;считаются&nbsp;выпуклыми,<br>
&nbsp;&nbsp;&nbsp;&nbsp;чтобы&nbsp;ear&nbsp;clipping&nbsp;работал&nbsp;на&nbsp;узких&nbsp;полигонах.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;cross&nbsp;=&nbsp;(curr_p[0]&nbsp;-&nbsp;prev_p[0])&nbsp;*&nbsp;(next_p[1]&nbsp;-&nbsp;curr_p[1])&nbsp;-&nbsp;\<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(curr_p[1]&nbsp;-&nbsp;prev_p[1])&nbsp;*&nbsp;(next_p[0]&nbsp;-&nbsp;curr_p[0])<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;ccw:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;cross&nbsp;&gt;&nbsp;-epsilon&nbsp;&nbsp;#&nbsp;&gt;=&nbsp;0&nbsp;с&nbsp;погрешностью<br>
&nbsp;&nbsp;&nbsp;&nbsp;else:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;cross&nbsp;&lt;&nbsp;epsilon&nbsp;&nbsp;&nbsp;#&nbsp;&lt;=&nbsp;0&nbsp;с&nbsp;погрешностью<br>
<br>
<br>
def&nbsp;point_in_triangle_2d(<br>
&nbsp;&nbsp;&nbsp;&nbsp;p:&nbsp;np.ndarray,<br>
&nbsp;&nbsp;&nbsp;&nbsp;a:&nbsp;np.ndarray,<br>
&nbsp;&nbsp;&nbsp;&nbsp;b:&nbsp;np.ndarray,<br>
&nbsp;&nbsp;&nbsp;&nbsp;c:&nbsp;np.ndarray,<br>
)&nbsp;-&gt;&nbsp;bool:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Проверить,&nbsp;находится&nbsp;ли&nbsp;точка&nbsp;внутри&nbsp;треугольника&nbsp;(строго).&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;sign(p1,&nbsp;p2,&nbsp;p3):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(p1[0]&nbsp;-&nbsp;p3[0])&nbsp;*&nbsp;(p2[1]&nbsp;-&nbsp;p3[1])&nbsp;-&nbsp;(p2[0]&nbsp;-&nbsp;p3[0])&nbsp;*&nbsp;(p1[1]&nbsp;-&nbsp;p3[1])<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;d1&nbsp;=&nbsp;sign(p,&nbsp;a,&nbsp;b)<br>
&nbsp;&nbsp;&nbsp;&nbsp;d2&nbsp;=&nbsp;sign(p,&nbsp;b,&nbsp;c)<br>
&nbsp;&nbsp;&nbsp;&nbsp;d3&nbsp;=&nbsp;sign(p,&nbsp;c,&nbsp;a)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;has_neg&nbsp;=&nbsp;(d1&nbsp;&lt;&nbsp;0)&nbsp;or&nbsp;(d2&nbsp;&lt;&nbsp;0)&nbsp;or&nbsp;(d3&nbsp;&lt;&nbsp;0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;has_pos&nbsp;=&nbsp;(d1&nbsp;&gt;&nbsp;0)&nbsp;or&nbsp;(d2&nbsp;&gt;&nbsp;0)&nbsp;or&nbsp;(d3&nbsp;&gt;&nbsp;0)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;not&nbsp;(has_neg&nbsp;and&nbsp;has_pos)<br>
<br>
<br>
def&nbsp;segments_intersect_strict(<br>
&nbsp;&nbsp;&nbsp;&nbsp;a1:&nbsp;np.ndarray,<br>
&nbsp;&nbsp;&nbsp;&nbsp;a2:&nbsp;np.ndarray,<br>
&nbsp;&nbsp;&nbsp;&nbsp;b1:&nbsp;np.ndarray,<br>
&nbsp;&nbsp;&nbsp;&nbsp;b2:&nbsp;np.ndarray,<br>
)&nbsp;-&gt;&nbsp;bool:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Проверить&nbsp;строгое&nbsp;пересечение&nbsp;двух&nbsp;отрезков&nbsp;(без&nbsp;касания&nbsp;в&nbsp;точках).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;cross(o,&nbsp;a,&nbsp;b):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(a[0]&nbsp;-&nbsp;o[0])&nbsp;*&nbsp;(b[1]&nbsp;-&nbsp;o[1])&nbsp;-&nbsp;(a[1]&nbsp;-&nbsp;o[1])&nbsp;*&nbsp;(b[0]&nbsp;-&nbsp;o[0])<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;d1&nbsp;=&nbsp;cross(b1,&nbsp;b2,&nbsp;a1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;d2&nbsp;=&nbsp;cross(b1,&nbsp;b2,&nbsp;a2)<br>
&nbsp;&nbsp;&nbsp;&nbsp;d3&nbsp;=&nbsp;cross(a1,&nbsp;a2,&nbsp;b1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;d4&nbsp;=&nbsp;cross(a1,&nbsp;a2,&nbsp;b2)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;((d1&nbsp;&gt;&nbsp;0&nbsp;and&nbsp;d2&nbsp;&lt;&nbsp;0)&nbsp;or&nbsp;(d1&nbsp;&lt;&nbsp;0&nbsp;and&nbsp;d2&nbsp;&gt;&nbsp;0))&nbsp;and&nbsp;\<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((d3&nbsp;&gt;&nbsp;0&nbsp;and&nbsp;d4&nbsp;&lt;&nbsp;0)&nbsp;or&nbsp;(d3&nbsp;&lt;&nbsp;0&nbsp;and&nbsp;d4&nbsp;&gt;&nbsp;0)):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;True<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;False<br>
<br>
<br>
def&nbsp;ear_clip(polygon:&nbsp;np.ndarray)&nbsp;-&gt;&nbsp;list[tuple[int,&nbsp;int,&nbsp;int]]:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Триангулировать&nbsp;простой&nbsp;полигон&nbsp;методом&nbsp;Ear&nbsp;Clipping.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;polygon:&nbsp;np.ndarray&nbsp;shape&nbsp;(N,&nbsp;2)&nbsp;—&nbsp;вершины&nbsp;полигона.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Список&nbsp;треугольников&nbsp;[(i,&nbsp;j,&nbsp;k),&nbsp;...].<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;=&nbsp;len(polygon)<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;n&nbsp;&lt;&nbsp;3:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;[]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;n&nbsp;==&nbsp;3:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;[(0,&nbsp;1,&nbsp;2)]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Определяем&nbsp;ориентацию&nbsp;полигона&nbsp;(CCW&nbsp;=&nbsp;положительная&nbsp;площадь)<br>
&nbsp;&nbsp;&nbsp;&nbsp;area&nbsp;=&nbsp;signed_area_2d(polygon)<br>
&nbsp;&nbsp;&nbsp;&nbsp;ccw&nbsp;=&nbsp;area&nbsp;&gt;&nbsp;0<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Создаём&nbsp;связный&nbsp;список&nbsp;индексов<br>
&nbsp;&nbsp;&nbsp;&nbsp;indices&nbsp;=&nbsp;list(range(n))<br>
&nbsp;&nbsp;&nbsp;&nbsp;triangles&nbsp;=&nbsp;[]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Пытаемся&nbsp;найти&nbsp;и&nbsp;отрезать&nbsp;уши<br>
&nbsp;&nbsp;&nbsp;&nbsp;max_iterations&nbsp;=&nbsp;n&nbsp;*&nbsp;n<br>
&nbsp;&nbsp;&nbsp;&nbsp;iteration&nbsp;=&nbsp;0<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;convex_count&nbsp;=&nbsp;0<br>
&nbsp;&nbsp;&nbsp;&nbsp;reflex_count&nbsp;=&nbsp;0<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;len(indices)&nbsp;&gt;&nbsp;3&nbsp;and&nbsp;iteration&nbsp;&lt;&nbsp;max_iterations:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iteration&nbsp;+=&nbsp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;found_ear&nbsp;=&nbsp;False<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;convex_count&nbsp;=&nbsp;0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reflex_count&nbsp;=&nbsp;0<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i&nbsp;in&nbsp;range(len(indices)):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prev_i&nbsp;=&nbsp;(i&nbsp;-&nbsp;1)&nbsp;%&nbsp;len(indices)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;next_i&nbsp;=&nbsp;(i&nbsp;+&nbsp;1)&nbsp;%&nbsp;len(indices)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prev_idx&nbsp;=&nbsp;indices[prev_i]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;curr_idx&nbsp;=&nbsp;indices[i]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;next_idx&nbsp;=&nbsp;indices[next_i]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prev_p&nbsp;=&nbsp;polygon[prev_idx]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;curr_p&nbsp;=&nbsp;polygon[curr_idx]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;next_p&nbsp;=&nbsp;polygon[next_idx]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Проверяем&nbsp;выпуклость&nbsp;вершины<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;is_convex_2d(prev_p,&nbsp;curr_p,&nbsp;next_p,&nbsp;ccw):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reflex_count&nbsp;+=&nbsp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;convex_count&nbsp;+=&nbsp;1<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Проверяем,&nbsp;что&nbsp;треугольник&nbsp;не&nbsp;содержит&nbsp;других&nbsp;вершин<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is_ear&nbsp;=&nbsp;True<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;j&nbsp;in&nbsp;range(len(indices)):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;j&nbsp;==&nbsp;prev_i&nbsp;or&nbsp;j&nbsp;==&nbsp;i&nbsp;or&nbsp;j&nbsp;==&nbsp;next_i:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test_idx&nbsp;=&nbsp;indices[j]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test_p&nbsp;=&nbsp;polygon[test_idx]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Пропускаем&nbsp;вершины,&nbsp;совпадающие&nbsp;с&nbsp;вершинами&nbsp;треугольника<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eps&nbsp;=&nbsp;1e-10<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(abs(test_p[0]&nbsp;-&nbsp;prev_p[0])&nbsp;&lt;&nbsp;eps&nbsp;and&nbsp;abs(test_p[1]&nbsp;-&nbsp;prev_p[1])&nbsp;&lt;&nbsp;eps):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(abs(test_p[0]&nbsp;-&nbsp;curr_p[0])&nbsp;&lt;&nbsp;eps&nbsp;and&nbsp;abs(test_p[1]&nbsp;-&nbsp;curr_p[1])&nbsp;&lt;&nbsp;eps):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(abs(test_p[0]&nbsp;-&nbsp;next_p[0])&nbsp;&lt;&nbsp;eps&nbsp;and&nbsp;abs(test_p[1]&nbsp;-&nbsp;next_p[1])&nbsp;&lt;&nbsp;eps):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;point_in_triangle_2d(test_p,&nbsp;prev_p,&nbsp;curr_p,&nbsp;next_p):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is_ear&nbsp;=&nbsp;False<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;is_ear:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;triangles.append((prev_idx,&nbsp;curr_idx,&nbsp;next_idx))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;indices.pop(i)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;found_ear&nbsp;=&nbsp;True<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;found_ear:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(f&quot;[ear_clip]&nbsp;no&nbsp;ear&nbsp;found!&nbsp;remaining={len(indices)},&nbsp;convex={convex_count},&nbsp;reflex={reflex_count},&nbsp;triangles={len(triangles)}&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Добавляем&nbsp;последний&nbsp;треугольник<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;len(indices)&nbsp;==&nbsp;3:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;triangles.append((indices[0],&nbsp;indices[1],&nbsp;indices[2]))<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;triangles<br>
<br>
<br>
def&nbsp;ear_clipping(vertices:&nbsp;np.ndarray,&nbsp;optimize:&nbsp;bool&nbsp;=&nbsp;True)&nbsp;-&gt;&nbsp;np.ndarray:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Триангулировать&nbsp;простой&nbsp;полигон&nbsp;методом&nbsp;Ear&nbsp;Clipping.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Обёртка&nbsp;над&nbsp;ear_clip(),&nbsp;возвращающая&nbsp;np.ndarray.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Опционально&nbsp;применяет&nbsp;Delaunay&nbsp;edge&nbsp;flipping&nbsp;для&nbsp;улучшения&nbsp;качества.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertices:&nbsp;2D&nbsp;координаты&nbsp;вершин&nbsp;полигона&nbsp;(CCW),&nbsp;shape&nbsp;(N,&nbsp;2).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;optimize:&nbsp;Применить&nbsp;edge&nbsp;flipping&nbsp;для&nbsp;улучшения&nbsp;качества.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Треугольники&nbsp;(индексы&nbsp;вершин),&nbsp;shape&nbsp;(N-2,&nbsp;3).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;triangles&nbsp;=&nbsp;ear_clip(vertices)<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;triangles:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;np.array([],&nbsp;dtype=np.int32).reshape(0,&nbsp;3)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;optimize&nbsp;and&nbsp;len(triangles)&nbsp;&gt;=&nbsp;2:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Граничные&nbsp;рёбра&nbsp;полигона&nbsp;—&nbsp;не&nbsp;переворачивать<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boundary&nbsp;=&nbsp;extract_boundary_edges(len(vertices))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;triangles&nbsp;=&nbsp;delaunay_flip(vertices,&nbsp;triangles,&nbsp;boundary)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;np.array(triangles,&nbsp;dtype=np.int32)<br>
<br>
<br>
def&nbsp;douglas_peucker_2d(<br>
&nbsp;&nbsp;&nbsp;&nbsp;points:&nbsp;np.ndarray,<br>
&nbsp;&nbsp;&nbsp;&nbsp;epsilon:&nbsp;float,<br>
)&nbsp;-&gt;&nbsp;np.ndarray:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Упростить&nbsp;2D&nbsp;полилинию&nbsp;алгоритмом&nbsp;Douglas-Peucker.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;points:&nbsp;np.ndarray&nbsp;shape&nbsp;(N,&nbsp;2)&nbsp;—&nbsp;вершины&nbsp;полилинии.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;epsilon:&nbsp;Максимальное&nbsp;отклонение.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Упрощённая&nbsp;полилиния&nbsp;shape&nbsp;(M,&nbsp;2).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;len(points)&nbsp;&lt;=&nbsp;2:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;points<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;=&nbsp;len(points)<br>
&nbsp;&nbsp;&nbsp;&nbsp;start&nbsp;=&nbsp;points[0]<br>
&nbsp;&nbsp;&nbsp;&nbsp;end&nbsp;=&nbsp;points[-1]<br>
&nbsp;&nbsp;&nbsp;&nbsp;line_vec&nbsp;=&nbsp;end&nbsp;-&nbsp;start<br>
&nbsp;&nbsp;&nbsp;&nbsp;line_len&nbsp;=&nbsp;np.linalg.norm(line_vec)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;line_len&nbsp;&lt;&nbsp;1e-10:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;points[[0]]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;line_dir&nbsp;=&nbsp;line_vec&nbsp;/&nbsp;line_len<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;max_dist&nbsp;=&nbsp;0.0<br>
&nbsp;&nbsp;&nbsp;&nbsp;max_idx&nbsp;=&nbsp;0<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i&nbsp;in&nbsp;range(1,&nbsp;n&nbsp;-&nbsp;1):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to_point&nbsp;=&nbsp;points[i]&nbsp;-&nbsp;start<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proj_len&nbsp;=&nbsp;np.dot(to_point,&nbsp;line_dir)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proj_point&nbsp;=&nbsp;start&nbsp;+&nbsp;proj_len&nbsp;*&nbsp;line_dir<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dist&nbsp;=&nbsp;np.linalg.norm(points[i]&nbsp;-&nbsp;proj_point)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;dist&nbsp;&gt;&nbsp;max_dist:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max_dist&nbsp;=&nbsp;dist<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max_idx&nbsp;=&nbsp;i<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;max_dist&nbsp;&gt;&nbsp;epsilon:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;left&nbsp;=&nbsp;douglas_peucker_2d(points[:max_idx&nbsp;+&nbsp;1],&nbsp;epsilon)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;right&nbsp;=&nbsp;douglas_peucker_2d(points[max_idx:],&nbsp;epsilon)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;np.vstack([left[:-1],&nbsp;right])<br>
&nbsp;&nbsp;&nbsp;&nbsp;else:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;points[[0,&nbsp;-1]]<br>
<br>
<br>
def&nbsp;douglas_peucker_2d_with_fixed(<br>
&nbsp;&nbsp;&nbsp;&nbsp;points:&nbsp;np.ndarray,<br>
&nbsp;&nbsp;&nbsp;&nbsp;epsilon:&nbsp;float,<br>
&nbsp;&nbsp;&nbsp;&nbsp;fixed_indices:&nbsp;set[int],<br>
)&nbsp;-&gt;&nbsp;np.ndarray:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Упростить&nbsp;2D&nbsp;полилинию&nbsp;алгоритмом&nbsp;Douglas-Peucker,&nbsp;сохраняя&nbsp;фиксированные&nbsp;вершины.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Фиксированные&nbsp;вершины&nbsp;(например,&nbsp;на&nbsp;границах&nbsp;с&nbsp;другими&nbsp;регионами)&nbsp;не&nbsp;удаляются.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;points:&nbsp;np.ndarray&nbsp;shape&nbsp;(N,&nbsp;2)&nbsp;—&nbsp;вершины&nbsp;полилинии.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;epsilon:&nbsp;Максимальное&nbsp;отклонение.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fixed_indices:&nbsp;Индексы&nbsp;вершин,&nbsp;которые&nbsp;нельзя&nbsp;удалять.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Упрощённая&nbsp;полилиния&nbsp;shape&nbsp;(M,&nbsp;2).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;len(points)&nbsp;&lt;=&nbsp;2:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;points<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;=&nbsp;len(points)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Находим&nbsp;индексы,&nbsp;которые&nbsp;нужно&nbsp;сохранить&nbsp;(включая&nbsp;первый,&nbsp;последний&nbsp;и&nbsp;фиксированные)<br>
&nbsp;&nbsp;&nbsp;&nbsp;keep_indices:&nbsp;set[int]&nbsp;=&nbsp;{0,&nbsp;n&nbsp;-&nbsp;1}<br>
&nbsp;&nbsp;&nbsp;&nbsp;keep_indices.update(i&nbsp;for&nbsp;i&nbsp;in&nbsp;fixed_indices&nbsp;if&nbsp;0&nbsp;&lt;=&nbsp;i&nbsp;&lt;&nbsp;n)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Рекурсивная&nbsp;функция&nbsp;для&nbsp;упрощения&nbsp;сегмента<br>
&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;simplify_segment(start_idx:&nbsp;int,&nbsp;end_idx:&nbsp;int)&nbsp;-&gt;&nbsp;None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;end_idx&nbsp;-&nbsp;start_idx&nbsp;&lt;=&nbsp;1:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;start&nbsp;=&nbsp;points[start_idx]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end&nbsp;=&nbsp;points[end_idx]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line_vec&nbsp;=&nbsp;end&nbsp;-&nbsp;start<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line_len&nbsp;=&nbsp;np.linalg.norm(line_vec)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;line_len&nbsp;&lt;&nbsp;1e-10:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line_dir&nbsp;=&nbsp;line_vec&nbsp;/&nbsp;line_len<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max_dist&nbsp;=&nbsp;0.0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max_idx&nbsp;=&nbsp;-1<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Ищем&nbsp;точку&nbsp;с&nbsp;максимальным&nbsp;отклонением&nbsp;(исключая&nbsp;фиксированные)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i&nbsp;in&nbsp;range(start_idx&nbsp;+&nbsp;1,&nbsp;end_idx):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to_point&nbsp;=&nbsp;points[i]&nbsp;-&nbsp;start<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proj_len&nbsp;=&nbsp;np.dot(to_point,&nbsp;line_dir)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proj_point&nbsp;=&nbsp;start&nbsp;+&nbsp;proj_len&nbsp;*&nbsp;line_dir<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dist&nbsp;=&nbsp;np.linalg.norm(points[i]&nbsp;-&nbsp;proj_point)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;dist&nbsp;&gt;&nbsp;max_dist:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max_dist&nbsp;=&nbsp;dist<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max_idx&nbsp;=&nbsp;i<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Проверяем,&nbsp;есть&nbsp;ли&nbsp;фиксированные&nbsp;точки&nbsp;в&nbsp;этом&nbsp;сегменте<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fixed_in_segment&nbsp;=&nbsp;[i&nbsp;for&nbsp;i&nbsp;in&nbsp;range(start_idx&nbsp;+&nbsp;1,&nbsp;end_idx)&nbsp;if&nbsp;i&nbsp;in&nbsp;fixed_indices]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;fixed_in_segment:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Если&nbsp;есть&nbsp;фиксированные&nbsp;точки,&nbsp;добавляем&nbsp;их&nbsp;и&nbsp;рекурсивно&nbsp;обрабатываем&nbsp;подсегменты<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;fixed_idx&nbsp;in&nbsp;fixed_in_segment:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keep_indices.add(fixed_idx)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Сортируем&nbsp;все&nbsp;сохраняемые&nbsp;точки&nbsp;в&nbsp;сегменте<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;segment_keep&nbsp;=&nbsp;sorted([start_idx]&nbsp;+&nbsp;fixed_in_segment&nbsp;+&nbsp;[end_idx])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i&nbsp;in&nbsp;range(len(segment_keep)&nbsp;-&nbsp;1):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;simplify_segment(segment_keep[i],&nbsp;segment_keep[i&nbsp;+&nbsp;1])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif&nbsp;max_dist&nbsp;&gt;&nbsp;epsilon&nbsp;and&nbsp;max_idx&nbsp;&gt;&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Стандартный&nbsp;Douglas-Peucker<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keep_indices.add(max_idx)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;simplify_segment(start_idx,&nbsp;max_idx)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;simplify_segment(max_idx,&nbsp;end_idx)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;simplify_segment(0,&nbsp;n&nbsp;-&nbsp;1)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Собираем&nbsp;результат<br>
&nbsp;&nbsp;&nbsp;&nbsp;sorted_indices&nbsp;=&nbsp;sorted(keep_indices)<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;points[sorted_indices]<br>
<br>
<br>
def&nbsp;is_vertex_visible(<br>
&nbsp;&nbsp;&nbsp;&nbsp;contour:&nbsp;list,<br>
&nbsp;&nbsp;&nbsp;&nbsp;vertex_idx:&nbsp;int,<br>
&nbsp;&nbsp;&nbsp;&nbsp;point:&nbsp;np.ndarray,<br>
&nbsp;&nbsp;&nbsp;&nbsp;hole:&nbsp;list,<br>
)&nbsp;-&gt;&nbsp;bool:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Проверить,&nbsp;видима&nbsp;ли&nbsp;вершина&nbsp;контура&nbsp;из&nbsp;точки.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;contour:&nbsp;Список&nbsp;вершин&nbsp;контура.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertex_idx:&nbsp;Индекс&nbsp;вершины.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;point:&nbsp;Точка,&nbsp;из&nbsp;которой&nbsp;проверяем&nbsp;видимость.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hole:&nbsp;Список&nbsp;вершин&nbsp;дырки.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;True&nbsp;если&nbsp;вершина&nbsp;видима.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;vertex&nbsp;=&nbsp;contour[vertex_idx]<br>
&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;=&nbsp;len(contour)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Проверяем&nbsp;пересечение&nbsp;со&nbsp;всеми&nbsp;рёбрами&nbsp;контура<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i&nbsp;in&nbsp;range(n):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;i&nbsp;==&nbsp;vertex_idx&nbsp;or&nbsp;(i&nbsp;+&nbsp;1)&nbsp;%&nbsp;n&nbsp;==&nbsp;vertex_idx:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;i&nbsp;==&nbsp;(vertex_idx&nbsp;-&nbsp;1)&nbsp;%&nbsp;n:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p1&nbsp;=&nbsp;contour[i]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p2&nbsp;=&nbsp;contour[(i&nbsp;+&nbsp;1)&nbsp;%&nbsp;n]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;segments_intersect_strict(point,&nbsp;vertex,&nbsp;p1,&nbsp;p2):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;False<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Проверяем&nbsp;пересечение&nbsp;с&nbsp;рёбрами&nbsp;дырки<br>
&nbsp;&nbsp;&nbsp;&nbsp;m&nbsp;=&nbsp;len(hole)<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i&nbsp;in&nbsp;range(m):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p1&nbsp;=&nbsp;hole[i]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p2&nbsp;=&nbsp;hole[(i&nbsp;+&nbsp;1)&nbsp;%&nbsp;m]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;segments_intersect_strict(point,&nbsp;vertex,&nbsp;p1,&nbsp;p2):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;False<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;True<br>
<br>
<br>
def&nbsp;find_optimal_bridge(<br>
&nbsp;&nbsp;&nbsp;&nbsp;contour:&nbsp;list,<br>
&nbsp;&nbsp;&nbsp;&nbsp;hole:&nbsp;list,<br>
)&nbsp;-&gt;&nbsp;tuple[int,&nbsp;int]&nbsp;|&nbsp;None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Найти&nbsp;оптимальный&nbsp;мост&nbsp;между&nbsp;контуром&nbsp;и&nbsp;дыркой.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Перебирает&nbsp;все&nbsp;пары&nbsp;(вершина&nbsp;контура,&nbsp;вершина&nbsp;дырки),<br>
&nbsp;&nbsp;&nbsp;&nbsp;проверяет&nbsp;видимость&nbsp;и&nbsp;выбирает&nbsp;пару&nbsp;с&nbsp;минимальным&nbsp;расстоянием.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;contour:&nbsp;Список&nbsp;вершин&nbsp;внешнего&nbsp;контура&nbsp;[(x,&nbsp;y),&nbsp;...].<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hole:&nbsp;Список&nbsp;вершин&nbsp;дырки&nbsp;[(x,&nbsp;y),&nbsp;...].<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(outer_idx,&nbsp;hole_idx)&nbsp;или&nbsp;None&nbsp;если&nbsp;мост&nbsp;не&nbsp;найден.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;n_contour&nbsp;=&nbsp;len(contour)<br>
&nbsp;&nbsp;&nbsp;&nbsp;n_hole&nbsp;=&nbsp;len(hole)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;best_dist&nbsp;=&nbsp;float('inf')<br>
&nbsp;&nbsp;&nbsp;&nbsp;best_pair&nbsp;=&nbsp;None<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Перебираем&nbsp;все&nbsp;пары&nbsp;вершин<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;hi&nbsp;in&nbsp;range(n_hole):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hole_point&nbsp;=&nbsp;hole[hi]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hx,&nbsp;hy&nbsp;=&nbsp;hole_point[0],&nbsp;hole_point[1]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;ci&nbsp;in&nbsp;range(n_contour):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Проверяем&nbsp;видимость<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;is_vertex_visible(contour,&nbsp;ci,&nbsp;hole_point,&nbsp;hole):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Вычисляем&nbsp;расстояние<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dx&nbsp;=&nbsp;contour[ci][0]&nbsp;-&nbsp;hx<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dy&nbsp;=&nbsp;contour[ci][1]&nbsp;-&nbsp;hy<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dist&nbsp;=&nbsp;dx&nbsp;*&nbsp;dx&nbsp;+&nbsp;dy&nbsp;*&nbsp;dy<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;dist&nbsp;&lt;&nbsp;best_dist:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;best_dist&nbsp;=&nbsp;dist<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;best_pair&nbsp;=&nbsp;(ci,&nbsp;hi)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Если&nbsp;ни&nbsp;одна&nbsp;пара&nbsp;не&nbsp;видима,&nbsp;ищем&nbsp;просто&nbsp;ближайшую<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;best_pair&nbsp;is&nbsp;None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;hi&nbsp;in&nbsp;range(n_hole):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hole_point&nbsp;=&nbsp;hole[hi]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hx,&nbsp;hy&nbsp;=&nbsp;hole_point[0],&nbsp;hole_point[1]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;ci&nbsp;in&nbsp;range(n_contour):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dx&nbsp;=&nbsp;contour[ci][0]&nbsp;-&nbsp;hx<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dy&nbsp;=&nbsp;contour[ci][1]&nbsp;-&nbsp;hy<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dist&nbsp;=&nbsp;dx&nbsp;*&nbsp;dx&nbsp;+&nbsp;dy&nbsp;*&nbsp;dy<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;dist&nbsp;&lt;&nbsp;best_dist:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;best_dist&nbsp;=&nbsp;dist<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;best_pair&nbsp;=&nbsp;(ci,&nbsp;hi)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;best_pair<br>
<br>
<br>
def&nbsp;merge_holes_with_bridges(<br>
&nbsp;&nbsp;&nbsp;&nbsp;outer:&nbsp;np.ndarray,<br>
&nbsp;&nbsp;&nbsp;&nbsp;holes:&nbsp;list[np.ndarray],<br>
)&nbsp;-&gt;&nbsp;np.ndarray:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Объединить&nbsp;дырки&nbsp;с&nbsp;внешним&nbsp;контуром&nbsp;через&nbsp;bridge&nbsp;edges.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outer:&nbsp;Внешний&nbsp;контур&nbsp;shape&nbsp;(N,&nbsp;2),&nbsp;CCW&nbsp;ориентация.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;holes:&nbsp;Список&nbsp;дырок,&nbsp;каждая&nbsp;shape&nbsp;(M,&nbsp;2),&nbsp;CW&nbsp;ориентация.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Объединённый&nbsp;контур&nbsp;shape&nbsp;(K,&nbsp;2).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;holes:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;outer<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;list(outer)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Сортируем&nbsp;дырки&nbsp;по&nbsp;максимальному&nbsp;X&nbsp;(обрабатываем&nbsp;справа&nbsp;налево)<br>
&nbsp;&nbsp;&nbsp;&nbsp;sorted_holes&nbsp;=&nbsp;sorted(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;holes,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key=lambda&nbsp;h:&nbsp;max(p[0]&nbsp;for&nbsp;p&nbsp;in&nbsp;h),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reverse=True<br>
&nbsp;&nbsp;&nbsp;&nbsp;)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;hole&nbsp;in&nbsp;sorted_holes:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;len(hole)&nbsp;&lt;&nbsp;3:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hole_list&nbsp;=&nbsp;list(hole)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bridge&nbsp;=&nbsp;find_optimal_bridge(result,&nbsp;hole_list)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;bridge&nbsp;is&nbsp;None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bridge_outer_idx,&nbsp;bridge_hole_idx&nbsp;=&nbsp;bridge<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Вставляем&nbsp;дырку&nbsp;в&nbsp;контур<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_contour&nbsp;=&nbsp;[]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Часть&nbsp;внешнего&nbsp;контура&nbsp;до&nbsp;bridge&nbsp;vertex&nbsp;(включительно)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i&nbsp;in&nbsp;range(bridge_outer_idx&nbsp;+&nbsp;1):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_contour.append(result[i])<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Дырка&nbsp;в&nbsp;прямом&nbsp;порядке&nbsp;(CW),&nbsp;начиная&nbsp;с&nbsp;bridge_hole_idx<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i&nbsp;in&nbsp;range(len(hole_list)):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;idx&nbsp;=&nbsp;(bridge_hole_idx&nbsp;+&nbsp;i)&nbsp;%&nbsp;len(hole_list)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_contour.append(hole_list[idx])<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Возврат&nbsp;к&nbsp;bridge&nbsp;vertex&nbsp;(замыкаем&nbsp;мост)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_contour.append(hole_list[bridge_hole_idx])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_contour.append(result[bridge_outer_idx])<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Остаток&nbsp;внешнего&nbsp;контура<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i&nbsp;in&nbsp;range(bridge_outer_idx&nbsp;+&nbsp;1,&nbsp;len(result)):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_contour.append(result[i])<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;new_contour<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;np.array(result,&nbsp;dtype=np.float32)<br>
<br>
<br>
def&nbsp;in_circumcircle(<br>
&nbsp;&nbsp;&nbsp;&nbsp;ax:&nbsp;float,&nbsp;ay:&nbsp;float,<br>
&nbsp;&nbsp;&nbsp;&nbsp;bx:&nbsp;float,&nbsp;by:&nbsp;float,<br>
&nbsp;&nbsp;&nbsp;&nbsp;cx:&nbsp;float,&nbsp;cy:&nbsp;float,<br>
&nbsp;&nbsp;&nbsp;&nbsp;dx:&nbsp;float,&nbsp;dy:&nbsp;float,<br>
)&nbsp;-&gt;&nbsp;bool:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Проверить,&nbsp;лежит&nbsp;ли&nbsp;точка&nbsp;D&nbsp;внутри&nbsp;описанной&nbsp;окружности&nbsp;треугольника&nbsp;ABC.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Использует&nbsp;определитель&nbsp;3x3&nbsp;(критерий&nbsp;Delaunay).<br>
&nbsp;&nbsp;&nbsp;&nbsp;Предполагает&nbsp;CCW&nbsp;ориентацию&nbsp;ABC.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;True&nbsp;если&nbsp;D&nbsp;внутри&nbsp;окружности.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Сдвигаем&nbsp;координаты&nbsp;относительно&nbsp;D<br>
&nbsp;&nbsp;&nbsp;&nbsp;adx&nbsp;=&nbsp;ax&nbsp;-&nbsp;dx<br>
&nbsp;&nbsp;&nbsp;&nbsp;ady&nbsp;=&nbsp;ay&nbsp;-&nbsp;dy<br>
&nbsp;&nbsp;&nbsp;&nbsp;bdx&nbsp;=&nbsp;bx&nbsp;-&nbsp;dx<br>
&nbsp;&nbsp;&nbsp;&nbsp;bdy&nbsp;=&nbsp;by&nbsp;-&nbsp;dy<br>
&nbsp;&nbsp;&nbsp;&nbsp;cdx&nbsp;=&nbsp;cx&nbsp;-&nbsp;dx<br>
&nbsp;&nbsp;&nbsp;&nbsp;cdy&nbsp;=&nbsp;cy&nbsp;-&nbsp;dy<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Квадраты&nbsp;расстояний<br>
&nbsp;&nbsp;&nbsp;&nbsp;ad_sq&nbsp;=&nbsp;adx&nbsp;*&nbsp;adx&nbsp;+&nbsp;ady&nbsp;*&nbsp;ady<br>
&nbsp;&nbsp;&nbsp;&nbsp;bd_sq&nbsp;=&nbsp;bdx&nbsp;*&nbsp;bdx&nbsp;+&nbsp;bdy&nbsp;*&nbsp;bdy<br>
&nbsp;&nbsp;&nbsp;&nbsp;cd_sq&nbsp;=&nbsp;cdx&nbsp;*&nbsp;cdx&nbsp;+&nbsp;cdy&nbsp;*&nbsp;cdy<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Определитель&nbsp;3x3<br>
&nbsp;&nbsp;&nbsp;&nbsp;det&nbsp;=&nbsp;adx&nbsp;*&nbsp;(bdy&nbsp;*&nbsp;cd_sq&nbsp;-&nbsp;cdy&nbsp;*&nbsp;bd_sq)&nbsp;\<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;ady&nbsp;*&nbsp;(bdx&nbsp;*&nbsp;cd_sq&nbsp;-&nbsp;cdx&nbsp;*&nbsp;bd_sq)&nbsp;\<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;ad_sq&nbsp;*&nbsp;(bdx&nbsp;*&nbsp;cdy&nbsp;-&nbsp;cdx&nbsp;*&nbsp;bdy)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;det&nbsp;&gt;&nbsp;0<br>
<br>
<br>
def&nbsp;build_edge_map(<br>
&nbsp;&nbsp;&nbsp;&nbsp;triangles:&nbsp;list[tuple[int,&nbsp;int,&nbsp;int]],<br>
)&nbsp;-&gt;&nbsp;dict[tuple[int,&nbsp;int],&nbsp;list[int]]:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Построить&nbsp;карту&nbsp;рёбер:&nbsp;edge&nbsp;-&gt;&nbsp;список&nbsp;индексов&nbsp;треугольников.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Ребро&nbsp;нормализовано&nbsp;(меньший&nbsp;индекс&nbsp;первым).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;edge_map:&nbsp;dict[tuple[int,&nbsp;int],&nbsp;list[int]]&nbsp;=&nbsp;{}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;tri_idx,&nbsp;(a,&nbsp;b,&nbsp;c)&nbsp;in&nbsp;enumerate(triangles):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;v0,&nbsp;v1&nbsp;in&nbsp;[(a,&nbsp;b),&nbsp;(b,&nbsp;c),&nbsp;(c,&nbsp;a)]:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge&nbsp;=&nbsp;(min(v0,&nbsp;v1),&nbsp;max(v0,&nbsp;v1))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;edge&nbsp;not&nbsp;in&nbsp;edge_map:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge_map[edge]&nbsp;=&nbsp;[]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge_map[edge].append(tri_idx)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;edge_map<br>
<br>
<br>
def&nbsp;get_opposite_vertex(<br>
&nbsp;&nbsp;&nbsp;&nbsp;tri:&nbsp;tuple[int,&nbsp;int,&nbsp;int],<br>
&nbsp;&nbsp;&nbsp;&nbsp;edge:&nbsp;tuple[int,&nbsp;int],<br>
)&nbsp;-&gt;&nbsp;int:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Получить&nbsp;вершину&nbsp;треугольника,&nbsp;противоположную&nbsp;ребру.&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;v&nbsp;in&nbsp;tri:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;v&nbsp;!=&nbsp;edge[0]&nbsp;and&nbsp;v&nbsp;!=&nbsp;edge[1]:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;v<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;-1<br>
<br>
<br>
def&nbsp;delaunay_flip(<br>
&nbsp;&nbsp;&nbsp;&nbsp;vertices:&nbsp;np.ndarray,<br>
&nbsp;&nbsp;&nbsp;&nbsp;triangles:&nbsp;list[tuple[int,&nbsp;int,&nbsp;int]],<br>
&nbsp;&nbsp;&nbsp;&nbsp;boundary_edges:&nbsp;set[tuple[int,&nbsp;int]]&nbsp;|&nbsp;None&nbsp;=&nbsp;None,<br>
&nbsp;&nbsp;&nbsp;&nbsp;max_iterations:&nbsp;int&nbsp;=&nbsp;1000,<br>
)&nbsp;-&gt;&nbsp;list[tuple[int,&nbsp;int,&nbsp;int]]:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Улучшить&nbsp;триангуляцию&nbsp;методом&nbsp;edge&nbsp;flipping&nbsp;(Delaunay).<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertices:&nbsp;2D&nbsp;координаты&nbsp;вершин,&nbsp;shape&nbsp;(N,&nbsp;2).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;triangles:&nbsp;Список&nbsp;треугольников&nbsp;[(a,&nbsp;b,&nbsp;c),&nbsp;...].<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boundary_edges:&nbsp;Множество&nbsp;граничных&nbsp;рёбер&nbsp;(не&nbsp;переворачивать).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max_iterations:&nbsp;Максимум&nbsp;итераций.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Улучшенный&nbsp;список&nbsp;треугольников.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;len(triangles)&nbsp;&lt;&nbsp;2:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;triangles<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;triangles&nbsp;=&nbsp;list(triangles)&nbsp;&nbsp;#&nbsp;копия<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;boundary_edges&nbsp;is&nbsp;None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boundary_edges&nbsp;=&nbsp;set()<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;flip_count&nbsp;=&nbsp;0<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;iteration&nbsp;in&nbsp;range(max_iterations):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flipped&nbsp;=&nbsp;False<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge_map&nbsp;=&nbsp;build_edge_map(triangles)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;edge,&nbsp;tri_indices&nbsp;in&nbsp;edge_map.items():<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Только&nbsp;внутренние&nbsp;рёбра&nbsp;(2&nbsp;треугольника)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;len(tri_indices)&nbsp;!=&nbsp;2:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Не&nbsp;трогаем&nbsp;граничные&nbsp;рёбра<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;edge&nbsp;in&nbsp;boundary_edges:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tri1_idx,&nbsp;tri2_idx&nbsp;=&nbsp;tri_indices<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tri1&nbsp;=&nbsp;triangles[tri1_idx]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tri2&nbsp;=&nbsp;triangles[tri2_idx]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Вершины&nbsp;противоположные&nbsp;ребру<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v1&nbsp;=&nbsp;get_opposite_vertex(tri1,&nbsp;edge)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v2&nbsp;=&nbsp;get_opposite_vertex(tri2,&nbsp;edge)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;v1&nbsp;&lt;&nbsp;0&nbsp;or&nbsp;v2&nbsp;&lt;&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Проверяем&nbsp;Delaunay&nbsp;критерий<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Точки&nbsp;ребра<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e0,&nbsp;e1&nbsp;=&nbsp;edge<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ax,&nbsp;ay&nbsp;=&nbsp;vertices[e0]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bx,&nbsp;by&nbsp;=&nbsp;vertices[e1]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cx,&nbsp;cy&nbsp;=&nbsp;vertices[v1]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dx,&nbsp;dy&nbsp;=&nbsp;vertices[v2]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Проверяем&nbsp;ориентацию&nbsp;треугольника&nbsp;(e0,&nbsp;e1,&nbsp;v1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Если&nbsp;CW,&nbsp;меняем&nbsp;порядок&nbsp;для&nbsp;корректной&nbsp;проверки<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cross&nbsp;=&nbsp;(bx&nbsp;-&nbsp;ax)&nbsp;*&nbsp;(cy&nbsp;-&nbsp;ay)&nbsp;-&nbsp;(by&nbsp;-&nbsp;ay)&nbsp;*&nbsp;(cx&nbsp;-&nbsp;ax)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;cross&nbsp;&lt;&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;CW&nbsp;—&nbsp;меняем&nbsp;местами<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ax,&nbsp;ay,&nbsp;bx,&nbsp;by&nbsp;=&nbsp;bx,&nbsp;by,&nbsp;ax,&nbsp;ay<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Проверяем,&nbsp;лежит&nbsp;ли&nbsp;v2&nbsp;внутри&nbsp;описанной&nbsp;окружности&nbsp;(e0,&nbsp;e1,&nbsp;v1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;in_circumcircle(ax,&nbsp;ay,&nbsp;bx,&nbsp;by,&nbsp;cx,&nbsp;cy,&nbsp;dx,&nbsp;dy):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Flip:&nbsp;заменяем&nbsp;ребро&nbsp;(e0,&nbsp;e1)&nbsp;на&nbsp;(v1,&nbsp;v2)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Новые&nbsp;треугольники:&nbsp;(e0,&nbsp;v2,&nbsp;v1)&nbsp;и&nbsp;(e1,&nbsp;v1,&nbsp;v2)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_tri1&nbsp;=&nbsp;(e0,&nbsp;v2,&nbsp;v1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_tri2&nbsp;=&nbsp;(e1,&nbsp;v1,&nbsp;v2)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Проверяем&nbsp;корректность&nbsp;(не&nbsp;вырожденные)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;tri_area(t):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a,&nbsp;b,&nbsp;c&nbsp;=&nbsp;t<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;abs(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vertices[b][0]&nbsp;-&nbsp;vertices[a][0])&nbsp;*&nbsp;(vertices[c][1]&nbsp;-&nbsp;vertices[a][1])&nbsp;-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vertices[c][0]&nbsp;-&nbsp;vertices[a][0])&nbsp;*&nbsp;(vertices[b][1]&nbsp;-&nbsp;vertices[a][1])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;tri_area(new_tri1)&nbsp;&gt;&nbsp;1e-10&nbsp;and&nbsp;tri_area(new_tri2)&nbsp;&gt;&nbsp;1e-10:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;triangles[tri1_idx]&nbsp;=&nbsp;new_tri1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;triangles[tri2_idx]&nbsp;=&nbsp;new_tri2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flipped&nbsp;=&nbsp;True<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flip_count&nbsp;+=&nbsp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break&nbsp;&nbsp;#&nbsp;Перестраиваем&nbsp;edge_map<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;flipped:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;flip_count&nbsp;&gt;&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(f&quot;[delaunay_flip]&nbsp;{flip_count}&nbsp;flips&quot;)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;triangles<br>
<br>
<br>
def&nbsp;valence_flip(<br>
&nbsp;&nbsp;&nbsp;&nbsp;vertices:&nbsp;np.ndarray,<br>
&nbsp;&nbsp;&nbsp;&nbsp;triangles:&nbsp;list[tuple[int,&nbsp;int,&nbsp;int]],<br>
&nbsp;&nbsp;&nbsp;&nbsp;boundary_edges:&nbsp;set[tuple[int,&nbsp;int]]&nbsp;|&nbsp;None&nbsp;=&nbsp;None,<br>
&nbsp;&nbsp;&nbsp;&nbsp;max_vertex_valence:&nbsp;int&nbsp;=&nbsp;0,<br>
&nbsp;&nbsp;&nbsp;&nbsp;max_iterations:&nbsp;int&nbsp;=&nbsp;1000,<br>
)&nbsp;-&gt;&nbsp;list[tuple[int,&nbsp;int,&nbsp;int]]:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Улучшить&nbsp;триангуляцию&nbsp;методом&nbsp;edge&nbsp;flipping&nbsp;для&nbsp;уменьшения&nbsp;валентности.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Переворачивает&nbsp;рёбра,&nbsp;если&nbsp;это&nbsp;уменьшает&nbsp;максимальную&nbsp;валентность&nbsp;вершин.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertices:&nbsp;2D&nbsp;координаты&nbsp;вершин,&nbsp;shape&nbsp;(N,&nbsp;2).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;triangles:&nbsp;Список&nbsp;треугольников&nbsp;[(a,&nbsp;b,&nbsp;c),&nbsp;...].<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boundary_edges:&nbsp;Множество&nbsp;граничных&nbsp;рёбер&nbsp;(не&nbsp;переворачивать).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max_vertex_valence:&nbsp;Целевая&nbsp;макс.&nbsp;валентность&nbsp;(0&nbsp;=&nbsp;минимизировать).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max_iterations:&nbsp;Максимум&nbsp;итераций.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Улучшенный&nbsp;список&nbsp;треугольников.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;len(triangles)&nbsp;&lt;&nbsp;2:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;triangles<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;triangles&nbsp;=&nbsp;list(triangles)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;boundary_edges&nbsp;is&nbsp;None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boundary_edges&nbsp;=&nbsp;set()<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;compute_valence()&nbsp;-&gt;&nbsp;dict[int,&nbsp;int]:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Подсчитать&nbsp;валентность&nbsp;каждой&nbsp;вершины.&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val:&nbsp;dict[int,&nbsp;int]&nbsp;=&nbsp;{}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;tri&nbsp;in&nbsp;triangles:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;v&nbsp;in&nbsp;tri:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val[v]&nbsp;=&nbsp;val.get(v,&nbsp;0)&nbsp;+&nbsp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;val<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;flip_count&nbsp;=&nbsp;0<br>
&nbsp;&nbsp;&nbsp;&nbsp;initial_max_valence&nbsp;=&nbsp;max(compute_valence().values())&nbsp;if&nbsp;triangles&nbsp;else&nbsp;0<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;iteration&nbsp;in&nbsp;range(max_iterations):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flipped&nbsp;=&nbsp;False<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;valence&nbsp;=&nbsp;compute_valence()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge_map&nbsp;=&nbsp;build_edge_map(triangles)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Если&nbsp;задан&nbsp;max_vertex_valence&nbsp;и&nbsp;все&nbsp;вершины&nbsp;в&nbsp;пределах&nbsp;—&nbsp;выходим<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;max_vertex_valence&nbsp;&gt;&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current_max&nbsp;=&nbsp;max(valence.values())&nbsp;if&nbsp;valence&nbsp;else&nbsp;0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;current_max&nbsp;&lt;=&nbsp;max_vertex_valence:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;edge,&nbsp;tri_indices&nbsp;in&nbsp;edge_map.items():<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;len(tri_indices)&nbsp;!=&nbsp;2:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;edge&nbsp;in&nbsp;boundary_edges:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tri1_idx,&nbsp;tri2_idx&nbsp;=&nbsp;tri_indices<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tri1&nbsp;=&nbsp;triangles[tri1_idx]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tri2&nbsp;=&nbsp;triangles[tri2_idx]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e0,&nbsp;e1&nbsp;=&nbsp;edge<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v1&nbsp;=&nbsp;get_opposite_vertex(tri1,&nbsp;edge)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v2&nbsp;=&nbsp;get_opposite_vertex(tri2,&nbsp;edge)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;v1&nbsp;&lt;&nbsp;0&nbsp;or&nbsp;v2&nbsp;&lt;&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Текущие&nbsp;валентности<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val_e0&nbsp;=&nbsp;valence.get(e0,&nbsp;0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val_e1&nbsp;=&nbsp;valence.get(e1,&nbsp;0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val_v1&nbsp;=&nbsp;valence.get(v1,&nbsp;0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val_v2&nbsp;=&nbsp;valence.get(v2,&nbsp;0)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current_max&nbsp;=&nbsp;max(val_e0,&nbsp;val_e1,&nbsp;val_v1,&nbsp;val_v2)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;После&nbsp;flip:&nbsp;e0,&nbsp;e1&nbsp;теряют&nbsp;по&nbsp;1;&nbsp;v1,&nbsp;v2&nbsp;получают&nbsp;по&nbsp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_max&nbsp;=&nbsp;max(val_e0&nbsp;-&nbsp;1,&nbsp;val_e1&nbsp;-&nbsp;1,&nbsp;val_v1&nbsp;+&nbsp;1,&nbsp;val_v2&nbsp;+&nbsp;1)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Flip&nbsp;только&nbsp;если&nbsp;уменьшает&nbsp;max&nbsp;валентность<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;new_max&nbsp;&gt;=&nbsp;current_max:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Если&nbsp;задан&nbsp;порог&nbsp;и&nbsp;новый&nbsp;max&nbsp;всё&nbsp;ещё&nbsp;выше&nbsp;порога&nbsp;у&nbsp;v1/v2&nbsp;—&nbsp;не&nbsp;flip<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;(иначе&nbsp;мы&nbsp;просто&nbsp;переносим&nbsp;проблему&nbsp;на&nbsp;другие&nbsp;вершины)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;max_vertex_valence&nbsp;&gt;&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;val_v1&nbsp;+&nbsp;1&nbsp;&gt;&nbsp;max_vertex_valence&nbsp;or&nbsp;val_v2&nbsp;+&nbsp;1&nbsp;&gt;&nbsp;max_vertex_valence:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Проверяем&nbsp;что&nbsp;flip&nbsp;хотя&nbsp;бы&nbsp;уменьшает&nbsp;проблему<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;val_e0&nbsp;&lt;=&nbsp;max_vertex_valence&nbsp;and&nbsp;val_e1&nbsp;&lt;=&nbsp;max_vertex_valence:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Выполняем&nbsp;flip<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_tri1&nbsp;=&nbsp;(e0,&nbsp;v2,&nbsp;v1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_tri2&nbsp;=&nbsp;(e1,&nbsp;v1,&nbsp;v2)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Проверяем&nbsp;что&nbsp;новые&nbsp;треугольники&nbsp;не&nbsp;вырождены<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;tri_area(t):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a,&nbsp;b,&nbsp;c&nbsp;=&nbsp;t<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;abs(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vertices[b][0]&nbsp;-&nbsp;vertices[a][0])&nbsp;*&nbsp;(vertices[c][1]&nbsp;-&nbsp;vertices[a][1])&nbsp;-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vertices[c][0]&nbsp;-&nbsp;vertices[a][0])&nbsp;*&nbsp;(vertices[b][1]&nbsp;-&nbsp;vertices[a][1])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;tri_area(new_tri1)&nbsp;&gt;&nbsp;1e-10&nbsp;and&nbsp;tri_area(new_tri2)&nbsp;&gt;&nbsp;1e-10:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;triangles[tri1_idx]&nbsp;=&nbsp;new_tri1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;triangles[tri2_idx]&nbsp;=&nbsp;new_tri2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flipped&nbsp;=&nbsp;True<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flip_count&nbsp;+=&nbsp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;flipped:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;flip_count&nbsp;&gt;&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final_max_valence&nbsp;=&nbsp;max(compute_valence().values())&nbsp;if&nbsp;triangles&nbsp;else&nbsp;0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(f&quot;[valence_flip]&nbsp;{flip_count}&nbsp;flips,&nbsp;max&nbsp;valence:&nbsp;{initial_max_valence}&nbsp;-&gt;&nbsp;{final_max_valence}&quot;)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;triangles<br>
<br>
<br>
def&nbsp;angle_flip(<br>
&nbsp;&nbsp;&nbsp;&nbsp;vertices:&nbsp;np.ndarray,<br>
&nbsp;&nbsp;&nbsp;&nbsp;triangles:&nbsp;list[tuple[int,&nbsp;int,&nbsp;int]],<br>
&nbsp;&nbsp;&nbsp;&nbsp;boundary_edges:&nbsp;set[tuple[int,&nbsp;int]]&nbsp;|&nbsp;None&nbsp;=&nbsp;None,<br>
&nbsp;&nbsp;&nbsp;&nbsp;max_iterations:&nbsp;int&nbsp;=&nbsp;1000,<br>
)&nbsp;-&gt;&nbsp;list[tuple[int,&nbsp;int,&nbsp;int]]:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Улучшить&nbsp;триангуляцию&nbsp;методом&nbsp;edge&nbsp;flipping&nbsp;для&nbsp;максимизации&nbsp;минимального&nbsp;угла.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Переворачивает&nbsp;рёбра,&nbsp;если&nbsp;это&nbsp;увеличивает&nbsp;минимальный&nbsp;угол&nbsp;в&nbsp;паре&nbsp;треугольников.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertices:&nbsp;2D&nbsp;координаты&nbsp;вершин,&nbsp;shape&nbsp;(N,&nbsp;2).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;triangles:&nbsp;Список&nbsp;треугольников&nbsp;[(a,&nbsp;b,&nbsp;c),&nbsp;...].<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boundary_edges:&nbsp;Множество&nbsp;граничных&nbsp;рёбер&nbsp;(не&nbsp;переворачивать).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max_iterations:&nbsp;Максимум&nbsp;итераций.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Улучшенный&nbsp;список&nbsp;треугольников.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;import&nbsp;math<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;len(triangles)&nbsp;&lt;&nbsp;2:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;triangles<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;triangles&nbsp;=&nbsp;list(triangles)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;boundary_edges&nbsp;is&nbsp;None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boundary_edges&nbsp;=&nbsp;set()<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;compute_min_angle(tri:&nbsp;tuple[int,&nbsp;int,&nbsp;int])&nbsp;-&gt;&nbsp;float:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Вычислить&nbsp;минимальный&nbsp;угол&nbsp;треугольника&nbsp;в&nbsp;радианах.&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a,&nbsp;b,&nbsp;c&nbsp;=&nbsp;tri<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p0&nbsp;=&nbsp;vertices[a]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p1&nbsp;=&nbsp;vertices[b]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p2&nbsp;=&nbsp;vertices[c]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;angle_at(p,&nbsp;q,&nbsp;r):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Угол&nbsp;при&nbsp;вершине&nbsp;q&nbsp;в&nbsp;треугольнике&nbsp;p-q-r.&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v1&nbsp;=&nbsp;(p[0]&nbsp;-&nbsp;q[0],&nbsp;p[1]&nbsp;-&nbsp;q[1])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v2&nbsp;=&nbsp;(r[0]&nbsp;-&nbsp;q[0],&nbsp;r[1]&nbsp;-&nbsp;q[1])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dot&nbsp;=&nbsp;v1[0]&nbsp;*&nbsp;v2[0]&nbsp;+&nbsp;v1[1]&nbsp;*&nbsp;v2[1]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;len1&nbsp;=&nbsp;math.sqrt(v1[0]**2&nbsp;+&nbsp;v1[1]**2)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;len2&nbsp;=&nbsp;math.sqrt(v2[0]**2&nbsp;+&nbsp;v2[1]**2)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;len1&nbsp;&lt;&nbsp;1e-10&nbsp;or&nbsp;len2&nbsp;&lt;&nbsp;1e-10:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0.0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cos_angle&nbsp;=&nbsp;max(-1.0,&nbsp;min(1.0,&nbsp;dot&nbsp;/&nbsp;(len1&nbsp;*&nbsp;len2)))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;math.acos(cos_angle)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;min(angle_at(p1,&nbsp;p0,&nbsp;p2),&nbsp;angle_at(p0,&nbsp;p1,&nbsp;p2),&nbsp;angle_at(p0,&nbsp;p2,&nbsp;p1))<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;flip_count&nbsp;=&nbsp;0<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;iteration&nbsp;in&nbsp;range(max_iterations):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flipped&nbsp;=&nbsp;False<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge_map&nbsp;=&nbsp;build_edge_map(triangles)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;edge,&nbsp;tri_indices&nbsp;in&nbsp;edge_map.items():<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;len(tri_indices)&nbsp;!=&nbsp;2:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;edge&nbsp;in&nbsp;boundary_edges:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tri1_idx,&nbsp;tri2_idx&nbsp;=&nbsp;tri_indices<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tri1&nbsp;=&nbsp;triangles[tri1_idx]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tri2&nbsp;=&nbsp;triangles[tri2_idx]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e0,&nbsp;e1&nbsp;=&nbsp;edge<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v1&nbsp;=&nbsp;get_opposite_vertex(tri1,&nbsp;edge)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v2&nbsp;=&nbsp;get_opposite_vertex(tri2,&nbsp;edge)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;v1&nbsp;&lt;&nbsp;0&nbsp;or&nbsp;v2&nbsp;&lt;&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Текущий&nbsp;минимальный&nbsp;угол<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current_min&nbsp;=&nbsp;min(compute_min_angle(tri1),&nbsp;compute_min_angle(tri2))<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Новые&nbsp;треугольники&nbsp;после&nbsp;flip<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_tri1&nbsp;=&nbsp;(e0,&nbsp;v2,&nbsp;v1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_tri2&nbsp;=&nbsp;(e1,&nbsp;v1,&nbsp;v2)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Проверяем&nbsp;что&nbsp;новые&nbsp;треугольники&nbsp;не&nbsp;вырождены<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;tri_area(t):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a,&nbsp;b,&nbsp;c&nbsp;=&nbsp;t<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vertices[b][0]&nbsp;-&nbsp;vertices[a][0])&nbsp;*&nbsp;(vertices[c][1]&nbsp;-&nbsp;vertices[a][1])&nbsp;-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vertices[c][0]&nbsp;-&nbsp;vertices[a][0])&nbsp;*&nbsp;(vertices[b][1]&nbsp;-&nbsp;vertices[a][1])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;area1&nbsp;=&nbsp;tri_area(new_tri1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;area2&nbsp;=&nbsp;tri_area(new_tri2)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Оба&nbsp;треугольника&nbsp;должны&nbsp;иметь&nbsp;одинаковую&nbsp;ориентацию&nbsp;и&nbsp;не&nbsp;быть&nbsp;вырожденными<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;abs(area1)&nbsp;&lt;&nbsp;1e-10&nbsp;or&nbsp;abs(area2)&nbsp;&lt;&nbsp;1e-10:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(area1&nbsp;&gt;&nbsp;0)&nbsp;!=&nbsp;(area2&nbsp;&gt;&nbsp;0):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Минимальный&nbsp;угол&nbsp;после&nbsp;flip<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_min&nbsp;=&nbsp;min(compute_min_angle(new_tri1),&nbsp;compute_min_angle(new_tri2))<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Flip&nbsp;только&nbsp;если&nbsp;увеличивает&nbsp;минимальный&nbsp;угол<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;new_min&nbsp;&gt;&nbsp;current_min&nbsp;+&nbsp;1e-6:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;triangles[tri1_idx]&nbsp;=&nbsp;new_tri1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;triangles[tri2_idx]&nbsp;=&nbsp;new_tri2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flipped&nbsp;=&nbsp;True<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flip_count&nbsp;+=&nbsp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;flipped:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;flip_count&nbsp;&gt;&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(f&quot;[angle_flip]&nbsp;{flip_count}&nbsp;flips&quot;)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;triangles<br>
<br>
<br>
def&nbsp;cvt_smoothing(<br>
&nbsp;&nbsp;&nbsp;&nbsp;vertices:&nbsp;np.ndarray,<br>
&nbsp;&nbsp;&nbsp;&nbsp;triangles:&nbsp;list[tuple[int,&nbsp;int,&nbsp;int]],<br>
&nbsp;&nbsp;&nbsp;&nbsp;boundary_vertices:&nbsp;set[int]&nbsp;|&nbsp;None&nbsp;=&nbsp;None,<br>
&nbsp;&nbsp;&nbsp;&nbsp;iterations:&nbsp;int&nbsp;=&nbsp;3,<br>
)&nbsp;-&gt;&nbsp;np.ndarray:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Оптимизировать&nbsp;позиции&nbsp;вершин&nbsp;для&nbsp;улучшения&nbsp;качества&nbsp;треугольников.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Каждая&nbsp;внутренняя&nbsp;вершина&nbsp;двигается&nbsp;к&nbsp;позиции,&nbsp;которая&nbsp;делает&nbsp;окружающие<br>
&nbsp;&nbsp;&nbsp;&nbsp;треугольники&nbsp;более&nbsp;равносторонними.&nbsp;Движение&nbsp;ограничено&nbsp;чтобы&nbsp;сохранить&nbsp;площадь.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertices:&nbsp;2D&nbsp;координаты&nbsp;вершин,&nbsp;shape&nbsp;(N,&nbsp;2).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;triangles:&nbsp;Список&nbsp;треугольников&nbsp;[(a,&nbsp;b,&nbsp;c),&nbsp;...].<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boundary_vertices:&nbsp;Множество&nbsp;индексов&nbsp;граничных&nbsp;вершин&nbsp;(не&nbsp;сдвигать).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iterations:&nbsp;Количество&nbsp;итераций&nbsp;оптимизации.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Новый&nbsp;массив&nbsp;вершин.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;import&nbsp;math<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;len(vertices)&nbsp;==&nbsp;0&nbsp;or&nbsp;len(triangles)&nbsp;==&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;vertices<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;vertices&nbsp;=&nbsp;np.array(vertices,&nbsp;dtype=np.float64)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;boundary_vertices&nbsp;is&nbsp;None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boundary_vertices&nbsp;=&nbsp;set()<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Строим&nbsp;карту:&nbsp;вершина&nbsp;→&nbsp;список&nbsp;треугольников<br>
&nbsp;&nbsp;&nbsp;&nbsp;vertex_triangles:&nbsp;dict[int,&nbsp;list[int]]&nbsp;=&nbsp;{i:&nbsp;[]&nbsp;for&nbsp;i&nbsp;in&nbsp;range(len(vertices))}<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;tri_idx,&nbsp;tri&nbsp;in&nbsp;enumerate(triangles):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;v&nbsp;in&nbsp;tri:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertex_triangles[v].append(tri_idx)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Строим&nbsp;граф&nbsp;соседей<br>
&nbsp;&nbsp;&nbsp;&nbsp;neighbors:&nbsp;dict[int,&nbsp;set[int]]&nbsp;=&nbsp;{i:&nbsp;set()&nbsp;for&nbsp;i&nbsp;in&nbsp;range(len(vertices))}<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;tri&nbsp;in&nbsp;triangles:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a,&nbsp;b,&nbsp;c&nbsp;=&nbsp;tri<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbors[a].add(b)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbors[a].add(c)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbors[b].add(a)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbors[b].add(c)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbors[c].add(a)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbors[c].add(b)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;compute_total_area()&nbsp;-&gt;&nbsp;float:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Вычислить&nbsp;общую&nbsp;площадь.&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;total&nbsp;=&nbsp;0.0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;tri&nbsp;in&nbsp;triangles:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a,&nbsp;b,&nbsp;c&nbsp;=&nbsp;tri<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v0&nbsp;=&nbsp;vertices[a]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v1&nbsp;=&nbsp;vertices[b]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v2&nbsp;=&nbsp;vertices[c]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;total&nbsp;+=&nbsp;abs((v1[0]&nbsp;-&nbsp;v0[0])&nbsp;*&nbsp;(v2[1]&nbsp;-&nbsp;v0[1])&nbsp;-&nbsp;(v2[0]&nbsp;-&nbsp;v0[0])&nbsp;*&nbsp;(v1[1]&nbsp;-&nbsp;v0[1]))&nbsp;/&nbsp;2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;total<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;compute_ideal_position(v_idx:&nbsp;int)&nbsp;-&gt;&nbsp;tuple[float,&nbsp;float]:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Вычислить&nbsp;идеальную&nbsp;позицию&nbsp;для&nbsp;вершины.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Для&nbsp;каждого&nbsp;соседа&nbsp;вычисляем&nbsp;точку,&nbsp;которая&nbsp;образовала&nbsp;бы<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;равносторонний&nbsp;треугольник.&nbsp;Усредняем&nbsp;эти&nbsp;точки.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nbrs&nbsp;=&nbsp;list(neighbors[v_idx])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;len(nbrs)&nbsp;&lt;&nbsp;2:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;vertices[v_idx][0],&nbsp;vertices[v_idx][1]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Центроид&nbsp;соседей&nbsp;(как&nbsp;базовая&nbsp;точка)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cx&nbsp;=&nbsp;sum(vertices[n][0]&nbsp;for&nbsp;n&nbsp;in&nbsp;nbrs)&nbsp;/&nbsp;len(nbrs)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cy&nbsp;=&nbsp;sum(vertices[n][1]&nbsp;for&nbsp;n&nbsp;in&nbsp;nbrs)&nbsp;/&nbsp;len(nbrs)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;cx,&nbsp;cy<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;area_before&nbsp;=&nbsp;compute_total_area()<br>
&nbsp;&nbsp;&nbsp;&nbsp;interior_count&nbsp;=&nbsp;len(vertices)&nbsp;-&nbsp;len(boundary_vertices)<br>
&nbsp;&nbsp;&nbsp;&nbsp;interior_indices&nbsp;=&nbsp;[i&nbsp;for&nbsp;i&nbsp;in&nbsp;range(len(vertices))&nbsp;if&nbsp;i&nbsp;not&nbsp;in&nbsp;boundary_vertices]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Сохраняем&nbsp;исходные&nbsp;позиции&nbsp;граничных&nbsp;вершин&nbsp;для&nbsp;проверки<br>
&nbsp;&nbsp;&nbsp;&nbsp;boundary_positions_before&nbsp;=&nbsp;{i:&nbsp;(vertices[i][0],&nbsp;vertices[i][1])&nbsp;for&nbsp;i&nbsp;in&nbsp;boundary_vertices}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Коэффициент&nbsp;сдвига&nbsp;(консервативный)<br>
&nbsp;&nbsp;&nbsp;&nbsp;alpha&nbsp;=&nbsp;0.3<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;iteration&nbsp;in&nbsp;range(iterations):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_vertices&nbsp;=&nbsp;vertices.copy()<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;v_idx&nbsp;in&nbsp;interior_indices:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Целевая&nbsp;позиция<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;target_x,&nbsp;target_y&nbsp;=&nbsp;compute_ideal_position(v_idx)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Сдвигаем&nbsp;на&nbsp;долю&nbsp;alpha&nbsp;к&nbsp;целевой&nbsp;позиции<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_vertices[v_idx][0]&nbsp;=&nbsp;vertices[v_idx][0]&nbsp;+&nbsp;alpha&nbsp;*&nbsp;(target_x&nbsp;-&nbsp;vertices[v_idx][0])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_vertices[v_idx][1]&nbsp;=&nbsp;vertices[v_idx][1]&nbsp;+&nbsp;alpha&nbsp;*&nbsp;(target_y&nbsp;-&nbsp;vertices[v_idx][1])<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Проверяем&nbsp;изменение&nbsp;площади&nbsp;и&nbsp;корректируем<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;old_verts&nbsp;=&nbsp;vertices<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertices&nbsp;=&nbsp;new_vertices<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;area_after&nbsp;=&nbsp;compute_total_area()<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Если&nbsp;площадь&nbsp;изменилась&nbsp;значительно,&nbsp;масштабируем&nbsp;обратно<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;abs(area_after&nbsp;-&nbsp;area_before)&nbsp;&gt;&nbsp;area_before&nbsp;*&nbsp;0.01:&nbsp;&nbsp;#&nbsp;&gt;&nbsp;1%&nbsp;изменение<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Вычисляем&nbsp;центроид&nbsp;границы<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boundary_list&nbsp;=&nbsp;list(boundary_vertices)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;boundary_list:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bcx&nbsp;=&nbsp;sum(vertices[i][0]&nbsp;for&nbsp;i&nbsp;in&nbsp;boundary_list)&nbsp;/&nbsp;len(boundary_list)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bcy&nbsp;=&nbsp;sum(vertices[i][1]&nbsp;for&nbsp;i&nbsp;in&nbsp;boundary_list)&nbsp;/&nbsp;len(boundary_list)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bcx&nbsp;=&nbsp;sum(v[0]&nbsp;for&nbsp;v&nbsp;in&nbsp;vertices)&nbsp;/&nbsp;len(vertices)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bcy&nbsp;=&nbsp;sum(v[1]&nbsp;for&nbsp;v&nbsp;in&nbsp;vertices)&nbsp;/&nbsp;len(vertices)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Масштабируем&nbsp;внутренние&nbsp;вершины<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scale&nbsp;=&nbsp;math.sqrt(area_before&nbsp;/&nbsp;area_after)&nbsp;if&nbsp;area_after&nbsp;&gt;&nbsp;1e-10&nbsp;else&nbsp;1.0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i&nbsp;in&nbsp;interior_indices:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertices[i][0]&nbsp;=&nbsp;bcx&nbsp;+&nbsp;(vertices[i][0]&nbsp;-&nbsp;bcx)&nbsp;*&nbsp;scale<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertices[i][1]&nbsp;=&nbsp;bcy&nbsp;+&nbsp;(vertices[i][1]&nbsp;-&nbsp;bcy)&nbsp;*&nbsp;scale<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Проверяем&nbsp;что&nbsp;граничные&nbsp;вершины&nbsp;не&nbsp;сдвинулись<br>
&nbsp;&nbsp;&nbsp;&nbsp;boundary_moved&nbsp;=&nbsp;0<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i&nbsp;in&nbsp;boundary_vertices:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bx,&nbsp;by&nbsp;=&nbsp;boundary_positions_before[i]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;abs(vertices[i][0]&nbsp;-&nbsp;bx)&nbsp;&gt;&nbsp;1e-6&nbsp;or&nbsp;abs(vertices[i][1]&nbsp;-&nbsp;by)&nbsp;&gt;&nbsp;1e-6:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boundary_moved&nbsp;+=&nbsp;1<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;interior_count&nbsp;&gt;&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final_area&nbsp;=&nbsp;compute_total_area()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;area_change&nbsp;=&nbsp;(final_area&nbsp;-&nbsp;area_before)&nbsp;/&nbsp;area_before&nbsp;*&nbsp;100<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(f&quot;[cvt_smoothing]&nbsp;{iterations}&nbsp;iterations,&nbsp;{interior_count}&nbsp;interior&nbsp;vertices,&nbsp;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f&quot;boundary:&nbsp;{len(boundary_vertices)},&nbsp;area&nbsp;change:&nbsp;{area_change:.2f}%&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f&quot;{f',&nbsp;BOUNDARY&nbsp;MOVED:&nbsp;{boundary_moved}!'&nbsp;if&nbsp;boundary_moved&nbsp;else&nbsp;''}&quot;)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;vertices.astype(np.float32)<br>
<br>
<br>
def&nbsp;edge_collapse(<br>
&nbsp;&nbsp;&nbsp;&nbsp;vertices:&nbsp;np.ndarray,<br>
&nbsp;&nbsp;&nbsp;&nbsp;triangles:&nbsp;list[tuple[int,&nbsp;int,&nbsp;int]],<br>
&nbsp;&nbsp;&nbsp;&nbsp;min_edge_length:&nbsp;float,<br>
&nbsp;&nbsp;&nbsp;&nbsp;min_contour_edge_length:&nbsp;float&nbsp;=&nbsp;0.0,<br>
&nbsp;&nbsp;&nbsp;&nbsp;boundary_edges:&nbsp;set[tuple[int,&nbsp;int]]&nbsp;|&nbsp;None&nbsp;=&nbsp;None,<br>
&nbsp;&nbsp;&nbsp;&nbsp;boundary_vertices:&nbsp;set[int]&nbsp;|&nbsp;None&nbsp;=&nbsp;None,<br>
&nbsp;&nbsp;&nbsp;&nbsp;max_iterations:&nbsp;int&nbsp;=&nbsp;1000,<br>
)&nbsp;-&gt;&nbsp;tuple[np.ndarray,&nbsp;list[tuple[int,&nbsp;int,&nbsp;int]]]:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Схлопнуть&nbsp;короткие&nbsp;рёбра&nbsp;для&nbsp;упрощения&nbsp;меша.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertices:&nbsp;2D&nbsp;координаты&nbsp;вершин,&nbsp;shape&nbsp;(N,&nbsp;2).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;triangles:&nbsp;Список&nbsp;треугольников&nbsp;[(a,&nbsp;b,&nbsp;c),&nbsp;...].<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min_edge_length:&nbsp;Мин.&nbsp;длина&nbsp;внутреннего&nbsp;ребра.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min_contour_edge_length:&nbsp;Мин.&nbsp;длина&nbsp;ребра&nbsp;на&nbsp;контуре.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boundary_edges:&nbsp;Множество&nbsp;граничных&nbsp;рёбер&nbsp;(нормализованные:&nbsp;min,&nbsp;max).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boundary_vertices:&nbsp;Множество&nbsp;индексов&nbsp;граничных&nbsp;вершин&nbsp;(не&nbsp;сдвигать).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max_iterations:&nbsp;Максимум&nbsp;итераций.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(new_vertices,&nbsp;new_triangles)&nbsp;—&nbsp;упрощённая&nbsp;триангуляция.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(min_edge_length&nbsp;&lt;=&nbsp;0&nbsp;and&nbsp;min_contour_edge_length&nbsp;&lt;=&nbsp;0)&nbsp;or&nbsp;len(triangles)&nbsp;==&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;vertices,&nbsp;triangles<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;vertices&nbsp;=&nbsp;list(map(tuple,&nbsp;vertices))<br>
&nbsp;&nbsp;&nbsp;&nbsp;triangles&nbsp;=&nbsp;list(triangles)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;boundary_edges&nbsp;is&nbsp;None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boundary_edges&nbsp;=&nbsp;set()<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;boundary_vertices&nbsp;is&nbsp;None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boundary_vertices&nbsp;=&nbsp;set()<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Debug&nbsp;info<br>
&nbsp;&nbsp;&nbsp;&nbsp;edge_map&nbsp;=&nbsp;build_edge_map(triangles)<br>
&nbsp;&nbsp;&nbsp;&nbsp;all_edges&nbsp;=&nbsp;list(edge_map.keys())<br>
&nbsp;&nbsp;&nbsp;&nbsp;edge_lengths&nbsp;=&nbsp;[]<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;e0,&nbsp;e1&nbsp;in&nbsp;all_edges:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v0&nbsp;=&nbsp;vertices[e0]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v1&nbsp;=&nbsp;vertices[e1]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;length&nbsp;=&nbsp;((v1[0]&nbsp;-&nbsp;v0[0])**2&nbsp;+&nbsp;(v1[1]&nbsp;-&nbsp;v0[1])**2)**0.5<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge_lengths.append(length)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;edge_lengths:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min_len&nbsp;=&nbsp;min(edge_lengths)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max_len&nbsp;=&nbsp;max(edge_lengths)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;avg_len&nbsp;=&nbsp;sum(edge_lengths)&nbsp;/&nbsp;len(edge_lengths)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Count&nbsp;collapsible&nbsp;edges<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interior_collapsible&nbsp;=&nbsp;0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;contour_collapsible&nbsp;=&nbsp;0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;edge&nbsp;in&nbsp;all_edges:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e0,&nbsp;e1&nbsp;=&nbsp;edge<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v0&nbsp;=&nbsp;vertices[e0]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v1&nbsp;=&nbsp;vertices[e1]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;length&nbsp;=&nbsp;((v1[0]&nbsp;-&nbsp;v0[0])**2&nbsp;+&nbsp;(v1[1]&nbsp;-&nbsp;v0[1])**2)**0.5<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;edge&nbsp;in&nbsp;boundary_edges:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;min_contour_edge_length&nbsp;&gt;&nbsp;0&nbsp;and&nbsp;length&nbsp;&lt;&nbsp;min_contour_edge_length:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;contour_collapsible&nbsp;+=&nbsp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;min_edge_length&nbsp;&gt;&nbsp;0&nbsp;and&nbsp;length&nbsp;&lt;&nbsp;min_edge_length:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interior_collapsible&nbsp;+=&nbsp;1<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(f&quot;[edge_collapse]&nbsp;interior_threshold={min_edge_length:.3f},&nbsp;contour_threshold={min_contour_edge_length:.3f}&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(f&quot;[edge_collapse]&nbsp;edges={len(all_edges)},&nbsp;lengths:&nbsp;min={min_len:.3f},&nbsp;max={max_len:.3f},&nbsp;avg={avg_len:.3f}&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(f&quot;[edge_collapse]&nbsp;interior_collapsible={interior_collapsible},&nbsp;contour_collapsible={contour_collapsible}&quot;)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;collapse_count&nbsp;=&nbsp;0<br>
&nbsp;&nbsp;&nbsp;&nbsp;min_len_sq&nbsp;=&nbsp;min_edge_length&nbsp;*&nbsp;min_edge_length<br>
&nbsp;&nbsp;&nbsp;&nbsp;min_contour_len_sq&nbsp;=&nbsp;min_contour_edge_length&nbsp;*&nbsp;min_contour_edge_length<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;iteration&nbsp;in&nbsp;range(max_iterations):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Находим&nbsp;самое&nbsp;короткое&nbsp;СХЛОПЫВАЕМОЕ&nbsp;ребро<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;(учитываем&nbsp;разные&nbsp;пороги&nbsp;для&nbsp;внутренних&nbsp;и&nbsp;контурных&nbsp;рёбер)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shortest_edge&nbsp;=&nbsp;None<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shortest_len_sq&nbsp;=&nbsp;float('inf')<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shortest_is_boundary&nbsp;=&nbsp;False<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge_map&nbsp;=&nbsp;build_edge_map(triangles)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;edge&nbsp;in&nbsp;edge_map.keys():<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e0,&nbsp;e1&nbsp;=&nbsp;edge<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v0&nbsp;=&nbsp;vertices[e0]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v1&nbsp;=&nbsp;vertices[e1]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;len_sq&nbsp;=&nbsp;(v1[0]&nbsp;-&nbsp;v0[0])**2&nbsp;+&nbsp;(v1[1]&nbsp;-&nbsp;v0[1])**2<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is_boundary&nbsp;=&nbsp;edge&nbsp;in&nbsp;boundary_edges<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;threshold_sq&nbsp;=&nbsp;min_contour_len_sq&nbsp;if&nbsp;is_boundary&nbsp;else&nbsp;min_len_sq<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Пропускаем&nbsp;если&nbsp;порог&nbsp;нулевой<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;threshold_sq&nbsp;&lt;=&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Проверяем,&nbsp;короче&nbsp;ли&nbsp;ребро&nbsp;порога<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;len_sq&nbsp;&gt;=&nbsp;threshold_sq:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;len_sq&nbsp;&lt;&nbsp;shortest_len_sq:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shortest_len_sq&nbsp;=&nbsp;len_sq<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shortest_edge&nbsp;=&nbsp;edge<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shortest_is_boundary&nbsp;=&nbsp;is_boundary<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;shortest_edge&nbsp;is&nbsp;None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e0,&nbsp;e1&nbsp;=&nbsp;shortest_edge<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is_boundary_edge&nbsp;=&nbsp;shortest_edge&nbsp;in&nbsp;boundary_edges<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Схлопываем&nbsp;ребро:&nbsp;определяем&nbsp;какую&nbsp;вершину&nbsp;оставить<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e0_is_boundary&nbsp;=&nbsp;e0&nbsp;in&nbsp;boundary_vertices<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e1_is_boundary&nbsp;=&nbsp;e1&nbsp;in&nbsp;boundary_vertices<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;e0_is_boundary&nbsp;and&nbsp;e1_is_boundary&nbsp;and&nbsp;not&nbsp;is_boundary_edge:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Обе&nbsp;вершины&nbsp;граничные,&nbsp;но&nbsp;ребро&nbsp;внутреннее&nbsp;—&nbsp;не&nbsp;схлопываем<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;is_boundary_edge:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Граничное&nbsp;ребро&nbsp;—&nbsp;сдвигаем&nbsp;обе&nbsp;вершины&nbsp;в&nbsp;середину&nbsp;(меняем&nbsp;форму&nbsp;контура)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keep_idx,&nbsp;remove_idx&nbsp;=&nbsp;e0,&nbsp;e1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mid_x&nbsp;=&nbsp;(vertices[e0][0]&nbsp;+&nbsp;vertices[e1][0])&nbsp;/&nbsp;2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mid_y&nbsp;=&nbsp;(vertices[e0][1]&nbsp;+&nbsp;vertices[e1][1])&nbsp;/&nbsp;2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertices[keep_idx]&nbsp;=&nbsp;(mid_x,&nbsp;mid_y)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif&nbsp;e0_is_boundary:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;e0&nbsp;граничная&nbsp;—&nbsp;оставляем&nbsp;e0,&nbsp;удаляем&nbsp;e1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keep_idx,&nbsp;remove_idx&nbsp;=&nbsp;e0,&nbsp;e1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Не&nbsp;двигаем&nbsp;граничную&nbsp;вершину<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif&nbsp;e1_is_boundary:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;e1&nbsp;граничная&nbsp;—&nbsp;оставляем&nbsp;e1,&nbsp;удаляем&nbsp;e0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keep_idx,&nbsp;remove_idx&nbsp;=&nbsp;e1,&nbsp;e0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Не&nbsp;двигаем&nbsp;граничную&nbsp;вершину<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Обе&nbsp;внутренние&nbsp;—&nbsp;сдвигаем&nbsp;в&nbsp;середину<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keep_idx,&nbsp;remove_idx&nbsp;=&nbsp;e0,&nbsp;e1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mid_x&nbsp;=&nbsp;(vertices[e0][0]&nbsp;+&nbsp;vertices[e1][0])&nbsp;/&nbsp;2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mid_y&nbsp;=&nbsp;(vertices[e0][1]&nbsp;+&nbsp;vertices[e1][1])&nbsp;/&nbsp;2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertices[keep_idx]&nbsp;=&nbsp;(mid_x,&nbsp;mid_y)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Заменяем&nbsp;remove_idx&nbsp;на&nbsp;keep_idx&nbsp;во&nbsp;всех&nbsp;треугольниках<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_triangles&nbsp;=&nbsp;[]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;tri&nbsp;in&nbsp;triangles:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a,&nbsp;b,&nbsp;c&nbsp;=&nbsp;tri<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;a&nbsp;==&nbsp;remove_idx:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;keep_idx<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;b&nbsp;==&nbsp;remove_idx:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;=&nbsp;keep_idx<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;c&nbsp;==&nbsp;remove_idx:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;keep_idx<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Проверяем&nbsp;что&nbsp;треугольник&nbsp;не&nbsp;вырожден&nbsp;(все&nbsp;вершины&nbsp;разные)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;a&nbsp;!=&nbsp;b&nbsp;and&nbsp;b&nbsp;!=&nbsp;c&nbsp;and&nbsp;c&nbsp;!=&nbsp;a:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_triangles.append((a,&nbsp;b,&nbsp;c))<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;triangles&nbsp;=&nbsp;new_triangles<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;collapse_count&nbsp;+=&nbsp;1<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Обновляем&nbsp;boundary_edges:&nbsp;заменяем&nbsp;remove_idx&nbsp;на&nbsp;keep_idx<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_boundary_edges&nbsp;=&nbsp;set()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;be0,&nbsp;be1&nbsp;in&nbsp;boundary_edges:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;be0&nbsp;==&nbsp;remove_idx:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;be0&nbsp;=&nbsp;keep_idx<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;be1&nbsp;==&nbsp;remove_idx:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;be1&nbsp;=&nbsp;keep_idx<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;be0&nbsp;!=&nbsp;be1:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_boundary_edges.add((min(be0,&nbsp;be1),&nbsp;max(be0,&nbsp;be1)))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boundary_edges&nbsp;=&nbsp;new_boundary_edges<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Обновляем&nbsp;boundary_vertices:&nbsp;заменяем&nbsp;remove_idx&nbsp;на&nbsp;keep_idx<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;remove_idx&nbsp;in&nbsp;boundary_vertices:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boundary_vertices.discard(remove_idx)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boundary_vertices.add(keep_idx)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;collapse_count&nbsp;&gt;&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Удаляем&nbsp;неиспользуемые&nbsp;вершины&nbsp;и&nbsp;перенумеровываем<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;used_vertices&nbsp;=&nbsp;set()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;tri&nbsp;in&nbsp;triangles:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;used_vertices.update(tri)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;len(used_vertices)&nbsp;&lt;&nbsp;len(vertices):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Создаём&nbsp;маппинг&nbsp;старых&nbsp;индексов&nbsp;в&nbsp;новые<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;old_to_new&nbsp;=&nbsp;{}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_vertices&nbsp;=&nbsp;[]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;old_idx&nbsp;in&nbsp;sorted(used_vertices):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;old_to_new[old_idx]&nbsp;=&nbsp;len(new_vertices)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_vertices.append(vertices[old_idx])<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Перенумеровываем&nbsp;треугольники<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;triangles&nbsp;=&nbsp;[<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(old_to_new[a],&nbsp;old_to_new[b],&nbsp;old_to_new[c])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;a,&nbsp;b,&nbsp;c&nbsp;in&nbsp;triangles<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertices&nbsp;=&nbsp;new_vertices<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(f&quot;[edge_collapse]&nbsp;{collapse_count}&nbsp;collapses,&nbsp;{len(vertices)}&nbsp;vertices,&nbsp;{len(triangles)}&nbsp;triangles&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;else:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(f&quot;[edge_collapse]&nbsp;no&nbsp;collapses&nbsp;performed&quot;)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;np.array(vertices,&nbsp;dtype=np.float32),&nbsp;triangles<br>
<br>
<br>
def&nbsp;extract_boundary_edges(polygon_size:&nbsp;int)&nbsp;-&gt;&nbsp;set[tuple[int,&nbsp;int]]:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Извлечь&nbsp;граничные&nbsp;рёбра&nbsp;полигона&nbsp;(индексы&nbsp;0..n-1).&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;edges&nbsp;=&nbsp;set()<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i&nbsp;in&nbsp;range(polygon_size):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;=&nbsp;(i&nbsp;+&nbsp;1)&nbsp;%&nbsp;polygon_size<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edges.add((min(i,&nbsp;j),&nbsp;max(i,&nbsp;j)))<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;edges<br>
<br>
<br>
def&nbsp;refine_triangulation(<br>
&nbsp;&nbsp;&nbsp;&nbsp;vertices:&nbsp;np.ndarray,<br>
&nbsp;&nbsp;&nbsp;&nbsp;triangles:&nbsp;list[tuple[int,&nbsp;int,&nbsp;int]],<br>
&nbsp;&nbsp;&nbsp;&nbsp;max_edge_length:&nbsp;float,<br>
&nbsp;&nbsp;&nbsp;&nbsp;max_iterations:&nbsp;int&nbsp;=&nbsp;100,<br>
&nbsp;&nbsp;&nbsp;&nbsp;max_vertex_valence:&nbsp;int&nbsp;=&nbsp;0,<br>
)&nbsp;-&gt;&nbsp;tuple[np.ndarray,&nbsp;list[tuple[int,&nbsp;int,&nbsp;int]]]:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Улучшить&nbsp;триангуляцию,&nbsp;разбивая&nbsp;большие&nbsp;треугольники&nbsp;и&nbsp;снижая&nbsp;валентность&nbsp;вершин.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Добавляет&nbsp;точки&nbsp;на&nbsp;середине&nbsp;рёбер,&nbsp;превышающих&nbsp;max_edge_length,<br>
&nbsp;&nbsp;&nbsp;&nbsp;а&nbsp;также&nbsp;разбивает&nbsp;рёбра&nbsp;от&nbsp;вершин&nbsp;с&nbsp;высокой&nbsp;валентностью.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertices:&nbsp;2D&nbsp;координаты&nbsp;вершин,&nbsp;shape&nbsp;(N,&nbsp;2).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;triangles:&nbsp;Список&nbsp;треугольников&nbsp;[(a,&nbsp;b,&nbsp;c),&nbsp;...].<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max_edge_length:&nbsp;Максимальная&nbsp;длина&nbsp;ребра&nbsp;(0&nbsp;=&nbsp;без&nbsp;ограничения).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max_iterations:&nbsp;Максимум&nbsp;итераций&nbsp;разбиения.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max_vertex_valence:&nbsp;Макс.&nbsp;количество&nbsp;треугольников&nbsp;на&nbsp;вершину&nbsp;(0&nbsp;=&nbsp;без&nbsp;ограничения).<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(new_vertices,&nbsp;new_triangles)&nbsp;—&nbsp;улучшенная&nbsp;триангуляция.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;vertices&nbsp;=&nbsp;list(map(tuple,&nbsp;vertices))&nbsp;&nbsp;#&nbsp;список&nbsp;для&nbsp;добавления<br>
&nbsp;&nbsp;&nbsp;&nbsp;triangles&nbsp;=&nbsp;list(triangles)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;split_edge(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge:&nbsp;tuple[int,&nbsp;int],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;verts:&nbsp;list[tuple[float,&nbsp;float]],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tris:&nbsp;list[tuple[int,&nbsp;int,&nbsp;int]],<br>
&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;-&gt;&nbsp;tuple[list[tuple[float,&nbsp;float]],&nbsp;list[tuple[int,&nbsp;int,&nbsp;int]]]:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Разбить&nbsp;ребро,&nbsp;добавив&nbsp;вершину&nbsp;на&nbsp;середине.&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e0,&nbsp;e1&nbsp;=&nbsp;edge<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mid_x&nbsp;=&nbsp;(verts[e0][0]&nbsp;+&nbsp;verts[e1][0])&nbsp;/&nbsp;2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mid_y&nbsp;=&nbsp;(verts[e0][1]&nbsp;+&nbsp;verts[e1][1])&nbsp;/&nbsp;2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_vertex_idx&nbsp;=&nbsp;len(verts)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;verts.append((mid_x,&nbsp;mid_y))<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Находим&nbsp;все&nbsp;треугольники&nbsp;с&nbsp;этим&nbsp;ребром<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tris_to_split&nbsp;=&nbsp;[]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;tri_idx,&nbsp;tri&nbsp;in&nbsp;enumerate(tris):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge_set&nbsp;=&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(min(tri[0],&nbsp;tri[1]),&nbsp;max(tri[0],&nbsp;tri[1])),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(min(tri[1],&nbsp;tri[2]),&nbsp;max(tri[1],&nbsp;tri[2])),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(min(tri[2],&nbsp;tri[0]),&nbsp;max(tri[2],&nbsp;tri[0])),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;edge&nbsp;in&nbsp;edge_set:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tris_to_split.append(tri_idx)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Разбиваем&nbsp;каждый&nbsp;треугольник&nbsp;на&nbsp;два<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_triangles&nbsp;=&nbsp;[]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;tri_idx,&nbsp;tri&nbsp;in&nbsp;enumerate(tris):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;tri_idx&nbsp;in&nbsp;tris_to_split:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;opposite&nbsp;=&nbsp;-1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;v&nbsp;in&nbsp;tri:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;v&nbsp;!=&nbsp;e0&nbsp;and&nbsp;v&nbsp;!=&nbsp;e1:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;opposite&nbsp;=&nbsp;v<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;opposite&nbsp;&gt;=&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_triangles.append((e0,&nbsp;new_vertex_idx,&nbsp;opposite))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_triangles.append((new_vertex_idx,&nbsp;e1,&nbsp;opposite))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_triangles.append(tri)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;verts,&nbsp;new_triangles<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;iteration&nbsp;in&nbsp;range(max_iterations):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;made_split&nbsp;=&nbsp;False<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Фаза&nbsp;1:&nbsp;Разбиение&nbsp;по&nbsp;длине&nbsp;рёбер<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;max_edge_length&nbsp;&gt;&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;longest_edge&nbsp;=&nbsp;None<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;longest_length&nbsp;=&nbsp;0.0<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;tri&nbsp;in&nbsp;triangles:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;edge_idx&nbsp;in&nbsp;range(3):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v0_idx&nbsp;=&nbsp;tri[edge_idx]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v1_idx&nbsp;=&nbsp;tri[(edge_idx&nbsp;+&nbsp;1)&nbsp;%&nbsp;3]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v0&nbsp;=&nbsp;vertices[v0_idx]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v1&nbsp;=&nbsp;vertices[v1_idx]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;length&nbsp;=&nbsp;((v1[0]&nbsp;-&nbsp;v0[0])**2&nbsp;+&nbsp;(v1[1]&nbsp;-&nbsp;v0[1])**2)**0.5<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;length&nbsp;&gt;&nbsp;longest_length:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;longest_length&nbsp;=&nbsp;length<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;longest_edge&nbsp;=&nbsp;(min(v0_idx,&nbsp;v1_idx),&nbsp;max(v0_idx,&nbsp;v1_idx))<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;longest_length&nbsp;&gt;&nbsp;max_edge_length&nbsp;and&nbsp;longest_edge&nbsp;is&nbsp;not&nbsp;None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertices,&nbsp;triangles&nbsp;=&nbsp;split_edge(longest_edge,&nbsp;vertices,&nbsp;triangles)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;made_split&nbsp;=&nbsp;True<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue&nbsp;&nbsp;#&nbsp;Перезапускаем&nbsp;итерацию<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Фаза&nbsp;2:&nbsp;Ограничение&nbsp;валентности&nbsp;вершин&nbsp;(TODO:&nbsp;реализовать)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Текущий&nbsp;алгоритм&nbsp;разбиения&nbsp;рёбер&nbsp;не&nbsp;уменьшает&nbsp;валентность.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Для&nbsp;корректной&nbsp;работы&nbsp;нужен&nbsp;более&nbsp;сложный&nbsp;подход&nbsp;с&nbsp;перетриангуляцией.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Пока&nbsp;параметр&nbsp;max_vertex_valence&nbsp;не&nbsp;используется.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Нет&nbsp;изменений&nbsp;—&nbsp;завершаем<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;made_split:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;np.array(vertices,&nbsp;dtype=np.float32),&nbsp;triangles<br>
<br>
<br>
def&nbsp;ear_clipping_refined(<br>
&nbsp;&nbsp;&nbsp;&nbsp;vertices:&nbsp;np.ndarray,<br>
&nbsp;&nbsp;&nbsp;&nbsp;max_edge_length:&nbsp;float&nbsp;=&nbsp;1.0,<br>
&nbsp;&nbsp;&nbsp;&nbsp;min_edge_length:&nbsp;float&nbsp;=&nbsp;0.0,<br>
&nbsp;&nbsp;&nbsp;&nbsp;min_contour_edge_length:&nbsp;float&nbsp;=&nbsp;0.0,<br>
&nbsp;&nbsp;&nbsp;&nbsp;max_vertex_valence:&nbsp;int&nbsp;=&nbsp;0,<br>
&nbsp;&nbsp;&nbsp;&nbsp;use_delaunay_flip:&nbsp;bool&nbsp;=&nbsp;True,<br>
&nbsp;&nbsp;&nbsp;&nbsp;use_valence_flip:&nbsp;bool&nbsp;=&nbsp;False,<br>
&nbsp;&nbsp;&nbsp;&nbsp;use_angle_flip:&nbsp;bool&nbsp;=&nbsp;False,<br>
&nbsp;&nbsp;&nbsp;&nbsp;use_cvt_smoothing:&nbsp;bool&nbsp;=&nbsp;False,<br>
&nbsp;&nbsp;&nbsp;&nbsp;use_second_pass:&nbsp;bool&nbsp;=&nbsp;False,<br>
)&nbsp;-&gt;&nbsp;tuple[np.ndarray,&nbsp;np.ndarray]:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Триангулировать&nbsp;полигон&nbsp;с&nbsp;ограничением&nbsp;размера&nbsp;треугольников.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertices:&nbsp;2D&nbsp;координаты&nbsp;вершин&nbsp;полигона&nbsp;(CCW),&nbsp;shape&nbsp;(N,&nbsp;2).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max_edge_length:&nbsp;Максимальная&nbsp;длина&nbsp;ребра&nbsp;(0&nbsp;=&nbsp;без&nbsp;ограничения).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min_edge_length:&nbsp;Мин.&nbsp;длина&nbsp;внутреннего&nbsp;ребра&nbsp;для&nbsp;edge&nbsp;collapse&nbsp;(0&nbsp;=&nbsp;без&nbsp;collapse).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min_contour_edge_length:&nbsp;Мин.&nbsp;длина&nbsp;ребра&nbsp;на&nbsp;контуре&nbsp;(0&nbsp;=&nbsp;без&nbsp;collapse).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max_vertex_valence:&nbsp;Макс.&nbsp;количество&nbsp;треугольников&nbsp;на&nbsp;вершину&nbsp;(0&nbsp;=&nbsp;без&nbsp;ограничения).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use_delaunay_flip:&nbsp;Применить&nbsp;Delaunay&nbsp;edge&nbsp;flipping.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use_valence_flip:&nbsp;Применить&nbsp;edge&nbsp;flipping&nbsp;для&nbsp;уменьшения&nbsp;валентности.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use_angle_flip:&nbsp;Применить&nbsp;edge&nbsp;flipping&nbsp;для&nbsp;максимизации&nbsp;минимального&nbsp;угла.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use_cvt_smoothing:&nbsp;Применить&nbsp;CVT&nbsp;(Centroidal&nbsp;Voronoi&nbsp;Tessellation)&nbsp;smoothing.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use_second_pass:&nbsp;Повторный&nbsp;проход&nbsp;flips&nbsp;+&nbsp;smoothing&nbsp;после&nbsp;edge&nbsp;collapse.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vertices,&nbsp;triangles)&nbsp;—&nbsp;вершины&nbsp;могут&nbsp;содержать&nbsp;добавленные&nbsp;точки.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Базовая&nbsp;триангуляция<br>
&nbsp;&nbsp;&nbsp;&nbsp;triangles&nbsp;=&nbsp;ear_clip(vertices)<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;triangles:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;vertices,&nbsp;np.array([],&nbsp;dtype=np.int32).reshape(0,&nbsp;3)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Разбиваем&nbsp;большие&nbsp;треугольники<br>
&nbsp;&nbsp;&nbsp;&nbsp;refined_verts,&nbsp;refined_tris&nbsp;=&nbsp;refine_triangulation(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertices,&nbsp;triangles,&nbsp;max_edge_length,&nbsp;max_vertex_valence=max_vertex_valence<br>
&nbsp;&nbsp;&nbsp;&nbsp;)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Граничные&nbsp;рёбра&nbsp;исходного&nbsp;полигона&nbsp;(не&nbsp;переворачиваем)<br>
&nbsp;&nbsp;&nbsp;&nbsp;boundary&nbsp;=&nbsp;extract_boundary_edges(len(vertices))<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Граничные&nbsp;вершины&nbsp;—&nbsp;исходные&nbsp;вершины&nbsp;полигона<br>
&nbsp;&nbsp;&nbsp;&nbsp;boundary_vertices&nbsp;=&nbsp;set(range(len(vertices)))<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Также&nbsp;помечаем&nbsp;вершины,&nbsp;добавленные&nbsp;на&nbsp;граничных&nbsp;рёбрах<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;(после&nbsp;refinement&nbsp;новые&nbsp;вершины&nbsp;на&nbsp;границе&nbsp;тоже&nbsp;должны&nbsp;быть&nbsp;зафиксированы)<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;v_idx&nbsp;in&nbsp;range(len(vertices),&nbsp;len(refined_verts)):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Проверяем,&nbsp;лежит&nbsp;ли&nbsp;вершина&nbsp;на&nbsp;каком-либо&nbsp;граничном&nbsp;ребре<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx,&nbsp;vy&nbsp;=&nbsp;refined_verts[v_idx]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;e0,&nbsp;e1&nbsp;in&nbsp;boundary:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Точки&nbsp;ребра<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x0,&nbsp;y0&nbsp;=&nbsp;refined_verts[e0]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x1,&nbsp;y1&nbsp;=&nbsp;refined_verts[e1]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Проверяем,&nbsp;лежит&nbsp;ли&nbsp;точка&nbsp;на&nbsp;отрезке<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Вектор&nbsp;ребра<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dx,&nbsp;dy&nbsp;=&nbsp;x1&nbsp;-&nbsp;x0,&nbsp;y1&nbsp;-&nbsp;y0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge_len_sq&nbsp;=&nbsp;dx&nbsp;*&nbsp;dx&nbsp;+&nbsp;dy&nbsp;*&nbsp;dy<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;edge_len_sq&nbsp;&lt;&nbsp;1e-10:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Проекция&nbsp;точки&nbsp;на&nbsp;прямую<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t&nbsp;=&nbsp;((vx&nbsp;-&nbsp;x0)&nbsp;*&nbsp;dx&nbsp;+&nbsp;(vy&nbsp;-&nbsp;y0)&nbsp;*&nbsp;dy)&nbsp;/&nbsp;edge_len_sq<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;t&nbsp;&lt;&nbsp;-0.01&nbsp;or&nbsp;t&nbsp;&gt;&nbsp;1.01:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Расстояние&nbsp;до&nbsp;прямой<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proj_x&nbsp;=&nbsp;x0&nbsp;+&nbsp;t&nbsp;*&nbsp;dx<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proj_y&nbsp;=&nbsp;y0&nbsp;+&nbsp;t&nbsp;*&nbsp;dy<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dist_sq&nbsp;=&nbsp;(vx&nbsp;-&nbsp;proj_x)&nbsp;**&nbsp;2&nbsp;+&nbsp;(vy&nbsp;-&nbsp;proj_y)&nbsp;**&nbsp;2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;dist_sq&nbsp;&lt;&nbsp;1e-6:&nbsp;&nbsp;#&nbsp;На&nbsp;ребре<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boundary_vertices.add(v_idx)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Delaunay&nbsp;optimization<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;use_delaunay_flip&nbsp;and&nbsp;len(refined_tris)&nbsp;&gt;=&nbsp;2:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;refined_tris&nbsp;=&nbsp;delaunay_flip(refined_verts,&nbsp;refined_tris,&nbsp;boundary)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Valence&nbsp;optimization<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;use_valence_flip&nbsp;and&nbsp;len(refined_tris)&nbsp;&gt;=&nbsp;2:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;refined_tris&nbsp;=&nbsp;valence_flip(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;refined_verts,&nbsp;refined_tris,&nbsp;boundary,&nbsp;max_vertex_valence<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Angle&nbsp;optimization<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;use_angle_flip&nbsp;and&nbsp;len(refined_tris)&nbsp;&gt;=&nbsp;2:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;refined_tris&nbsp;=&nbsp;angle_flip(refined_verts,&nbsp;refined_tris,&nbsp;boundary)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;CVT&nbsp;smoothing&nbsp;(только&nbsp;внутренние&nbsp;вершины)<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;use_cvt_smoothing&nbsp;and&nbsp;len(refined_verts)&nbsp;&gt;&nbsp;len(vertices):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;refined_verts&nbsp;=&nbsp;cvt_smoothing(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;refined_verts,&nbsp;refined_tris,&nbsp;boundary_vertices<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Edge&nbsp;collapse&nbsp;(схлопывание&nbsp;коротких&nbsp;рёбер)<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Вычисляем&nbsp;граничные&nbsp;рёбра&nbsp;как&nbsp;рёбра&nbsp;с&nbsp;одним&nbsp;соседним&nbsp;треугольником<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;min_edge_length&nbsp;&gt;&nbsp;0&nbsp;or&nbsp;min_contour_edge_length&nbsp;&gt;&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge_map&nbsp;=&nbsp;build_edge_map(refined_tris)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;actual_boundary_edges&nbsp;=&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge&nbsp;for&nbsp;edge,&nbsp;tris&nbsp;in&nbsp;edge_map.items()&nbsp;if&nbsp;len(tris)&nbsp;==&nbsp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Граничные&nbsp;вершины&nbsp;—&nbsp;вершины&nbsp;на&nbsp;граничных&nbsp;рёбрах<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;actual_boundary_vertices&nbsp;=&nbsp;set()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;e0,&nbsp;e1&nbsp;in&nbsp;actual_boundary_edges:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;actual_boundary_vertices.add(e0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;actual_boundary_vertices.add(e1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;refined_verts,&nbsp;refined_tris&nbsp;=&nbsp;edge_collapse(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;refined_verts,&nbsp;refined_tris,&nbsp;min_edge_length,&nbsp;min_contour_edge_length,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;actual_boundary_edges,&nbsp;actual_boundary_vertices<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Второй&nbsp;проход&nbsp;(после&nbsp;edge&nbsp;collapse)<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;use_second_pass&nbsp;and&nbsp;len(refined_tris)&nbsp;&gt;=&nbsp;2:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&quot;[second_pass]&nbsp;Starting...&quot;)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Пересчитываем&nbsp;граничные&nbsp;рёбра&nbsp;после&nbsp;collapse<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge_map&nbsp;=&nbsp;build_edge_map(refined_tris)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boundary&nbsp;=&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge&nbsp;for&nbsp;edge,&nbsp;tris&nbsp;in&nbsp;edge_map.items()&nbsp;if&nbsp;len(tris)&nbsp;==&nbsp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Пересчитываем&nbsp;граничные&nbsp;вершины<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boundary_vertices&nbsp;=&nbsp;set()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;e0,&nbsp;e1&nbsp;in&nbsp;boundary:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boundary_vertices.add(e0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boundary_vertices.add(e1)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Delaunay&nbsp;flip&nbsp;(второй&nbsp;проход)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;use_delaunay_flip:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;refined_tris&nbsp;=&nbsp;delaunay_flip(refined_verts,&nbsp;refined_tris,&nbsp;boundary)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Valence&nbsp;optimization&nbsp;(второй&nbsp;проход)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;use_valence_flip:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;refined_tris&nbsp;=&nbsp;valence_flip(refined_verts,&nbsp;refined_tris,&nbsp;boundary,&nbsp;max_vertex_valence)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Angle&nbsp;optimization&nbsp;(второй&nbsp;проход)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;use_angle_flip:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;refined_tris&nbsp;=&nbsp;angle_flip(refined_verts,&nbsp;refined_tris,&nbsp;boundary)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;CVT&nbsp;smoothing&nbsp;(второй&nbsp;проход)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;use_cvt_smoothing&nbsp;and&nbsp;len(boundary_vertices)&nbsp;&lt;&nbsp;len(refined_verts):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;refined_verts&nbsp;=&nbsp;cvt_smoothing(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;refined_verts,&nbsp;refined_tris,&nbsp;boundary_vertices<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&quot;[second_pass]&nbsp;Done&quot;)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;refined_verts,&nbsp;np.array(refined_tris,&nbsp;dtype=np.int32)<br>
<br>
<br>
def&nbsp;transform_to_3d(<br>
&nbsp;&nbsp;&nbsp;&nbsp;points_2d:&nbsp;np.ndarray,<br>
&nbsp;&nbsp;&nbsp;&nbsp;origin:&nbsp;np.ndarray,<br>
&nbsp;&nbsp;&nbsp;&nbsp;u_axis:&nbsp;np.ndarray,<br>
&nbsp;&nbsp;&nbsp;&nbsp;v_axis:&nbsp;np.ndarray,<br>
)&nbsp;-&gt;&nbsp;np.ndarray:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Преобразовать&nbsp;2D&nbsp;точки&nbsp;обратно&nbsp;в&nbsp;3D.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;points_2d:&nbsp;np.ndarray&nbsp;shape&nbsp;(N,&nbsp;2).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;origin:&nbsp;Центр&nbsp;плоскости&nbsp;в&nbsp;3D.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u_axis:&nbsp;U&nbsp;ось&nbsp;плоскости.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v_axis:&nbsp;V&nbsp;ось&nbsp;плоскости.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;np.ndarray&nbsp;shape&nbsp;(N,&nbsp;3).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;=&nbsp;len(points_2d)<br>
&nbsp;&nbsp;&nbsp;&nbsp;points_3d&nbsp;=&nbsp;np.zeros((n,&nbsp;3),&nbsp;dtype=np.float32)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i&nbsp;in&nbsp;range(n):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u,&nbsp;v&nbsp;=&nbsp;points_2d[i]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;points_3d[i]&nbsp;=&nbsp;origin&nbsp;+&nbsp;u&nbsp;*&nbsp;u_axis&nbsp;+&nbsp;v&nbsp;*&nbsp;v_axis<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;points_3d<br>
<br>
<br>
def&nbsp;build_2d_basis(normal:&nbsp;np.ndarray)&nbsp;-&gt;&nbsp;tuple[np.ndarray,&nbsp;np.ndarray]:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Построить&nbsp;ортонормальный&nbsp;базис&nbsp;(U,&nbsp;V)&nbsp;перпендикулярный&nbsp;нормали.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;normal:&nbsp;Нормаль&nbsp;плоскости&nbsp;(3D&nbsp;вектор).<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(u_axis,&nbsp;v_axis)&nbsp;—&nbsp;ортонормальные&nbsp;векторы&nbsp;на&nbsp;плоскости.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;normal&nbsp;=&nbsp;normal&nbsp;/&nbsp;np.linalg.norm(normal)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Выбираем&nbsp;вектор,&nbsp;не&nbsp;параллельный&nbsp;нормали<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;abs(normal[0])&nbsp;&lt;&nbsp;0.9:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ref&nbsp;=&nbsp;np.array([1.0,&nbsp;0.0,&nbsp;0.0])<br>
&nbsp;&nbsp;&nbsp;&nbsp;else:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ref&nbsp;=&nbsp;np.array([0.0,&nbsp;1.0,&nbsp;0.0])<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;U&nbsp;=&nbsp;ref&nbsp;×&nbsp;normal&nbsp;(нормализованный)<br>
&nbsp;&nbsp;&nbsp;&nbsp;u_axis&nbsp;=&nbsp;np.cross(ref,&nbsp;normal)<br>
&nbsp;&nbsp;&nbsp;&nbsp;u_axis&nbsp;=&nbsp;u_axis&nbsp;/&nbsp;np.linalg.norm(u_axis)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;V&nbsp;=&nbsp;normal&nbsp;×&nbsp;U<br>
&nbsp;&nbsp;&nbsp;&nbsp;v_axis&nbsp;=&nbsp;np.cross(normal,&nbsp;u_axis)<br>
&nbsp;&nbsp;&nbsp;&nbsp;v_axis&nbsp;=&nbsp;v_axis&nbsp;/&nbsp;np.linalg.norm(v_axis)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;u_axis.astype(np.float32),&nbsp;v_axis.astype(np.float32)<br>
<!-- END SCAT CODE -->
</body>
</html>
