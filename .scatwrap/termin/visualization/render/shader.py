<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>termin/visualization/render/shader.py</title>
</head>
<body>
<!-- BEGIN SCAT CODE -->
&quot;&quot;&quot;Shader&nbsp;wrapper&nbsp;delegating&nbsp;compilation&nbsp;and&nbsp;uniform&nbsp;uploads&nbsp;to&nbsp;a&nbsp;graphics&nbsp;backend.&quot;&quot;&quot;<br>
<br>
from&nbsp;__future__&nbsp;import&nbsp;annotations<br>
<br>
from&nbsp;pathlib&nbsp;import&nbsp;Path<br>
from&nbsp;typing&nbsp;import&nbsp;Any,&nbsp;Optional<br>
<br>
import&nbsp;numpy&nbsp;as&nbsp;np<br>
<br>
from&nbsp;termin.visualization.platform.backends&nbsp;import&nbsp;get_default_graphics_backend<br>
from&nbsp;termin.visualization.platform.backends.base&nbsp;import&nbsp;GraphicsBackend,&nbsp;ShaderHandle<br>
<br>
<br>
class&nbsp;ShaderCompilationError(RuntimeError):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Raised&nbsp;when&nbsp;GLSL&nbsp;compilation&nbsp;or&nbsp;program&nbsp;linking&nbsp;fails.&quot;&quot;&quot;<br>
<br>
<br>
class&nbsp;ShaderProgram:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;A&nbsp;GLSL&nbsp;shader&nbsp;program&nbsp;(vertex&nbsp;+&nbsp;fragment).<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Uniform&nbsp;setters&nbsp;inside&nbsp;the&nbsp;class&nbsp;assume&nbsp;column-major&nbsp;matrices&nbsp;and&nbsp;they&nbsp;set&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;combined&nbsp;MVP&nbsp;transform&nbsp;``P&nbsp;*&nbsp;V&nbsp;*&nbsp;M``&nbsp;in&nbsp;homogeneous&nbsp;coordinates.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;__init__(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertex_source:&nbsp;str,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fragment_source:&nbsp;str,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;geometry_source:&nbsp;str&nbsp;|&nbsp;None&nbsp;=&nbsp;None<br>
&nbsp;&nbsp;&nbsp;&nbsp;):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.vertex_source&nbsp;=&nbsp;vertex_source<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.fragment_source&nbsp;=&nbsp;fragment_source<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.geometry_source&nbsp;=&nbsp;geometry_source<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._compiled&nbsp;=&nbsp;False<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._handle:&nbsp;ShaderHandle&nbsp;|&nbsp;None&nbsp;=&nbsp;None<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._backend:&nbsp;GraphicsBackend&nbsp;|&nbsp;None&nbsp;=&nbsp;None<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;__post_init__(self):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._handle&nbsp;=&nbsp;None<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._backend&nbsp;=&nbsp;None<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;@staticmethod<br>
&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;default_shader()&nbsp;-&gt;&nbsp;&quot;ShaderProgram&quot;:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vert&nbsp;=&nbsp;&quot;&quot;&quot;#version&nbsp;330&nbsp;core<br>
<br>
layout(location&nbsp;=&nbsp;0)&nbsp;in&nbsp;vec3&nbsp;a_position;<br>
layout(location&nbsp;=&nbsp;1)&nbsp;in&nbsp;vec3&nbsp;a_normal;<br>
<br>
uniform&nbsp;mat4&nbsp;u_model;<br>
uniform&nbsp;mat4&nbsp;u_view;<br>
uniform&nbsp;mat4&nbsp;u_projection;<br>
<br>
out&nbsp;vec3&nbsp;v_world_pos;<br>
out&nbsp;vec3&nbsp;v_normal;<br>
<br>
void&nbsp;main()&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec4&nbsp;world&nbsp;=&nbsp;u_model&nbsp;*&nbsp;vec4(a_position,&nbsp;1.0);<br>
&nbsp;&nbsp;&nbsp;&nbsp;v_world_pos&nbsp;=&nbsp;world.xyz;<br>
&nbsp;&nbsp;&nbsp;&nbsp;v_normal&nbsp;=&nbsp;mat3(transpose(inverse(u_model)))&nbsp;*&nbsp;a_normal;<br>
&nbsp;&nbsp;&nbsp;&nbsp;gl_Position&nbsp;=&nbsp;u_projection&nbsp;*&nbsp;u_view&nbsp;*&nbsp;world;<br>
}<br>
&quot;&quot;&quot;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;frag&nbsp;=&nbsp;&quot;&quot;&quot;#version&nbsp;330&nbsp;core<br>
<br>
in&nbsp;vec3&nbsp;v_world_pos;<br>
in&nbsp;vec3&nbsp;v_normal;<br>
<br>
uniform&nbsp;vec4&nbsp;u_color;&nbsp;//&nbsp;RGBA&nbsp;базового&nbsp;материала<br>
<br>
const&nbsp;int&nbsp;LIGHT_TYPE_DIRECTIONAL&nbsp;=&nbsp;0;<br>
const&nbsp;int&nbsp;LIGHT_TYPE_POINT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;1;<br>
const&nbsp;int&nbsp;LIGHT_TYPE_SPOT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;2;<br>
const&nbsp;int&nbsp;LIGHT_TYPE_AMBIENT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;3;<br>
<br>
const&nbsp;int&nbsp;MAX_LIGHTS&nbsp;=&nbsp;8;<br>
<br>
uniform&nbsp;int&nbsp;&nbsp;&nbsp;u_light_count;<br>
uniform&nbsp;int&nbsp;&nbsp;&nbsp;u_light_type[MAX_LIGHTS];<br>
uniform&nbsp;vec3&nbsp;&nbsp;u_light_color[MAX_LIGHTS];<br>
uniform&nbsp;float&nbsp;u_light_intensity[MAX_LIGHTS];<br>
uniform&nbsp;vec3&nbsp;&nbsp;u_light_direction[MAX_LIGHTS];<br>
uniform&nbsp;vec3&nbsp;&nbsp;u_light_position[MAX_LIGHTS];<br>
uniform&nbsp;float&nbsp;u_light_range[MAX_LIGHTS];<br>
uniform&nbsp;vec3&nbsp;&nbsp;u_light_attenuation[MAX_LIGHTS];&nbsp;//&nbsp;(constant,&nbsp;linear,&nbsp;quadratic)<br>
uniform&nbsp;float&nbsp;u_light_inner_angle[MAX_LIGHTS];<br>
uniform&nbsp;float&nbsp;u_light_outer_angle[MAX_LIGHTS];<br>
<br>
out&nbsp;vec4&nbsp;FragColor;<br>
<br>
float&nbsp;compute_distance_attenuation(int&nbsp;idx,&nbsp;float&nbsp;dist)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;att&nbsp;=&nbsp;u_light_attenuation[idx];<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;denom&nbsp;=&nbsp;att.x&nbsp;+&nbsp;att.y&nbsp;*&nbsp;dist&nbsp;+&nbsp;att.z&nbsp;*&nbsp;dist&nbsp;*&nbsp;dist;<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(denom&nbsp;&lt;=&nbsp;0.0)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1.0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;w&nbsp;=&nbsp;1.0&nbsp;/&nbsp;denom;<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;range&nbsp;=&nbsp;u_light_range[idx];<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(range&nbsp;&gt;&nbsp;0.0&nbsp;&amp;&amp;&nbsp;dist&nbsp;&gt;&nbsp;range)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w&nbsp;=&nbsp;0.0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;w;<br>
}<br>
<br>
float&nbsp;compute_spot_weight(int&nbsp;idx,&nbsp;vec3&nbsp;L)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;cos_theta&nbsp;=&nbsp;dot(u_light_direction[idx],&nbsp;-L);<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;cos_outer&nbsp;=&nbsp;cos(u_light_outer_angle[idx]);<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;cos_inner&nbsp;=&nbsp;cos(u_light_inner_angle[idx]);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(cos_theta&nbsp;&lt;=&nbsp;cos_outer)&nbsp;return&nbsp;0.0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(cos_theta&nbsp;&gt;=&nbsp;cos_inner)&nbsp;return&nbsp;1.0;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;t&nbsp;=&nbsp;(cos_theta&nbsp;-&nbsp;cos_outer)&nbsp;/&nbsp;(cos_inner&nbsp;-&nbsp;cos_outer);<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;t&nbsp;*&nbsp;t&nbsp;*&nbsp;(3.0&nbsp;-&nbsp;2.0&nbsp;*&nbsp;t);&nbsp;//&nbsp;smoothstep<br>
}<br>
<br>
void&nbsp;main()&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;N&nbsp;=&nbsp;normalize(v_normal);<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;base_color&nbsp;=&nbsp;u_color.rgb;<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;result&nbsp;=&nbsp;vec3(0.0);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;u_light_count;&nbsp;++i)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;type&nbsp;=&nbsp;u_light_type[i];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;radiance&nbsp;=&nbsp;u_light_color[i]&nbsp;*&nbsp;u_light_intensity[i];<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(type&nbsp;==&nbsp;LIGHT_TYPE_AMBIENT)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;+=&nbsp;base_color&nbsp;*&nbsp;radiance;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;L;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;dist;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;weight&nbsp;=&nbsp;1.0;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(type&nbsp;==&nbsp;LIGHT_TYPE_DIRECTIONAL)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L&nbsp;=&nbsp;normalize(-u_light_direction[i]);&nbsp;//&nbsp;направление&nbsp;на&nbsp;свет<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dist&nbsp;=&nbsp;1e9;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;to_light&nbsp;=&nbsp;u_light_position[i]&nbsp;-&nbsp;v_world_pos;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dist&nbsp;=&nbsp;length(to_light);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(dist&nbsp;&gt;&nbsp;0.0001)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L&nbsp;=&nbsp;to_light&nbsp;/&nbsp;dist;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L&nbsp;=&nbsp;vec3(0.0,&nbsp;1.0,&nbsp;0.0);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;weight&nbsp;*=&nbsp;compute_distance_attenuation(i,&nbsp;dist);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(type&nbsp;==&nbsp;LIGHT_TYPE_SPOT)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;weight&nbsp;*=&nbsp;compute_spot_weight(i,&nbsp;L);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;ndotl&nbsp;=&nbsp;max(dot(N,&nbsp;L),&nbsp;0.0);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;diffuse&nbsp;=&nbsp;base_color&nbsp;*&nbsp;ndotl;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;V&nbsp;=&nbsp;normalize(-v_world_pos);&nbsp;//&nbsp;камера&nbsp;в&nbsp;(0,0,0)&nbsp;для&nbsp;простоты<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;H&nbsp;=&nbsp;normalize(L&nbsp;+&nbsp;V);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;ndoth&nbsp;=&nbsp;max(dot(N,&nbsp;H),&nbsp;0.0);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;shininess&nbsp;=&nbsp;16.0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;spec&nbsp;=&nbsp;pow(ndoth,&nbsp;shininess);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;specular_color&nbsp;=&nbsp;vec3(1.0);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;specular&nbsp;=&nbsp;spec&nbsp;*&nbsp;specular_color;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;+=&nbsp;(diffuse&nbsp;+&nbsp;specular)&nbsp;*&nbsp;radiance&nbsp;*&nbsp;weight;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;FragColor&nbsp;=&nbsp;vec4(result,&nbsp;u_color.a);<br>
}<br>
&quot;&quot;&quot;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;ShaderProgram(vertex_source=vert,&nbsp;fragment_source=frag)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;ensure_ready(self,&nbsp;graphics:&nbsp;GraphicsBackend&nbsp;|&nbsp;None&nbsp;=&nbsp;None):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;self._compiled:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;backend&nbsp;=&nbsp;graphics&nbsp;or&nbsp;self._backend&nbsp;or&nbsp;get_default_graphics_backend()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;backend&nbsp;is&nbsp;None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;raise&nbsp;RuntimeError(&quot;Graphics&nbsp;backend&nbsp;is&nbsp;not&nbsp;available&nbsp;for&nbsp;shader&nbsp;compilation.&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._backend&nbsp;=&nbsp;backend<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._handle&nbsp;=&nbsp;backend.create_shader(self.vertex_source,&nbsp;self.fragment_source,&nbsp;self.geometry_source)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._compiled&nbsp;=&nbsp;True<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;_require_handle(self)&nbsp;-&gt;&nbsp;ShaderHandle:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;self._handle&nbsp;is&nbsp;None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;raise&nbsp;RuntimeError(&quot;ShaderProgram&nbsp;is&nbsp;not&nbsp;compiled.&nbsp;Call&nbsp;ensure_ready()&nbsp;first.&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;self._handle<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;use(self):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._require_handle().use()<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;stop(self):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;self._handle:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._handle.stop()<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;delete(self):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;self._handle:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._handle.delete()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._handle&nbsp;=&nbsp;None<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;set_uniform_matrix4(self,&nbsp;name:&nbsp;str,&nbsp;matrix:&nbsp;np.ndarray):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Upload&nbsp;a&nbsp;4x4&nbsp;matrix&nbsp;(float32)&nbsp;to&nbsp;uniform&nbsp;``name``.&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._require_handle().set_uniform_matrix4(name,&nbsp;matrix)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;set_uniform_vec2(self,&nbsp;name:&nbsp;str,&nbsp;vector:&nbsp;np.ndarray):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._require_handle().set_uniform_vec2(name,&nbsp;vector)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;set_uniform_vec3(self,&nbsp;name:&nbsp;str,&nbsp;vector:&nbsp;np.ndarray):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._require_handle().set_uniform_vec3(name,&nbsp;vector)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;set_uniform_vec4(self,&nbsp;name:&nbsp;str,&nbsp;vector:&nbsp;np.ndarray):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._require_handle().set_uniform_vec4(name,&nbsp;vector)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;set_uniform_float(self,&nbsp;name:&nbsp;str,&nbsp;value:&nbsp;float):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._require_handle().set_uniform_float(name,&nbsp;value)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;set_uniform_int(self,&nbsp;name:&nbsp;str,&nbsp;value:&nbsp;int):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._require_handle().set_uniform_int(name,&nbsp;value)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;set_uniform_auto(self,&nbsp;name:&nbsp;str,&nbsp;value:&nbsp;Any):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Best-effort&nbsp;setter&nbsp;that&nbsp;infers&nbsp;uniform&nbsp;type&nbsp;based&nbsp;on&nbsp;``value``.&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;isinstance(value,&nbsp;(list,&nbsp;tuple,&nbsp;np.ndarray)):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr&nbsp;=&nbsp;np.asarray(value)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;arr.shape&nbsp;==&nbsp;(4,&nbsp;4):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.set_uniform_matrix4(name,&nbsp;arr)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif&nbsp;arr.shape&nbsp;==&nbsp;(2,):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.set_uniform_vec2(name,&nbsp;arr)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif&nbsp;arr.shape&nbsp;==&nbsp;(3,):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.set_uniform_vec3(name,&nbsp;arr)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif&nbsp;arr.shape&nbsp;==&nbsp;(4,):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.set_uniform_vec4(name,&nbsp;arr)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;raise&nbsp;ValueError(f&quot;Unsupported&nbsp;uniform&nbsp;array&nbsp;shape&nbsp;for&nbsp;{name}:&nbsp;{arr.shape}&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif&nbsp;isinstance(value,&nbsp;bool):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.set_uniform_int(name,&nbsp;int(value))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif&nbsp;isinstance(value,&nbsp;int):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.set_uniform_int(name,&nbsp;value)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.set_uniform_float(name,&nbsp;float(value))<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;@classmethod<br>
&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;from_files(cls,&nbsp;vertex_path:&nbsp;str&nbsp;|&nbsp;Path,&nbsp;fragment_path:&nbsp;str&nbsp;|&nbsp;Path)&nbsp;-&gt;&nbsp;&quot;ShaderProgram&quot;:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertex_source&nbsp;=&nbsp;Path(vertex_path).read_text(encoding=&quot;utf-8&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fragment_source&nbsp;=&nbsp;Path(fragment_path).read_text(encoding=&quot;utf-8&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;cls(vertex_source=vertex_source,&nbsp;fragment_source=fragment_source)<br>
<!-- END SCAT CODE -->
</body>
</html>
