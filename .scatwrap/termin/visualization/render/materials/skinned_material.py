<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>termin/visualization/render/materials/skinned_material.py</title>
</head>
<body>
<!-- BEGIN SCAT CODE -->
&quot;&quot;&quot;SkinnedMaterial&nbsp;-&nbsp;Material&nbsp;for&nbsp;skinned&nbsp;meshes&nbsp;with&nbsp;skeletal&nbsp;animation.&quot;&quot;&quot;<br>
<br>
from&nbsp;__future__&nbsp;import&nbsp;annotations<br>
<br>
from&nbsp;termin._native.render&nbsp;import&nbsp;TcMaterial,&nbsp;TcRenderState<br>
<br>
<br>
SKINNED_VERT&nbsp;=&nbsp;&quot;&quot;&quot;#version&nbsp;330&nbsp;core<br>
<br>
layout(location&nbsp;=&nbsp;0)&nbsp;in&nbsp;vec3&nbsp;a_position;<br>
layout(location&nbsp;=&nbsp;1)&nbsp;in&nbsp;vec3&nbsp;a_normal;<br>
layout(location&nbsp;=&nbsp;2)&nbsp;in&nbsp;vec2&nbsp;a_uv;<br>
layout(location&nbsp;=&nbsp;3)&nbsp;in&nbsp;vec4&nbsp;a_joints;<br>
layout(location&nbsp;=&nbsp;4)&nbsp;in&nbsp;vec4&nbsp;a_weights;<br>
<br>
uniform&nbsp;mat4&nbsp;u_model;<br>
uniform&nbsp;mat4&nbsp;u_view;<br>
uniform&nbsp;mat4&nbsp;u_projection;<br>
<br>
//&nbsp;Bone&nbsp;matrices&nbsp;for&nbsp;skeletal&nbsp;animation&nbsp;(in&nbsp;model-local&nbsp;space)<br>
const&nbsp;int&nbsp;MAX_BONES&nbsp;=&nbsp;128;<br>
uniform&nbsp;mat4&nbsp;u_bone_matrices[MAX_BONES];<br>
uniform&nbsp;int&nbsp;u_bone_count;<br>
<br>
out&nbsp;vec3&nbsp;v_world_pos;<br>
out&nbsp;vec3&nbsp;v_normal;<br>
out&nbsp;vec2&nbsp;v_uv;<br>
<br>
void&nbsp;main()&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Compute&nbsp;skinned&nbsp;position&nbsp;and&nbsp;normal&nbsp;in&nbsp;model-local&nbsp;space<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec4&nbsp;skinned_pos&nbsp;=&nbsp;vec4(0.0);<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;skinned_normal&nbsp;=&nbsp;vec3(0.0);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Apply&nbsp;skinning&nbsp;if&nbsp;bone&nbsp;matrices&nbsp;are&nbsp;available<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(u_bone_count&nbsp;&gt;&nbsp;0)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;4;&nbsp;++i)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;joint_idx&nbsp;=&nbsp;int(a_joints[i]);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;weight&nbsp;=&nbsp;a_weights[i];<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(weight&nbsp;&gt;&nbsp;0.0&nbsp;&amp;&amp;&nbsp;joint_idx&nbsp;&lt;&nbsp;u_bone_count)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mat4&nbsp;bone_matrix&nbsp;=&nbsp;u_bone_matrices[joint_idx];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;skinned_pos&nbsp;+=&nbsp;weight&nbsp;*&nbsp;(bone_matrix&nbsp;*&nbsp;vec4(a_position,&nbsp;1.0));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;skinned_normal&nbsp;+=&nbsp;weight&nbsp;*&nbsp;(mat3(bone_matrix)&nbsp;*&nbsp;a_normal);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;No&nbsp;skinning&nbsp;-&nbsp;use&nbsp;original&nbsp;position<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;skinned_pos&nbsp;=&nbsp;vec4(a_position,&nbsp;1.0);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;skinned_normal&nbsp;=&nbsp;a_normal;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Apply&nbsp;model&nbsp;transform&nbsp;(same&nbsp;as&nbsp;non-skinned&nbsp;shaders)<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec4&nbsp;world_pos&nbsp;=&nbsp;u_model&nbsp;*&nbsp;skinned_pos;<br>
&nbsp;&nbsp;&nbsp;&nbsp;v_world_pos&nbsp;=&nbsp;world_pos.xyz;<br>
&nbsp;&nbsp;&nbsp;&nbsp;v_normal&nbsp;=&nbsp;mat3(transpose(inverse(u_model)))&nbsp;*&nbsp;skinned_normal;<br>
&nbsp;&nbsp;&nbsp;&nbsp;v_uv&nbsp;=&nbsp;a_uv;<br>
&nbsp;&nbsp;&nbsp;&nbsp;gl_Position&nbsp;=&nbsp;u_projection&nbsp;*&nbsp;u_view&nbsp;*&nbsp;world_pos;<br>
}<br>
&quot;&quot;&quot;<br>
<br>
SKINNED_FRAG&nbsp;=&nbsp;&quot;&quot;&quot;#version&nbsp;330&nbsp;core<br>
<br>
in&nbsp;vec3&nbsp;v_world_pos;<br>
in&nbsp;vec3&nbsp;v_normal;<br>
in&nbsp;vec2&nbsp;v_uv;<br>
<br>
uniform&nbsp;vec4&nbsp;u_color;<br>
uniform&nbsp;sampler2D&nbsp;u_albedo_texture;<br>
uniform&nbsp;float&nbsp;u_shininess;<br>
<br>
//&nbsp;Emission&nbsp;(for&nbsp;bloom/glow&nbsp;effects)<br>
uniform&nbsp;vec4&nbsp;u_emission_color;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;RGB&nbsp;=&nbsp;color,&nbsp;A&nbsp;unused<br>
uniform&nbsp;float&nbsp;u_emission_intensity;&nbsp;//&nbsp;0&nbsp;=&nbsp;no&nbsp;emission,&nbsp;&gt;1&nbsp;=&nbsp;HDR&nbsp;bloom<br>
<br>
//&nbsp;Lighting<br>
const&nbsp;int&nbsp;LIGHT_TYPE_DIRECTIONAL&nbsp;=&nbsp;0;<br>
const&nbsp;int&nbsp;LIGHT_TYPE_POINT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;1;<br>
const&nbsp;int&nbsp;LIGHT_TYPE_SPOT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;2;<br>
<br>
const&nbsp;int&nbsp;MAX_LIGHTS&nbsp;=&nbsp;8;<br>
<br>
uniform&nbsp;vec3&nbsp;u_camera_position;<br>
uniform&nbsp;vec3&nbsp;&nbsp;u_ambient_color;<br>
uniform&nbsp;float&nbsp;u_ambient_intensity;<br>
<br>
uniform&nbsp;int&nbsp;&nbsp;&nbsp;u_light_count;<br>
uniform&nbsp;int&nbsp;&nbsp;&nbsp;u_light_type[MAX_LIGHTS];<br>
uniform&nbsp;vec3&nbsp;&nbsp;u_light_color[MAX_LIGHTS];<br>
uniform&nbsp;float&nbsp;u_light_intensity[MAX_LIGHTS];<br>
uniform&nbsp;vec3&nbsp;&nbsp;u_light_direction[MAX_LIGHTS];<br>
uniform&nbsp;vec3&nbsp;&nbsp;u_light_position[MAX_LIGHTS];<br>
uniform&nbsp;float&nbsp;u_light_range[MAX_LIGHTS];<br>
uniform&nbsp;vec3&nbsp;&nbsp;u_light_attenuation[MAX_LIGHTS];<br>
uniform&nbsp;float&nbsp;u_light_inner_angle[MAX_LIGHTS];<br>
uniform&nbsp;float&nbsp;u_light_outer_angle[MAX_LIGHTS];<br>
<br>
//&nbsp;Shadow&nbsp;Mapping&nbsp;(hardware&nbsp;PCF)<br>
const&nbsp;int&nbsp;MAX_SHADOW_MAPS&nbsp;=&nbsp;4;<br>
const&nbsp;float&nbsp;SHADOW_BIAS&nbsp;=&nbsp;0.005;<br>
<br>
uniform&nbsp;int&nbsp;u_shadow_map_count;<br>
uniform&nbsp;sampler2DShadow&nbsp;u_shadow_map[MAX_SHADOW_MAPS];<br>
uniform&nbsp;mat4&nbsp;u_light_space_matrix[MAX_SHADOW_MAPS];<br>
uniform&nbsp;int&nbsp;u_shadow_light_index[MAX_SHADOW_MAPS];<br>
<br>
out&nbsp;vec4&nbsp;FragColor;<br>
<br>
//&nbsp;GLSL&nbsp;1.30+&nbsp;forbids&nbsp;dynamic&nbsp;indexing&nbsp;of&nbsp;sampler&nbsp;arrays<br>
float&nbsp;sample_shadow_map(int&nbsp;idx,&nbsp;vec3&nbsp;coords)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(idx&nbsp;==&nbsp;0)&nbsp;return&nbsp;texture(u_shadow_map[0],&nbsp;coords);<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(idx&nbsp;==&nbsp;1)&nbsp;return&nbsp;texture(u_shadow_map[1],&nbsp;coords);<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(idx&nbsp;==&nbsp;2)&nbsp;return&nbsp;texture(u_shadow_map[2],&nbsp;coords);<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(idx&nbsp;==&nbsp;3)&nbsp;return&nbsp;texture(u_shadow_map[3],&nbsp;coords);<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1.0;<br>
}<br>
<br>
float&nbsp;compute_distance_attenuation(int&nbsp;idx,&nbsp;float&nbsp;dist)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;att&nbsp;=&nbsp;u_light_attenuation[idx];<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;denom&nbsp;=&nbsp;att.x&nbsp;+&nbsp;att.y&nbsp;*&nbsp;dist&nbsp;+&nbsp;att.z&nbsp;*&nbsp;dist&nbsp;*&nbsp;dist;<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(denom&nbsp;&lt;=&nbsp;0.0)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1.0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;w&nbsp;=&nbsp;1.0&nbsp;/&nbsp;denom;<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;range&nbsp;=&nbsp;u_light_range[idx];<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(range&nbsp;&gt;&nbsp;0.0&nbsp;&amp;&amp;&nbsp;dist&nbsp;&gt;&nbsp;range)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w&nbsp;=&nbsp;0.0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;w;<br>
}<br>
<br>
float&nbsp;compute_spot_weight(int&nbsp;idx,&nbsp;vec3&nbsp;L)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;cos_theta&nbsp;=&nbsp;dot(u_light_direction[idx],&nbsp;-L);<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;cos_outer&nbsp;=&nbsp;cos(u_light_outer_angle[idx]);<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;cos_inner&nbsp;=&nbsp;cos(u_light_inner_angle[idx]);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(cos_theta&nbsp;&lt;=&nbsp;cos_outer)&nbsp;return&nbsp;0.0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(cos_theta&nbsp;&gt;=&nbsp;cos_inner)&nbsp;return&nbsp;1.0;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;t&nbsp;=&nbsp;(cos_theta&nbsp;-&nbsp;cos_outer)&nbsp;/&nbsp;(cos_inner&nbsp;-&nbsp;cos_outer);<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;t&nbsp;*&nbsp;t&nbsp;*&nbsp;(3.0&nbsp;-&nbsp;2.0&nbsp;*&nbsp;t);<br>
}<br>
<br>
float&nbsp;compute_shadow(int&nbsp;light_index)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;sm&nbsp;=&nbsp;0;&nbsp;sm&nbsp;&lt;&nbsp;u_shadow_map_count;&nbsp;++sm)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(u_shadow_light_index[sm]&nbsp;!=&nbsp;light_index)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec4&nbsp;light_space_pos&nbsp;=&nbsp;u_light_space_matrix[sm]&nbsp;*&nbsp;vec4(v_world_pos,&nbsp;1.0);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;proj_coords&nbsp;=&nbsp;light_space_pos.xyz&nbsp;/&nbsp;light_space_pos.w;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proj_coords&nbsp;=&nbsp;proj_coords&nbsp;*&nbsp;0.5&nbsp;+&nbsp;0.5;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(proj_coords.x&nbsp;&lt;&nbsp;0.0&nbsp;||&nbsp;proj_coords.x&nbsp;&gt;&nbsp;1.0&nbsp;||<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proj_coords.y&nbsp;&lt;&nbsp;0.0&nbsp;||&nbsp;proj_coords.y&nbsp;&gt;&nbsp;1.0&nbsp;||<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proj_coords.z&nbsp;&lt;&nbsp;0.0&nbsp;||&nbsp;proj_coords.z&nbsp;&gt;&nbsp;1.0)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1.0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Hardware&nbsp;PCF:&nbsp;texture()&nbsp;делает&nbsp;depth&nbsp;comparison&nbsp;автоматически<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;sample_shadow_map(sm,&nbsp;vec3(proj_coords.xy,&nbsp;proj_coords.z&nbsp;-&nbsp;SHADOW_BIAS));<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1.0;<br>
}<br>
<br>
void&nbsp;main()&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;N&nbsp;=&nbsp;normalize(v_normal);<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec4&nbsp;tex_color&nbsp;=&nbsp;texture(u_albedo_texture,&nbsp;v_uv);<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;base_color&nbsp;=&nbsp;u_color.rgb&nbsp;*&nbsp;tex_color.rgb;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;result&nbsp;=&nbsp;base_color&nbsp;*&nbsp;u_ambient_color&nbsp;*&nbsp;u_ambient_intensity;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;u_light_count;&nbsp;++i)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;type&nbsp;=&nbsp;u_light_type[i];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;radiance&nbsp;=&nbsp;u_light_color[i]&nbsp;*&nbsp;u_light_intensity[i];<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;L;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;dist;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;weight&nbsp;=&nbsp;1.0;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(type&nbsp;==&nbsp;LIGHT_TYPE_DIRECTIONAL)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L&nbsp;=&nbsp;normalize(-u_light_direction[i]);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dist&nbsp;=&nbsp;1e9;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;to_light&nbsp;=&nbsp;u_light_position[i]&nbsp;-&nbsp;v_world_pos;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dist&nbsp;=&nbsp;length(to_light);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(dist&nbsp;&gt;&nbsp;0.0001)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L&nbsp;=&nbsp;to_light&nbsp;/&nbsp;dist;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L&nbsp;=&nbsp;vec3(0.0,&nbsp;1.0,&nbsp;0.0);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;weight&nbsp;*=&nbsp;compute_distance_attenuation(i,&nbsp;dist);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(type&nbsp;==&nbsp;LIGHT_TYPE_SPOT)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;weight&nbsp;*=&nbsp;compute_spot_weight(i,&nbsp;L);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;shadow&nbsp;=&nbsp;1.0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(type&nbsp;==&nbsp;LIGHT_TYPE_DIRECTIONAL)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shadow&nbsp;=&nbsp;compute_shadow(i);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;ndotl&nbsp;=&nbsp;max(dot(N,&nbsp;L),&nbsp;0.0);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;diffuse&nbsp;=&nbsp;base_color&nbsp;*&nbsp;ndotl;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;V&nbsp;=&nbsp;normalize(u_camera_position&nbsp;-&nbsp;v_world_pos);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;H&nbsp;=&nbsp;normalize(L&nbsp;+&nbsp;V);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;ndoth&nbsp;=&nbsp;max(dot(N,&nbsp;H),&nbsp;0.0);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;spec&nbsp;=&nbsp;pow(ndoth,&nbsp;u_shininess);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;specular_color&nbsp;=&nbsp;vec3(1.0);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;specular&nbsp;=&nbsp;spec&nbsp;*&nbsp;specular_color;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;+=&nbsp;(diffuse&nbsp;+&nbsp;specular)&nbsp;*&nbsp;radiance&nbsp;*&nbsp;weight&nbsp;*&nbsp;shadow;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Add&nbsp;emission&nbsp;(for&nbsp;HDR&nbsp;bloom)<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;emission&nbsp;=&nbsp;u_emission_color.rgb&nbsp;*&nbsp;u_emission_intensity;<br>
&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;+=&nbsp;emission;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;FragColor&nbsp;=&nbsp;vec4(result,&nbsp;u_color.a);<br>
}<br>
&quot;&quot;&quot;<br>
<br>
<br>
def&nbsp;create_skinned_material(<br>
&nbsp;&nbsp;&nbsp;&nbsp;color:&nbsp;tuple[float,&nbsp;float,&nbsp;float,&nbsp;float]&nbsp;|&nbsp;None&nbsp;=&nbsp;None,<br>
&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;str&nbsp;=&nbsp;&quot;SkinnedMaterial&quot;,<br>
)&nbsp;-&gt;&nbsp;TcMaterial:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Create&nbsp;a&nbsp;skinned&nbsp;material&nbsp;for&nbsp;meshes&nbsp;with&nbsp;skeletal&nbsp;animation.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Uses&nbsp;same&nbsp;lighting&nbsp;model&nbsp;as&nbsp;DefaultMaterial&nbsp;but&nbsp;with&nbsp;skinning&nbsp;support<br>
&nbsp;&nbsp;&nbsp;&nbsp;in&nbsp;the&nbsp;vertex&nbsp;shader.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;from&nbsp;termin.visualization.render.texture&nbsp;import&nbsp;get_white_texture<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;mat&nbsp;=&nbsp;TcMaterial.create(name,&nbsp;&quot;&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;mat.shader_name&nbsp;=&nbsp;&quot;SkinnedShader&quot;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;state&nbsp;=&nbsp;TcRenderState.opaque()<br>
&nbsp;&nbsp;&nbsp;&nbsp;phase&nbsp;=&nbsp;mat.add_phase_from_sources(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertex_source=SKINNED_VERT,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fragment_source=SKINNED_FRAG,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;geometry_source=&quot;&quot;,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shader_name=&quot;SkinnedShader&quot;,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;phase_mark=&quot;opaque&quot;,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;priority=0,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state=state,<br>
&nbsp;&nbsp;&nbsp;&nbsp;)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;phase&nbsp;is&nbsp;not&nbsp;None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Set&nbsp;default&nbsp;color<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;color&nbsp;or&nbsp;(1.0,&nbsp;1.0,&nbsp;1.0,&nbsp;1.0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;phase.set_color(c[0],&nbsp;c[1],&nbsp;c[2],&nbsp;c[3])<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Set&nbsp;white&nbsp;texture&nbsp;as&nbsp;default&nbsp;albedo<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;white_tex&nbsp;=&nbsp;get_white_texture()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;white_tex&nbsp;and&nbsp;white_tex.texture_data:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;phase.set_texture(&quot;u_albedo_texture&quot;,&nbsp;white_tex.texture_data)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Set&nbsp;default&nbsp;shininess<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;phase.set_uniform_float(&quot;u_shininess&quot;,&nbsp;32.0)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;mat<br>
<br>
<br>
#&nbsp;Legacy&nbsp;alias<br>
def&nbsp;skinned_shader():<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Deprecated:&nbsp;Use&nbsp;create_skinned_material()&nbsp;instead.&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;raise&nbsp;NotImplementedError(&quot;skinned_shader()&nbsp;is&nbsp;deprecated.&nbsp;Use&nbsp;create_skinned_material()&nbsp;instead.&quot;)<br>
<br>
<br>
class&nbsp;SkinnedMaterial(TcMaterial):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Material&nbsp;for&nbsp;skinned&nbsp;meshes&nbsp;with&nbsp;skeletal&nbsp;animation.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns&nbsp;TcMaterial.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Uses&nbsp;same&nbsp;lighting&nbsp;model&nbsp;as&nbsp;DefaultMaterial&nbsp;but&nbsp;with&nbsp;skinning&nbsp;support<br>
&nbsp;&nbsp;&nbsp;&nbsp;in&nbsp;the&nbsp;vertex&nbsp;shader.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;__new__(cls,&nbsp;color:&nbsp;tuple[float,&nbsp;float,&nbsp;float,&nbsp;float]&nbsp;|&nbsp;None&nbsp;=&nbsp;None)&nbsp;-&gt;&nbsp;TcMaterial:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;create_skinned_material(color=color)<br>
<!-- END SCAT CODE -->
</body>
</html>
