<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>termin/visualization/render/materials/pbr_material.py</title>
</head>
<body>
<!-- BEGIN SCAT CODE -->
#&nbsp;termin/visualization/render/materials/pbr_material.py<br>
&quot;&quot;&quot;PBR&nbsp;(Physically&nbsp;Based&nbsp;Rendering)&nbsp;material&nbsp;using&nbsp;GGX/Cook-Torrance&nbsp;BRDF.&quot;&quot;&quot;<br>
<br>
from&nbsp;__future__&nbsp;import&nbsp;annotations<br>
<br>
from&nbsp;termin._native.render&nbsp;import&nbsp;TcMaterial,&nbsp;TcRenderState<br>
<br>
<br>
PBR_VERT&nbsp;=&nbsp;&quot;&quot;&quot;#version&nbsp;330&nbsp;core<br>
<br>
layout(location&nbsp;=&nbsp;0)&nbsp;in&nbsp;vec3&nbsp;a_position;<br>
layout(location&nbsp;=&nbsp;1)&nbsp;in&nbsp;vec3&nbsp;a_normal;<br>
layout(location&nbsp;=&nbsp;2)&nbsp;in&nbsp;vec2&nbsp;a_uv;<br>
<br>
uniform&nbsp;mat4&nbsp;u_model;<br>
uniform&nbsp;mat4&nbsp;u_view;<br>
uniform&nbsp;mat4&nbsp;u_projection;<br>
<br>
out&nbsp;vec3&nbsp;v_world_pos;<br>
out&nbsp;vec3&nbsp;v_normal;<br>
out&nbsp;vec2&nbsp;v_uv;<br>
<br>
void&nbsp;main()&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec4&nbsp;world&nbsp;=&nbsp;u_model&nbsp;*&nbsp;vec4(a_position,&nbsp;1.0);<br>
&nbsp;&nbsp;&nbsp;&nbsp;v_world_pos&nbsp;=&nbsp;world.xyz;<br>
&nbsp;&nbsp;&nbsp;&nbsp;v_normal&nbsp;=&nbsp;mat3(transpose(inverse(u_model)))&nbsp;*&nbsp;a_normal;<br>
&nbsp;&nbsp;&nbsp;&nbsp;v_uv&nbsp;=&nbsp;a_uv;<br>
&nbsp;&nbsp;&nbsp;&nbsp;gl_Position&nbsp;=&nbsp;u_projection&nbsp;*&nbsp;u_view&nbsp;*&nbsp;world;<br>
}<br>
&quot;&quot;&quot;<br>
<br>
PBR_FRAG&nbsp;=&nbsp;&quot;&quot;&quot;#version&nbsp;330&nbsp;core<br>
<br>
in&nbsp;vec3&nbsp;v_world_pos;<br>
in&nbsp;vec3&nbsp;v_normal;<br>
in&nbsp;vec2&nbsp;v_uv;<br>
<br>
//&nbsp;Material&nbsp;parameters<br>
uniform&nbsp;vec4&nbsp;u_color;<br>
uniform&nbsp;sampler2D&nbsp;u_albedo_texture;<br>
uniform&nbsp;float&nbsp;u_metallic;<br>
uniform&nbsp;float&nbsp;u_roughness;<br>
<br>
//&nbsp;Camera<br>
uniform&nbsp;vec3&nbsp;u_camera_position;<br>
<br>
//&nbsp;Lighting<br>
const&nbsp;int&nbsp;MAX_LIGHTS&nbsp;=&nbsp;8;<br>
const&nbsp;int&nbsp;LIGHT_TYPE_DIRECTIONAL&nbsp;=&nbsp;0;<br>
const&nbsp;int&nbsp;LIGHT_TYPE_POINT&nbsp;=&nbsp;1;<br>
const&nbsp;int&nbsp;LIGHT_TYPE_SPOT&nbsp;=&nbsp;2;<br>
<br>
uniform&nbsp;vec3&nbsp;&nbsp;u_ambient_color;<br>
uniform&nbsp;float&nbsp;u_ambient_intensity;<br>
<br>
uniform&nbsp;int&nbsp;&nbsp;&nbsp;u_light_count;<br>
uniform&nbsp;int&nbsp;&nbsp;&nbsp;u_light_type[MAX_LIGHTS];<br>
uniform&nbsp;vec3&nbsp;&nbsp;u_light_color[MAX_LIGHTS];<br>
uniform&nbsp;float&nbsp;u_light_intensity[MAX_LIGHTS];<br>
uniform&nbsp;vec3&nbsp;&nbsp;u_light_direction[MAX_LIGHTS];<br>
uniform&nbsp;vec3&nbsp;&nbsp;u_light_position[MAX_LIGHTS];<br>
uniform&nbsp;float&nbsp;u_light_range[MAX_LIGHTS];<br>
uniform&nbsp;vec3&nbsp;&nbsp;u_light_attenuation[MAX_LIGHTS];<br>
uniform&nbsp;float&nbsp;u_light_inner_angle[MAX_LIGHTS];<br>
uniform&nbsp;float&nbsp;u_light_outer_angle[MAX_LIGHTS];<br>
<br>
//&nbsp;Shadow&nbsp;Mapping&nbsp;(hardware&nbsp;PCF)<br>
const&nbsp;int&nbsp;MAX_SHADOW_MAPS&nbsp;=&nbsp;4;<br>
const&nbsp;float&nbsp;SHADOW_BIAS&nbsp;=&nbsp;0.005;<br>
uniform&nbsp;int&nbsp;u_shadow_map_count;<br>
uniform&nbsp;sampler2DShadow&nbsp;u_shadow_map[MAX_SHADOW_MAPS];<br>
uniform&nbsp;mat4&nbsp;u_light_space_matrix[MAX_SHADOW_MAPS];<br>
uniform&nbsp;int&nbsp;u_shadow_light_index[MAX_SHADOW_MAPS];<br>
<br>
out&nbsp;vec4&nbsp;FragColor;<br>
<br>
//&nbsp;GLSL&nbsp;1.30+&nbsp;forbids&nbsp;dynamic&nbsp;indexing&nbsp;of&nbsp;sampler&nbsp;arrays<br>
float&nbsp;sample_shadow_map(int&nbsp;idx,&nbsp;vec3&nbsp;coords)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(idx&nbsp;==&nbsp;0)&nbsp;return&nbsp;texture(u_shadow_map[0],&nbsp;coords);<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(idx&nbsp;==&nbsp;1)&nbsp;return&nbsp;texture(u_shadow_map[1],&nbsp;coords);<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(idx&nbsp;==&nbsp;2)&nbsp;return&nbsp;texture(u_shadow_map[2],&nbsp;coords);<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(idx&nbsp;==&nbsp;3)&nbsp;return&nbsp;texture(u_shadow_map[3],&nbsp;coords);<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1.0;<br>
}<br>
<br>
const&nbsp;float&nbsp;PI&nbsp;=&nbsp;3.14159265359;<br>
<br>
//&nbsp;Normal&nbsp;Distribution&nbsp;Function&nbsp;(GGX/Trowbridge-Reitz)<br>
float&nbsp;D_GGX(float&nbsp;NdotH,&nbsp;float&nbsp;roughness)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;a&nbsp;=&nbsp;roughness&nbsp;*&nbsp;roughness;<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;a2&nbsp;=&nbsp;a&nbsp;*&nbsp;a;<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;denom&nbsp;=&nbsp;NdotH&nbsp;*&nbsp;NdotH&nbsp;*&nbsp;(a2&nbsp;-&nbsp;1.0)&nbsp;+&nbsp;1.0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;a2&nbsp;/&nbsp;(PI&nbsp;*&nbsp;denom&nbsp;*&nbsp;denom);<br>
}<br>
<br>
//&nbsp;Geometry&nbsp;Function&nbsp;(Smith's&nbsp;method&nbsp;with&nbsp;GGX)<br>
float&nbsp;G_Smith(float&nbsp;NdotV,&nbsp;float&nbsp;NdotL,&nbsp;float&nbsp;roughness)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;r&nbsp;=&nbsp;roughness&nbsp;+&nbsp;1.0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;k&nbsp;=&nbsp;(r&nbsp;*&nbsp;r)&nbsp;/&nbsp;8.0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;G1_V&nbsp;=&nbsp;NdotV&nbsp;/&nbsp;(NdotV&nbsp;*&nbsp;(1.0&nbsp;-&nbsp;k)&nbsp;+&nbsp;k);<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;G1_L&nbsp;=&nbsp;NdotL&nbsp;/&nbsp;(NdotL&nbsp;*&nbsp;(1.0&nbsp;-&nbsp;k)&nbsp;+&nbsp;k);<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;G1_V&nbsp;*&nbsp;G1_L;<br>
}<br>
<br>
//&nbsp;Fresnel&nbsp;(Schlick&nbsp;approximation)<br>
vec3&nbsp;F_Schlick(float&nbsp;cosTheta,&nbsp;vec3&nbsp;F0)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;F0&nbsp;+&nbsp;(1.0&nbsp;-&nbsp;F0)&nbsp;*&nbsp;pow(1.0&nbsp;-&nbsp;cosTheta,&nbsp;5.0);<br>
}<br>
<br>
float&nbsp;compute_distance_attenuation(int&nbsp;idx,&nbsp;float&nbsp;dist)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;att&nbsp;=&nbsp;u_light_attenuation[idx];<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;denom&nbsp;=&nbsp;att.x&nbsp;+&nbsp;att.y&nbsp;*&nbsp;dist&nbsp;+&nbsp;att.z&nbsp;*&nbsp;dist&nbsp;*&nbsp;dist;<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(denom&nbsp;&lt;=&nbsp;0.0)&nbsp;return&nbsp;1.0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;w&nbsp;=&nbsp;1.0&nbsp;/&nbsp;denom;<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;range&nbsp;=&nbsp;u_light_range[idx];<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(range&nbsp;&gt;&nbsp;0.0&nbsp;&amp;&amp;&nbsp;dist&nbsp;&gt;&nbsp;range)&nbsp;w&nbsp;=&nbsp;0.0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;w;<br>
}<br>
<br>
float&nbsp;compute_spot_weight(int&nbsp;idx,&nbsp;vec3&nbsp;L)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;cos_theta&nbsp;=&nbsp;dot(u_light_direction[idx],&nbsp;-L);<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;cos_outer&nbsp;=&nbsp;cos(u_light_outer_angle[idx]);<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;cos_inner&nbsp;=&nbsp;cos(u_light_inner_angle[idx]);<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(cos_theta&nbsp;&lt;=&nbsp;cos_outer)&nbsp;return&nbsp;0.0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(cos_theta&nbsp;&gt;=&nbsp;cos_inner)&nbsp;return&nbsp;1.0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;t&nbsp;=&nbsp;(cos_theta&nbsp;-&nbsp;cos_outer)&nbsp;/&nbsp;(cos_inner&nbsp;-&nbsp;cos_outer);<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;t&nbsp;*&nbsp;t&nbsp;*&nbsp;(3.0&nbsp;-&nbsp;2.0&nbsp;*&nbsp;t);<br>
}<br>
<br>
float&nbsp;compute_shadow(int&nbsp;light_index)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;sm&nbsp;=&nbsp;0;&nbsp;sm&nbsp;&lt;&nbsp;u_shadow_map_count;&nbsp;++sm)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(u_shadow_light_index[sm]&nbsp;!=&nbsp;light_index)&nbsp;continue;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec4&nbsp;light_space_pos&nbsp;=&nbsp;u_light_space_matrix[sm]&nbsp;*&nbsp;vec4(v_world_pos,&nbsp;1.0);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;proj_coords&nbsp;=&nbsp;light_space_pos.xyz&nbsp;/&nbsp;light_space_pos.w;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proj_coords&nbsp;=&nbsp;proj_coords&nbsp;*&nbsp;0.5&nbsp;+&nbsp;0.5;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(proj_coords.x&nbsp;&lt;&nbsp;0.0&nbsp;||&nbsp;proj_coords.x&nbsp;&gt;&nbsp;1.0&nbsp;||<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proj_coords.y&nbsp;&lt;&nbsp;0.0&nbsp;||&nbsp;proj_coords.y&nbsp;&gt;&nbsp;1.0&nbsp;||<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proj_coords.z&nbsp;&lt;&nbsp;0.0&nbsp;||&nbsp;proj_coords.z&nbsp;&gt;&nbsp;1.0)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1.0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Hardware&nbsp;PCF:&nbsp;texture()&nbsp;делает&nbsp;depth&nbsp;comparison&nbsp;автоматически<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;sample_shadow_map(sm,&nbsp;vec3(proj_coords.xy,&nbsp;proj_coords.z&nbsp;-&nbsp;SHADOW_BIAS));<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1.0;<br>
}<br>
<br>
void&nbsp;main()&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;N&nbsp;=&nbsp;normalize(v_normal);<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;V&nbsp;=&nbsp;normalize(u_camera_position&nbsp;-&nbsp;v_world_pos);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Sample&nbsp;albedo<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec4&nbsp;tex_color&nbsp;=&nbsp;texture(u_albedo_texture,&nbsp;v_uv);<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;albedo&nbsp;=&nbsp;u_color.rgb&nbsp;*&nbsp;tex_color.rgb;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;metallic&nbsp;=&nbsp;u_metallic;<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;roughness&nbsp;=&nbsp;max(u_roughness,&nbsp;0.04);<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;F0&nbsp;=&nbsp;mix(vec3(0.04),&nbsp;albedo,&nbsp;metallic);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Ambient<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;ambient&nbsp;=&nbsp;u_ambient_color&nbsp;*&nbsp;u_ambient_intensity&nbsp;*&nbsp;albedo&nbsp;*&nbsp;(1.0&nbsp;-&nbsp;metallic&nbsp;*&nbsp;0.5);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Single&nbsp;directional&nbsp;light&nbsp;(working&nbsp;version)<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;L&nbsp;=&nbsp;normalize(-u_light_direction[0]);<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;NdotL&nbsp;=&nbsp;max(dot(N,&nbsp;L),&nbsp;0.0);<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;NdotV&nbsp;=&nbsp;max(dot(N,&nbsp;V),&nbsp;0.001);<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;H&nbsp;=&nbsp;normalize(V&nbsp;+&nbsp;L);<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;NdotH&nbsp;=&nbsp;max(dot(N,&nbsp;H),&nbsp;0.0);<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;HdotV&nbsp;=&nbsp;max(dot(H,&nbsp;V),&nbsp;0.0);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Cook-Torrance&nbsp;BRDF<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;D&nbsp;=&nbsp;D_GGX(NdotH,&nbsp;roughness);<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;G&nbsp;=&nbsp;G_Smith(NdotV,&nbsp;NdotL,&nbsp;roughness);<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;F&nbsp;=&nbsp;F_Schlick(HdotV,&nbsp;F0);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;numerator&nbsp;=&nbsp;D&nbsp;*&nbsp;G&nbsp;*&nbsp;F;<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;denominator&nbsp;=&nbsp;4.0&nbsp;*&nbsp;NdotV&nbsp;*&nbsp;NdotL&nbsp;+&nbsp;0.0001;<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;specular&nbsp;=&nbsp;numerator&nbsp;/&nbsp;denominator;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;kD&nbsp;=&nbsp;(1.0&nbsp;-&nbsp;F)&nbsp;*&nbsp;(1.0&nbsp;-&nbsp;metallic);<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;radiance&nbsp;=&nbsp;u_light_color[0]&nbsp;*&nbsp;u_light_intensity[0];<br>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;shadow&nbsp;=&nbsp;compute_shadow(0);<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;Lo&nbsp;=&nbsp;(kD&nbsp;*&nbsp;albedo&nbsp;+&nbsp;specular)&nbsp;*&nbsp;radiance&nbsp;*&nbsp;NdotL&nbsp;*&nbsp;shadow;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec3&nbsp;color&nbsp;=&nbsp;ambient&nbsp;+&nbsp;Lo;<br>
&nbsp;&nbsp;&nbsp;&nbsp;FragColor&nbsp;=&nbsp;vec4(color,&nbsp;1.0);<br>
}<br>
&quot;&quot;&quot;<br>
<br>
<br>
def&nbsp;create_pbr_material(<br>
&nbsp;&nbsp;&nbsp;&nbsp;color:&nbsp;tuple[float,&nbsp;float,&nbsp;float,&nbsp;float]&nbsp;|&nbsp;None&nbsp;=&nbsp;None,<br>
&nbsp;&nbsp;&nbsp;&nbsp;metallic:&nbsp;float&nbsp;=&nbsp;0.0,<br>
&nbsp;&nbsp;&nbsp;&nbsp;roughness:&nbsp;float&nbsp;=&nbsp;0.5,<br>
&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;str&nbsp;=&nbsp;&quot;PBRMaterial&quot;,<br>
)&nbsp;-&gt;&nbsp;TcMaterial:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Create&nbsp;a&nbsp;PBR&nbsp;material&nbsp;using&nbsp;Cook-Torrance&nbsp;BRDF.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;color:&nbsp;Base&nbsp;color&nbsp;(albedo)&nbsp;multiplier.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;metallic:&nbsp;0&nbsp;=&nbsp;dielectric,&nbsp;1&nbsp;=&nbsp;metal.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;roughness:&nbsp;0&nbsp;=&nbsp;smooth/mirror,&nbsp;1&nbsp;=&nbsp;rough/matte.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;Material&nbsp;name.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TcMaterial&nbsp;with&nbsp;PBR&nbsp;shader.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;from&nbsp;termin.visualization.render.texture&nbsp;import&nbsp;get_white_texture<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;mat&nbsp;=&nbsp;TcMaterial.create(name,&nbsp;&quot;&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;mat.shader_name&nbsp;=&nbsp;&quot;PBRShader&quot;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;state&nbsp;=&nbsp;TcRenderState.opaque()<br>
&nbsp;&nbsp;&nbsp;&nbsp;phase&nbsp;=&nbsp;mat.add_phase_from_sources(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertex_source=PBR_VERT,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fragment_source=PBR_FRAG,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;geometry_source=&quot;&quot;,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shader_name=&quot;PBRShader&quot;,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;phase_mark=&quot;opaque&quot;,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;priority=0,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state=state,<br>
&nbsp;&nbsp;&nbsp;&nbsp;)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;phase&nbsp;is&nbsp;not&nbsp;None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Set&nbsp;color<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;color&nbsp;or&nbsp;(1.0,&nbsp;1.0,&nbsp;1.0,&nbsp;1.0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;phase.set_color(c[0],&nbsp;c[1],&nbsp;c[2],&nbsp;c[3])<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Set&nbsp;PBR&nbsp;parameters<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;phase.set_uniform_float(&quot;u_metallic&quot;,&nbsp;metallic)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;phase.set_uniform_float(&quot;u_roughness&quot;,&nbsp;roughness)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Set&nbsp;white&nbsp;texture&nbsp;as&nbsp;default&nbsp;albedo<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;white_tex&nbsp;=&nbsp;get_white_texture()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;white_tex&nbsp;and&nbsp;white_tex.texture_data:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;phase.set_texture(&quot;u_albedo_texture&quot;,&nbsp;white_tex.texture_data)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;mat<br>
<br>
<br>
#&nbsp;Legacy&nbsp;alias<br>
def&nbsp;pbr_shader():<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Deprecated:&nbsp;Use&nbsp;create_pbr_material()&nbsp;instead.&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;raise&nbsp;NotImplementedError(&quot;pbr_shader()&nbsp;is&nbsp;deprecated.&nbsp;Use&nbsp;create_pbr_material()&nbsp;instead.&quot;)<br>
<br>
<br>
class&nbsp;PBRMaterial(TcMaterial):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;PBR&nbsp;material&nbsp;using&nbsp;Cook-Torrance&nbsp;BRDF.&nbsp;Returns&nbsp;TcMaterial.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Parameters:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;color:&nbsp;Base&nbsp;color&nbsp;(albedo)&nbsp;multiplier<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;metallic:&nbsp;0&nbsp;=&nbsp;dielectric,&nbsp;1&nbsp;=&nbsp;metal<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;roughness:&nbsp;0&nbsp;=&nbsp;smooth/mirror,&nbsp;1&nbsp;=&nbsp;rough/matte<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;__new__(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cls,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;color:&nbsp;tuple[float,&nbsp;float,&nbsp;float,&nbsp;float]&nbsp;|&nbsp;None&nbsp;=&nbsp;None,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;metallic:&nbsp;float&nbsp;=&nbsp;0.0,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;roughness:&nbsp;float&nbsp;=&nbsp;0.5,<br>
&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;-&gt;&nbsp;TcMaterial:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;create_pbr_material(color=color,&nbsp;metallic=metallic,&nbsp;roughness=roughness)<br>
<!-- END SCAT CODE -->
</body>
</html>
