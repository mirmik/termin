<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>termin/linalg/subspaces.py</title>
</head>
<body>
<!-- BEGIN SCAT CODE -->
import&nbsp;numpy<br>
<br>
<br>
def&nbsp;_ensure_inexact(A):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Конвертирует&nbsp;целочисленные&nbsp;массивы&nbsp;в&nbsp;float,&nbsp;сохраняя&nbsp;float/complex&nbsp;типы.&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;=&nbsp;numpy.asarray(A)<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;numpy.issubdtype(A.dtype,&nbsp;numpy.inexact):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Конвертируем&nbsp;целые&nbsp;числа&nbsp;в&nbsp;float64<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;numpy.asarray(A,&nbsp;dtype=float)<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Оставляем&nbsp;float32/float64/complex&nbsp;как&nbsp;есть<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;A<br>
<br>
<br>
def&nbsp;nullspace_projector(A):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Возвращает&nbsp;матрицу&nbsp;ортогонального&nbsp;проектора&nbsp;на&nbsp;нуль-пространство&nbsp;матрицы&nbsp;A.<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Проектор&nbsp;P&nbsp;обладает&nbsp;свойствами:<br>
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;A&nbsp;@&nbsp;P&nbsp;=&nbsp;0&nbsp;(проекция&nbsp;попадает&nbsp;в&nbsp;нуль-пространство)<br>
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;P&nbsp;@&nbsp;P&nbsp;=&nbsp;P&nbsp;(идемпотентность)<br>
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;P.T&nbsp;=&nbsp;P&nbsp;(для&nbsp;вещественных&nbsp;матриц&nbsp;-&nbsp;симметричность)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A:&nbsp;Матрица&nbsp;размера&nbsp;(m,&nbsp;n)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Матрица&nbsp;проектора&nbsp;размера&nbsp;(n,&nbsp;n)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Notes:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Для&nbsp;проекции&nbsp;вектора&nbsp;v&nbsp;на&nbsp;нуль-пространство:&nbsp;v_proj&nbsp;=&nbsp;P&nbsp;@&nbsp;v<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Использует&nbsp;SVD-разложение&nbsp;для&nbsp;оптимальной&nbsp;производительности.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;=&nbsp;_ensure_inexact(A)<br>
&nbsp;&nbsp;&nbsp;&nbsp;u,&nbsp;s,&nbsp;vh&nbsp;=&nbsp;numpy.linalg.svd(A,&nbsp;full_matrices=True)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Определяем&nbsp;ранг&nbsp;матрицы<br>
&nbsp;&nbsp;&nbsp;&nbsp;tol&nbsp;=&nbsp;max(A.shape)&nbsp;*&nbsp;numpy.finfo(A.dtype).eps&nbsp;*&nbsp;s[0]&nbsp;if&nbsp;s.size&nbsp;&gt;&nbsp;0&nbsp;else&nbsp;0<br>
&nbsp;&nbsp;&nbsp;&nbsp;rank&nbsp;=&nbsp;numpy.sum(s&nbsp;&gt;&nbsp;tol)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Базис&nbsp;нуль-пространства&nbsp;=&nbsp;правые&nbsp;сингулярные&nbsp;векторы&nbsp;для&nbsp;нулевых&nbsp;сингулярных&nbsp;чисел<br>
&nbsp;&nbsp;&nbsp;&nbsp;null_basis&nbsp;=&nbsp;vh[rank:].T.conj()<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Проектор&nbsp;=&nbsp;базис&nbsp;@&nbsp;базис.T<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;null_basis.size&nbsp;&gt;&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;null_basis&nbsp;@&nbsp;null_basis.T.conj()<br>
&nbsp;&nbsp;&nbsp;&nbsp;else:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Нуль-пространство&nbsp;пустое&nbsp;-&nbsp;возвращаем&nbsp;нулевой&nbsp;проектор<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;numpy.zeros((A.shape[1],&nbsp;A.shape[1]),&nbsp;dtype=A.dtype)<br>
<br>
<br>
def&nbsp;nullspace_basis_svd(A,&nbsp;rtol=None,&nbsp;atol=None):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Ортонормированный&nbsp;базис&nbsp;ker(A),&nbsp;полученный&nbsp;через&nbsp;SVD&nbsp;A&nbsp;=&nbsp;U&nbsp;Σ&nbsp;V^H.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Правые&nbsp;сингулярные&nbsp;векторы,&nbsp;соответствующие&nbsp;нулевым&nbsp;σ,&nbsp;образуют&nbsp;базис<br>
&nbsp;&nbsp;&nbsp;&nbsp;нуль-пространства.&nbsp;В&nbsp;реализации&nbsp;отбрасываются&nbsp;σ&nbsp;ниже&nbsp;заданного&nbsp;порога.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A:&nbsp;Матрица&nbsp;размера&nbsp;(m,&nbsp;n)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rtol:&nbsp;Относительный&nbsp;порог&nbsp;для&nbsp;сингулярных&nbsp;чисел&nbsp;(≈&nbsp;eps&nbsp;·&nbsp;max(m,&nbsp;n)).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;atol:&nbsp;Абсолютный&nbsp;порог&nbsp;(если&nbsp;задан,&nbsp;имеет&nbsp;приоритет&nbsp;над&nbsp;rtol).<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Матрица&nbsp;(n,&nbsp;k)&nbsp;с&nbsp;ортонормированными&nbsp;столбцами&nbsp;basis,&nbsp;где&nbsp;A&nbsp;@&nbsp;basis&nbsp;=&nbsp;0.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Если&nbsp;ker(A)&nbsp;тривиально,&nbsp;возвращается&nbsp;массив&nbsp;формы&nbsp;(n,&nbsp;0).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;=&nbsp;_ensure_inexact(A)<br>
&nbsp;&nbsp;&nbsp;&nbsp;u,&nbsp;s,&nbsp;vh&nbsp;=&nbsp;numpy.linalg.svd(A,&nbsp;full_matrices=True)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;atol&nbsp;is&nbsp;not&nbsp;None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tol&nbsp;=&nbsp;atol<br>
&nbsp;&nbsp;&nbsp;&nbsp;else:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;rtol&nbsp;is&nbsp;None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rtol&nbsp;=&nbsp;max(A.shape)&nbsp;*&nbsp;numpy.finfo(A.dtype).eps<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tol&nbsp;=&nbsp;rtol&nbsp;*&nbsp;s[0]&nbsp;if&nbsp;s.size&nbsp;&gt;&nbsp;0&nbsp;else&nbsp;rtol<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;rank&nbsp;=&nbsp;numpy.sum(s&nbsp;&gt;&nbsp;tol)<br>
&nbsp;&nbsp;&nbsp;&nbsp;null_basis&nbsp;=&nbsp;vh[rank:].T.conj()<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;null_basis.size&nbsp;==&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;numpy.zeros((A.shape[1],&nbsp;0),&nbsp;dtype=A.dtype)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;null_basis<br>
<br>
<br>
def&nbsp;nullspace_basis_qr(A,&nbsp;rtol=None,&nbsp;atol=None):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Ортонормированный&nbsp;базис&nbsp;ker(A)&nbsp;по&nbsp;формуле&nbsp;A^T&nbsp;=&nbsp;Q&nbsp;R&nbsp;(полный&nbsp;QR).<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Если&nbsp;r&nbsp;=&nbsp;rank(A),&nbsp;то&nbsp;строки&nbsp;A&nbsp;лежат&nbsp;в&nbsp;span(Q[:,&nbsp;:r])&nbsp;и<br>
&nbsp;&nbsp;&nbsp;&nbsp;ker(A)&nbsp;=&nbsp;(rowspace(A))^⊥&nbsp;=&nbsp;span(Q[:,&nbsp;r:]).&nbsp;Хвостовые&nbsp;столбцы&nbsp;Q&nbsp;уже<br>
&nbsp;&nbsp;&nbsp;&nbsp;ортонормированы&nbsp;и&nbsp;задают&nbsp;искомый&nbsp;базис.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A:&nbsp;Матрица&nbsp;размера&nbsp;(m,&nbsp;n)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rtol:&nbsp;Относительный&nbsp;порог&nbsp;для&nbsp;диагонали&nbsp;R.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;atol:&nbsp;Абсолютный&nbsp;порог&nbsp;(если&nbsp;задан,&nbsp;имеет&nbsp;приоритет).<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Матрица&nbsp;(n,&nbsp;k)&nbsp;с&nbsp;ортонормированными&nbsp;столбцами&nbsp;ker(A).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Если&nbsp;дополнение&nbsp;тривиально,&nbsp;возвращается&nbsp;массив&nbsp;формы&nbsp;(n,&nbsp;0).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;=&nbsp;_ensure_inexact(A)<br>
&nbsp;&nbsp;&nbsp;&nbsp;m,&nbsp;n&nbsp;=&nbsp;A.shape<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;n&nbsp;==&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;numpy.zeros((0,&nbsp;0),&nbsp;dtype=A.dtype)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Q,&nbsp;R&nbsp;=&nbsp;numpy.linalg.qr(A.T,&nbsp;mode=&quot;complete&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;diag_len&nbsp;=&nbsp;min(n,&nbsp;m)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;diag_len&nbsp;==&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rank&nbsp;=&nbsp;0<br>
&nbsp;&nbsp;&nbsp;&nbsp;else:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;diag&nbsp;=&nbsp;numpy.abs(numpy.diag(R[:diag_len,&nbsp;:diag_len]))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max_diag&nbsp;=&nbsp;diag.max()&nbsp;if&nbsp;diag.size&nbsp;&gt;&nbsp;0&nbsp;else&nbsp;0.0<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;atol&nbsp;is&nbsp;not&nbsp;None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tol&nbsp;=&nbsp;atol<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;rtol&nbsp;is&nbsp;None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rtol&nbsp;=&nbsp;max(m,&nbsp;n)&nbsp;*&nbsp;numpy.finfo(A.dtype).eps<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tol&nbsp;=&nbsp;rtol&nbsp;*&nbsp;max_diag&nbsp;if&nbsp;max_diag&nbsp;&gt;&nbsp;0&nbsp;else&nbsp;rtol<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rank&nbsp;=&nbsp;int(numpy.sum(diag&nbsp;&gt;&nbsp;tol))<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Q[:,&nbsp;rank:]<br>
<br>
<br>
def&nbsp;nullspace_basis(A,&nbsp;rtol=None,&nbsp;atol=None,&nbsp;method=&quot;svd&quot;):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Возвращает&nbsp;ортонормированный&nbsp;базис&nbsp;ker(A)&nbsp;с&nbsp;выбранным&nbsp;алгоритмом.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A:&nbsp;Матрица&nbsp;размера&nbsp;(m,&nbsp;n)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rtol:&nbsp;Относительный&nbsp;порог&nbsp;толеранса.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;atol:&nbsp;Абсолютный&nbsp;порог&nbsp;толеранса.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;method:&nbsp;'svd'&nbsp;(устойчивее)&nbsp;или&nbsp;'qr'&nbsp;(быстрее&nbsp;для&nbsp;узких&nbsp;матриц).<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Матрица&nbsp;(n,&nbsp;k),&nbsp;столбцы&nbsp;которой&nbsp;образуют&nbsp;базис&nbsp;нуль-пространства.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Raises:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ValueError:&nbsp;если&nbsp;указан&nbsp;неподдерживаемый&nbsp;method.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;method&nbsp;is&nbsp;None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;method&nbsp;=&nbsp;&quot;svd&quot;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;method&nbsp;==&nbsp;&quot;svd&quot;:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;nullspace_basis_svd(A,&nbsp;rtol=rtol,&nbsp;atol=atol)<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;method&nbsp;==&nbsp;&quot;qr&quot;:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;nullspace_basis_qr(A,&nbsp;rtol=rtol,&nbsp;atol=atol)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;raise&nbsp;ValueError(f&quot;Unsupported&nbsp;nullspace&nbsp;method&nbsp;'{method}'.&nbsp;Use&nbsp;'svd'&nbsp;or&nbsp;'qr'.&quot;)<br>
<br>
<br>
def&nbsp;rowspace_projector(A):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Возвращает&nbsp;матрицу&nbsp;ортогонального&nbsp;проектора&nbsp;на&nbsp;пространство&nbsp;строк&nbsp;матрицы&nbsp;A.<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Пространство&nbsp;строк&nbsp;(row&nbsp;space)&nbsp;-&nbsp;это&nbsp;ортогональное&nbsp;дополнение&nbsp;к&nbsp;нуль-пространству.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Проектор&nbsp;P&nbsp;обладает&nbsp;свойствами:<br>
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;P&nbsp;@&nbsp;v&nbsp;лежит&nbsp;в&nbsp;пространстве&nbsp;строк&nbsp;для&nbsp;любого&nbsp;v<br>
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;P&nbsp;+&nbsp;nullspace_projector(A)&nbsp;=&nbsp;I&nbsp;(дополнение)<br>
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;P&nbsp;@&nbsp;P&nbsp;=&nbsp;P&nbsp;(идемпотентность)<br>
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;P.T&nbsp;=&nbsp;P&nbsp;(для&nbsp;вещественных&nbsp;матриц&nbsp;-&nbsp;симметричность)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A:&nbsp;Матрица&nbsp;размера&nbsp;(m,&nbsp;n)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Матрица&nbsp;проектора&nbsp;размера&nbsp;(n,&nbsp;n)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Notes:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Для&nbsp;проекции&nbsp;вектора&nbsp;v&nbsp;на&nbsp;пространство&nbsp;строк:&nbsp;v_proj&nbsp;=&nbsp;P&nbsp;@&nbsp;v<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rowspace_projector(A)&nbsp;=&nbsp;I&nbsp;-&nbsp;nullspace_projector(A)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;=&nbsp;_ensure_inexact(A)<br>
&nbsp;&nbsp;&nbsp;&nbsp;u,&nbsp;s,&nbsp;vh&nbsp;=&nbsp;numpy.linalg.svd(A,&nbsp;full_matrices=True)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Определяем&nbsp;ранг&nbsp;матрицы<br>
&nbsp;&nbsp;&nbsp;&nbsp;tol&nbsp;=&nbsp;max(A.shape)&nbsp;*&nbsp;numpy.finfo(A.dtype).eps&nbsp;*&nbsp;s[0]&nbsp;if&nbsp;s.size&nbsp;&gt;&nbsp;0&nbsp;else&nbsp;0<br>
&nbsp;&nbsp;&nbsp;&nbsp;rank&nbsp;=&nbsp;numpy.sum(s&nbsp;&gt;&nbsp;tol)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Базис&nbsp;пространства&nbsp;строк&nbsp;=&nbsp;правые&nbsp;сингулярные&nbsp;векторы&nbsp;для&nbsp;ненулевых&nbsp;σ<br>
&nbsp;&nbsp;&nbsp;&nbsp;row_basis&nbsp;=&nbsp;vh[:rank].T.conj()<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Проектор&nbsp;=&nbsp;базис&nbsp;@&nbsp;базис.T<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;row_basis.size&nbsp;&gt;&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;row_basis&nbsp;@&nbsp;row_basis.T.conj()<br>
&nbsp;&nbsp;&nbsp;&nbsp;else:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Пространство&nbsp;строк&nbsp;пустое&nbsp;-&nbsp;возвращаем&nbsp;нулевой&nbsp;проектор<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;numpy.zeros((A.shape[1],&nbsp;A.shape[1]),&nbsp;dtype=A.dtype)<br>
<br>
<br>
def&nbsp;rowspace_basis(A,&nbsp;rtol=None):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Возвращает&nbsp;ортонормированный&nbsp;базис&nbsp;пространства&nbsp;строк&nbsp;матрицы&nbsp;A.<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Пространство&nbsp;строк&nbsp;(row&nbsp;space)&nbsp;состоит&nbsp;из&nbsp;всех&nbsp;линейных&nbsp;комбинаций&nbsp;строк&nbsp;A.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Это&nbsp;ортогональное&nbsp;дополнение&nbsp;к&nbsp;нуль-пространству:&nbsp;rowspace&nbsp;⊕&nbsp;nullspace&nbsp;=&nbsp;R^n.<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A:&nbsp;Матрица&nbsp;размера&nbsp;(m,&nbsp;n)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rtol:&nbsp;Относительный&nbsp;порог&nbsp;для&nbsp;определения&nbsp;нулевых&nbsp;сингулярных&nbsp;чисел.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;По&nbsp;умолчанию:&nbsp;max(m,&nbsp;n)&nbsp;*&nbsp;машинная_точность&nbsp;*&nbsp;max(сингулярное_число)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Матрица&nbsp;размера&nbsp;(n,&nbsp;k)&nbsp;где&nbsp;k&nbsp;=&nbsp;rank(A)&nbsp;-&nbsp;размерность&nbsp;пространства&nbsp;строк.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Столбцы&nbsp;образуют&nbsp;ортонормированный&nbsp;базис&nbsp;пространства&nbsp;строк.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Если&nbsp;rank(A)&nbsp;=&nbsp;0,&nbsp;возвращает&nbsp;массив&nbsp;формы&nbsp;(n,&nbsp;0).<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Notes:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Использует&nbsp;SVD-разложение&nbsp;для&nbsp;численной&nbsp;устойчивости<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Размерность&nbsp;пространства&nbsp;строк&nbsp;=&nbsp;rank(A)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Векторы&nbsp;базиса&nbsp;ортонормированы:&nbsp;basis.T&nbsp;@&nbsp;basis&nbsp;=&nbsp;I<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Для&nbsp;получения&nbsp;проектора:&nbsp;P&nbsp;=&nbsp;basis&nbsp;@&nbsp;basis.T<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Дополнение:&nbsp;rowspace_basis&nbsp;⊕&nbsp;nullspace_basis&nbsp;=&nbsp;полный&nbsp;базис&nbsp;R^n<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Examples:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;A&nbsp;=&nbsp;np.array([[1,&nbsp;2,&nbsp;3],&nbsp;[2,&nbsp;4,&nbsp;6]])&nbsp;&nbsp;#&nbsp;Ранг&nbsp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;R&nbsp;=&nbsp;rowspace_basis(A)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;R.shape&nbsp;&nbsp;#&nbsp;(3,&nbsp;1)&nbsp;-&nbsp;базис&nbsp;из&nbsp;1&nbsp;вектора<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;N&nbsp;=&nbsp;nullspace_basis(A)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;N.shape&nbsp;&nbsp;#&nbsp;(3,&nbsp;2)&nbsp;-&nbsp;дополнение<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;=&nbsp;_ensure_inexact(A)<br>
&nbsp;&nbsp;&nbsp;&nbsp;u,&nbsp;s,&nbsp;vh&nbsp;=&nbsp;numpy.linalg.svd(A,&nbsp;full_matrices=True)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Определяем&nbsp;порог&nbsp;для&nbsp;малых&nbsp;сингулярных&nbsp;чисел<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;rtol&nbsp;is&nbsp;None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rtol&nbsp;=&nbsp;max(A.shape)&nbsp;*&nbsp;numpy.finfo(A.dtype).eps<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;tol&nbsp;=&nbsp;rtol&nbsp;*&nbsp;s[0]&nbsp;if&nbsp;s.size&nbsp;&gt;&nbsp;0&nbsp;else&nbsp;rtol<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Ранг&nbsp;матрицы&nbsp;=&nbsp;количество&nbsp;сингулярных&nbsp;чисел&nbsp;больше&nbsp;порога<br>
&nbsp;&nbsp;&nbsp;&nbsp;rank&nbsp;=&nbsp;numpy.sum(s&nbsp;&gt;&nbsp;tol)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Пространство&nbsp;строк&nbsp;=&nbsp;правые&nbsp;сингулярные&nbsp;векторы&nbsp;соответствующие&nbsp;ненулевым&nbsp;σ<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Берём&nbsp;строки&nbsp;vh&nbsp;с&nbsp;индексами&nbsp;[:rank]&nbsp;и&nbsp;транспонируем<br>
&nbsp;&nbsp;&nbsp;&nbsp;row_basis&nbsp;=&nbsp;vh[:rank].T.conj()<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;row_basis<br>
<br>
<br>
def&nbsp;colspace_projector(A):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Возвращает&nbsp;матрицу&nbsp;ортогонального&nbsp;проектора&nbsp;на&nbsp;пространство&nbsp;столбцов&nbsp;матрицы&nbsp;A.<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Пространство&nbsp;столбцов&nbsp;(column&nbsp;space,&nbsp;range)&nbsp;-&nbsp;это&nbsp;образ&nbsp;отображения&nbsp;A.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Проектор&nbsp;P&nbsp;обладает&nbsp;свойствами:<br>
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;P&nbsp;@&nbsp;b&nbsp;лежит&nbsp;в&nbsp;colspace&nbsp;для&nbsp;любого&nbsp;b<br>
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;P&nbsp;+&nbsp;left_nullspace_projector(A)&nbsp;=&nbsp;I&nbsp;(дополнение)<br>
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;P&nbsp;@&nbsp;P&nbsp;=&nbsp;P&nbsp;(идемпотентность)<br>
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;P.T&nbsp;=&nbsp;P&nbsp;(для&nbsp;вещественных&nbsp;матриц&nbsp;-&nbsp;симметричность)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A:&nbsp;Матрица&nbsp;размера&nbsp;(m,&nbsp;n)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Матрица&nbsp;проектора&nbsp;размера&nbsp;(m,&nbsp;m)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Notes:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Для&nbsp;проекции&nbsp;вектора&nbsp;b&nbsp;на&nbsp;пространство&nbsp;столбцов:&nbsp;b_proj&nbsp;=&nbsp;P&nbsp;@&nbsp;b<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Если&nbsp;Ax&nbsp;=&nbsp;b&nbsp;несовместна,&nbsp;то&nbsp;Ax&nbsp;=&nbsp;P&nbsp;@&nbsp;b&nbsp;всегда&nbsp;разрешима.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Работает&nbsp;в&nbsp;пространстве&nbsp;значений&nbsp;R^m.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;=&nbsp;_ensure_inexact(A)<br>
&nbsp;&nbsp;&nbsp;&nbsp;u,&nbsp;s,&nbsp;vh&nbsp;=&nbsp;numpy.linalg.svd(A,&nbsp;full_matrices=True)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Определяем&nbsp;ранг&nbsp;матрицы<br>
&nbsp;&nbsp;&nbsp;&nbsp;tol&nbsp;=&nbsp;max(A.shape)&nbsp;*&nbsp;numpy.finfo(A.dtype).eps&nbsp;*&nbsp;s[0]&nbsp;if&nbsp;s.size&nbsp;&gt;&nbsp;0&nbsp;else&nbsp;0<br>
&nbsp;&nbsp;&nbsp;&nbsp;rank&nbsp;=&nbsp;numpy.sum(s&nbsp;&gt;&nbsp;tol)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Базис&nbsp;пространства&nbsp;столбцов&nbsp;=&nbsp;левые&nbsp;сингулярные&nbsp;векторы&nbsp;для&nbsp;ненулевых&nbsp;σ<br>
&nbsp;&nbsp;&nbsp;&nbsp;col_basis&nbsp;=&nbsp;u[:,&nbsp;:rank]<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Проектор&nbsp;=&nbsp;базис&nbsp;@&nbsp;базис.T<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;col_basis.size&nbsp;&gt;&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;col_basis&nbsp;@&nbsp;col_basis.T.conj()<br>
&nbsp;&nbsp;&nbsp;&nbsp;else:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Пространство&nbsp;столбцов&nbsp;пустое&nbsp;-&nbsp;возвращаем&nbsp;нулевой&nbsp;проектор<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;numpy.zeros((A.shape[0],&nbsp;A.shape[0]),&nbsp;dtype=A.dtype)<br>
<br>
<br>
def&nbsp;colspace_basis(A,&nbsp;rtol=None):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Возвращает&nbsp;ортонормированный&nbsp;базис&nbsp;пространства&nbsp;столбцов&nbsp;матрицы&nbsp;A.<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Пространство&nbsp;столбцов&nbsp;(column&nbsp;space,&nbsp;range,&nbsp;образ)&nbsp;состоит&nbsp;из&nbsp;всех&nbsp;векторов&nbsp;вида&nbsp;A&nbsp;@&nbsp;x.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Это&nbsp;ортогональное&nbsp;дополнение&nbsp;к&nbsp;левому&nbsp;нуль-пространству:&nbsp;colspace&nbsp;⊕&nbsp;left_nullspace&nbsp;=&nbsp;R^m.<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A:&nbsp;Матрица&nbsp;размера&nbsp;(m,&nbsp;n)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rtol:&nbsp;Относительный&nbsp;порог&nbsp;для&nbsp;определения&nbsp;нулевых&nbsp;сингулярных&nbsp;чисел.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;По&nbsp;умолчанию:&nbsp;max(m,&nbsp;n)&nbsp;*&nbsp;машинная_точность&nbsp;*&nbsp;max(сингулярное_число)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Матрица&nbsp;размера&nbsp;(m,&nbsp;k)&nbsp;где&nbsp;k&nbsp;=&nbsp;rank(A)&nbsp;-&nbsp;размерность&nbsp;пространства&nbsp;столбцов.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Столбцы&nbsp;образуют&nbsp;ортонормированный&nbsp;базис&nbsp;пространства&nbsp;столбцов.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Если&nbsp;rank(A)&nbsp;=&nbsp;0,&nbsp;возвращает&nbsp;массив&nbsp;формы&nbsp;(m,&nbsp;0).<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Notes:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Использует&nbsp;SVD-разложение&nbsp;для&nbsp;численной&nbsp;устойчивости<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Размерность&nbsp;пространства&nbsp;столбцов&nbsp;=&nbsp;rank(A)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Векторы&nbsp;базиса&nbsp;ортонормированы:&nbsp;basis.T&nbsp;@&nbsp;basis&nbsp;=&nbsp;I<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Для&nbsp;получения&nbsp;проектора:&nbsp;P&nbsp;=&nbsp;basis&nbsp;@&nbsp;basis.T<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Работает&nbsp;в&nbsp;пространстве&nbsp;значений&nbsp;R^m<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Эквивалент&nbsp;scipy.linalg.orth(A)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Examples:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;A&nbsp;=&nbsp;np.array([[1,&nbsp;0],&nbsp;[2,&nbsp;0],&nbsp;[3,&nbsp;0]])&nbsp;&nbsp;#&nbsp;Ранг&nbsp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;C&nbsp;=&nbsp;colspace_basis(A)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;C.shape&nbsp;&nbsp;#&nbsp;(3,&nbsp;1)&nbsp;-&nbsp;базис&nbsp;из&nbsp;1&nbsp;вектора<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;#&nbsp;Любой&nbsp;вектор&nbsp;A&nbsp;@&nbsp;x&nbsp;лежит&nbsp;в&nbsp;span(C)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;=&nbsp;_ensure_inexact(A)<br>
&nbsp;&nbsp;&nbsp;&nbsp;u,&nbsp;s,&nbsp;vh&nbsp;=&nbsp;numpy.linalg.svd(A,&nbsp;full_matrices=True)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Определяем&nbsp;порог&nbsp;для&nbsp;малых&nbsp;сингулярных&nbsp;чисел<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;rtol&nbsp;is&nbsp;None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rtol&nbsp;=&nbsp;max(A.shape)&nbsp;*&nbsp;numpy.finfo(A.dtype).eps<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;tol&nbsp;=&nbsp;rtol&nbsp;*&nbsp;s[0]&nbsp;if&nbsp;s.size&nbsp;&gt;&nbsp;0&nbsp;else&nbsp;rtol<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Ранг&nbsp;матрицы&nbsp;=&nbsp;количество&nbsp;сингулярных&nbsp;чисел&nbsp;больше&nbsp;порога<br>
&nbsp;&nbsp;&nbsp;&nbsp;rank&nbsp;=&nbsp;numpy.sum(s&nbsp;&gt;&nbsp;tol)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Пространство&nbsp;столбцов&nbsp;=&nbsp;левые&nbsp;сингулярные&nbsp;векторы&nbsp;соответствующие&nbsp;ненулевым&nbsp;σ<br>
&nbsp;&nbsp;&nbsp;&nbsp;col_basis&nbsp;=&nbsp;u[:,&nbsp;:rank]<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;col_basis<br>
<br>
<br>
def&nbsp;left_nullspace_projector(A):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Возвращает&nbsp;матрицу&nbsp;ортогонального&nbsp;проектора&nbsp;на&nbsp;левое&nbsp;нуль-пространство&nbsp;матрицы&nbsp;A.<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Левое&nbsp;нуль-пространство&nbsp;состоит&nbsp;из&nbsp;векторов&nbsp;y&nbsp;таких,&nbsp;что&nbsp;A^T&nbsp;@&nbsp;y&nbsp;=&nbsp;0.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Это&nbsp;ортогональное&nbsp;дополнение&nbsp;к&nbsp;пространству&nbsp;столбцов.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Проектор&nbsp;P&nbsp;обладает&nbsp;свойствами:<br>
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;A^T&nbsp;@&nbsp;P&nbsp;=&nbsp;0&nbsp;(эквивалентно:&nbsp;P&nbsp;@&nbsp;A&nbsp;=&nbsp;0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;P&nbsp;+&nbsp;colspace_projector(A)&nbsp;=&nbsp;I&nbsp;(дополнение)<br>
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;P&nbsp;@&nbsp;P&nbsp;=&nbsp;P&nbsp;(идемпотентность)<br>
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;P.T&nbsp;=&nbsp;P&nbsp;(для&nbsp;вещественных&nbsp;матриц&nbsp;-&nbsp;симметричность)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A:&nbsp;Матрица&nbsp;размера&nbsp;(m,&nbsp;n)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Матрица&nbsp;проектора&nbsp;размера&nbsp;(m,&nbsp;m)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Notes:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Для&nbsp;проекции&nbsp;вектора&nbsp;b&nbsp;на&nbsp;левое&nbsp;нуль-пространство:&nbsp;b_proj&nbsp;=&nbsp;P&nbsp;@&nbsp;b<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;left_nullspace(A)&nbsp;=&nbsp;nullspace(A^T)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Работает&nbsp;в&nbsp;пространстве&nbsp;значений&nbsp;R^m.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;=&nbsp;_ensure_inexact(A)<br>
&nbsp;&nbsp;&nbsp;&nbsp;u,&nbsp;s,&nbsp;vh&nbsp;=&nbsp;numpy.linalg.svd(A,&nbsp;full_matrices=True)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Определяем&nbsp;ранг&nbsp;матрицы<br>
&nbsp;&nbsp;&nbsp;&nbsp;tol&nbsp;=&nbsp;max(A.shape)&nbsp;*&nbsp;numpy.finfo(A.dtype).eps&nbsp;*&nbsp;s[0]&nbsp;if&nbsp;s.size&nbsp;&gt;&nbsp;0&nbsp;else&nbsp;0<br>
&nbsp;&nbsp;&nbsp;&nbsp;rank&nbsp;=&nbsp;numpy.sum(s&nbsp;&gt;&nbsp;tol)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Базис&nbsp;левого&nbsp;нуль-пространства&nbsp;=&nbsp;левые&nbsp;сингулярные&nbsp;векторы&nbsp;для&nbsp;нулевых&nbsp;σ<br>
&nbsp;&nbsp;&nbsp;&nbsp;left_null_basis&nbsp;=&nbsp;u[:,&nbsp;rank:]<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Проектор&nbsp;=&nbsp;базис&nbsp;@&nbsp;базис.T<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;left_null_basis.size&nbsp;&gt;&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;left_null_basis&nbsp;@&nbsp;left_null_basis.T.conj()<br>
&nbsp;&nbsp;&nbsp;&nbsp;else:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Левое&nbsp;нуль-пространство&nbsp;пустое&nbsp;-&nbsp;возвращаем&nbsp;нулевой&nbsp;проектор<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;numpy.zeros((A.shape[0],&nbsp;A.shape[0]),&nbsp;dtype=A.dtype)<br>
<br>
<br>
def&nbsp;left_nullspace_basis(A,&nbsp;rtol=None):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Возвращает&nbsp;ортонормированный&nbsp;базис&nbsp;левого&nbsp;нуль-пространства&nbsp;матрицы&nbsp;A.<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Левое&nbsp;нуль-пространство&nbsp;состоит&nbsp;из&nbsp;векторов&nbsp;y&nbsp;таких,&nbsp;что&nbsp;A^T&nbsp;@&nbsp;y&nbsp;=&nbsp;0.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Это&nbsp;ортогональное&nbsp;дополнение&nbsp;к&nbsp;пространству&nbsp;столбцов:&nbsp;left_nullspace&nbsp;⊕&nbsp;colspace&nbsp;=&nbsp;R^m.<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A:&nbsp;Матрица&nbsp;размера&nbsp;(m,&nbsp;n)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rtol:&nbsp;Относительный&nbsp;порог&nbsp;для&nbsp;определения&nbsp;нулевых&nbsp;сингулярных&nbsp;чисел.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;По&nbsp;умолчанию:&nbsp;max(m,&nbsp;n)&nbsp;*&nbsp;машинная_точность&nbsp;*&nbsp;max(сингулярное_число)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Матрица&nbsp;размера&nbsp;(m,&nbsp;k)&nbsp;где&nbsp;k&nbsp;=&nbsp;m&nbsp;-&nbsp;rank(A)&nbsp;-&nbsp;размерность&nbsp;левого&nbsp;нуль-пространства.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Столбцы&nbsp;образуют&nbsp;ортонормированный&nbsp;базис&nbsp;левого&nbsp;нуль-пространства.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Если&nbsp;rank(A)&nbsp;=&nbsp;m,&nbsp;возвращает&nbsp;массив&nbsp;формы&nbsp;(m,&nbsp;0).<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Notes:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Использует&nbsp;SVD-разложение&nbsp;для&nbsp;численной&nbsp;устойчивости<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Размерность&nbsp;левого&nbsp;нуль-пространства&nbsp;=&nbsp;m&nbsp;-&nbsp;rank(A)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Векторы&nbsp;базиса&nbsp;ортонормированы:&nbsp;basis.T&nbsp;@&nbsp;basis&nbsp;=&nbsp;I<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Для&nbsp;получения&nbsp;проектора:&nbsp;P&nbsp;=&nbsp;basis&nbsp;@&nbsp;basis.T<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Работает&nbsp;в&nbsp;пространстве&nbsp;значений&nbsp;R^m<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Эквивалент&nbsp;nullspace_basis(A.T)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Examples:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;A&nbsp;=&nbsp;np.array([[1,&nbsp;2],&nbsp;[2,&nbsp;4],&nbsp;[3,&nbsp;6]])&nbsp;&nbsp;#&nbsp;Ранг&nbsp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;L&nbsp;=&nbsp;left_nullspace_basis(A)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;L.shape&nbsp;&nbsp;#&nbsp;(3,&nbsp;2)&nbsp;-&nbsp;базис&nbsp;из&nbsp;2&nbsp;векторов<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;np.allclose(A.T&nbsp;@&nbsp;L,&nbsp;0)&nbsp;&nbsp;#&nbsp;Проверка:&nbsp;A^T&nbsp;@&nbsp;y&nbsp;=&nbsp;0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;True<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;=&nbsp;_ensure_inexact(A)<br>
&nbsp;&nbsp;&nbsp;&nbsp;u,&nbsp;s,&nbsp;vh&nbsp;=&nbsp;numpy.linalg.svd(A,&nbsp;full_matrices=True)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Определяем&nbsp;порог&nbsp;для&nbsp;малых&nbsp;сингулярных&nbsp;чисел<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;rtol&nbsp;is&nbsp;None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rtol&nbsp;=&nbsp;max(A.shape)&nbsp;*&nbsp;numpy.finfo(A.dtype).eps<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;tol&nbsp;=&nbsp;rtol&nbsp;*&nbsp;s[0]&nbsp;if&nbsp;s.size&nbsp;&gt;&nbsp;0&nbsp;else&nbsp;rtol<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Ранг&nbsp;матрицы&nbsp;=&nbsp;количество&nbsp;сингулярных&nbsp;чисел&nbsp;больше&nbsp;порога<br>
&nbsp;&nbsp;&nbsp;&nbsp;rank&nbsp;=&nbsp;numpy.sum(s&nbsp;&gt;&nbsp;tol)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Левое&nbsp;нуль-пространство&nbsp;=&nbsp;левые&nbsp;сингулярные&nbsp;векторы&nbsp;соответствующие&nbsp;нулевым&nbsp;σ<br>
&nbsp;&nbsp;&nbsp;&nbsp;left_null_basis&nbsp;=&nbsp;u[:,&nbsp;rank:]<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;left_null_basis<br>
<br>
<br>
def&nbsp;vector_projector(u):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Возвращает&nbsp;матрицу&nbsp;ортогонального&nbsp;проектора&nbsp;на&nbsp;направление&nbsp;вектора&nbsp;u.<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Проектор&nbsp;P&nbsp;проецирует&nbsp;любой&nbsp;вектор&nbsp;v&nbsp;на&nbsp;направление&nbsp;u:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;@&nbsp;v&nbsp;=&nbsp;proj_u(v)&nbsp;=&nbsp;(u&nbsp;·&nbsp;v&nbsp;/&nbsp;u&nbsp;·&nbsp;u)&nbsp;*&nbsp;u<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u:&nbsp;Вектор-направление&nbsp;размера&nbsp;(n,)&nbsp;или&nbsp;(n,&nbsp;1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Матрица&nbsp;проектора&nbsp;размера&nbsp;(n,&nbsp;n)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Raises:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ValueError:&nbsp;Если&nbsp;u&nbsp;-&nbsp;нулевой&nbsp;вектор<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Notes:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Проектор&nbsp;имеет&nbsp;вид:&nbsp;P&nbsp;=&nbsp;(u&nbsp;@&nbsp;u.T)&nbsp;/&nbsp;(u.T&nbsp;@&nbsp;u)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Свойства:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;P&nbsp;@&nbsp;P&nbsp;=&nbsp;P&nbsp;(идемпотентность)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;P.T&nbsp;=&nbsp;P&nbsp;(симметричность&nbsp;для&nbsp;вещественных&nbsp;векторов)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;rank(P)&nbsp;=&nbsp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;trace(P)&nbsp;=&nbsp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Examples:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;u&nbsp;=&nbsp;np.array([1.,&nbsp;0.,&nbsp;0.])&nbsp;&nbsp;#&nbsp;Вектор&nbsp;вдоль&nbsp;оси&nbsp;X<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;P&nbsp;=&nbsp;vector_projector(u)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;v&nbsp;=&nbsp;np.array([3.,&nbsp;4.,&nbsp;5.])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;P&nbsp;@&nbsp;v&nbsp;&nbsp;#&nbsp;array([3.,&nbsp;0.,&nbsp;0.])&nbsp;-&nbsp;проекция&nbsp;на&nbsp;ось&nbsp;X<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;u&nbsp;=&nbsp;numpy.asarray(u)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Приводим&nbsp;к&nbsp;вектору-столбцу<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;u.ndim&nbsp;==&nbsp;1:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u&nbsp;=&nbsp;u.reshape(-1,&nbsp;1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;elif&nbsp;u.ndim&nbsp;==&nbsp;2&nbsp;and&nbsp;u.shape[1]&nbsp;!=&nbsp;1:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;raise&nbsp;ValueError(f&quot;u&nbsp;должен&nbsp;быть&nbsp;вектором,&nbsp;получена&nbsp;матрица&nbsp;формы&nbsp;{u.shape}&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Проверка&nbsp;на&nbsp;нулевой&nbsp;вектор<br>
&nbsp;&nbsp;&nbsp;&nbsp;norm_sq&nbsp;=&nbsp;numpy.vdot(u,&nbsp;u).real&nbsp;&nbsp;#&nbsp;u^H&nbsp;@&nbsp;u&nbsp;для&nbsp;комплексных&nbsp;векторов<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;norm_sq&nbsp;==&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;raise&nbsp;ValueError(&quot;Нельзя&nbsp;проецировать&nbsp;на&nbsp;нулевой&nbsp;вектор&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;P&nbsp;=&nbsp;u&nbsp;@&nbsp;u^H&nbsp;/&nbsp;(u^H&nbsp;@&nbsp;u)<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(u&nbsp;@&nbsp;u.T.conj())&nbsp;/&nbsp;norm_sq<br>
<br>
<br>
def&nbsp;subspace_projector(*vectors):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Возвращает&nbsp;матрицу&nbsp;ортогонального&nbsp;проектора&nbsp;на&nbsp;подпространство,&nbsp;натянутое&nbsp;на&nbsp;векторы.<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Проектор&nbsp;P&nbsp;проецирует&nbsp;любой&nbsp;вектор&nbsp;v&nbsp;на&nbsp;подпространство&nbsp;span(u1,&nbsp;u2,&nbsp;...,&nbsp;uk):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;@&nbsp;v&nbsp;=&nbsp;проекция&nbsp;v&nbsp;на&nbsp;span(vectors)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*vectors:&nbsp;Набор&nbsp;векторов,&nbsp;задающих&nbsp;подпространство.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Каждый&nbsp;вектор&nbsp;размера&nbsp;(n,)&nbsp;или&nbsp;(n,&nbsp;1).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Векторы&nbsp;могут&nbsp;быть&nbsp;линейно&nbsp;зависимы&nbsp;(автоматически&nbsp;учитывается).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Матрица&nbsp;проектора&nbsp;размера&nbsp;(n,&nbsp;n)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Raises:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ValueError:&nbsp;Если&nbsp;все&nbsp;векторы&nbsp;нулевые&nbsp;или&nbsp;не&nbsp;переданы<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Notes:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Автоматически&nbsp;ортогонализует&nbsp;векторы&nbsp;через&nbsp;SVD<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Ранг&nbsp;проектора&nbsp;=&nbsp;rank(span(vectors))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Работает&nbsp;для&nbsp;любого&nbsp;количества&nbsp;векторов&nbsp;(k-векторы,&nbsp;бивекторы&nbsp;и&nbsp;т.д.)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Для&nbsp;1&nbsp;вектора&nbsp;эквивалентно&nbsp;vector_projector()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Для&nbsp;2&nbsp;векторов&nbsp;-&nbsp;проектор&nbsp;на&nbsp;плоскость&nbsp;(бивектор)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Examples:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;#&nbsp;Проектор&nbsp;на&nbsp;плоскость&nbsp;XY<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;u1&nbsp;=&nbsp;np.array([1.,&nbsp;0.,&nbsp;0.])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;u2&nbsp;=&nbsp;np.array([0.,&nbsp;1.,&nbsp;0.])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;P&nbsp;=&nbsp;subspace_projector(u1,&nbsp;u2)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;v&nbsp;=&nbsp;np.array([3.,&nbsp;4.,&nbsp;5.])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;P&nbsp;@&nbsp;v&nbsp;&nbsp;#&nbsp;array([3.,&nbsp;4.,&nbsp;0.])&nbsp;-&nbsp;проекция&nbsp;на&nbsp;XY<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;len(vectors)&nbsp;==&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;raise&nbsp;ValueError(&quot;Необходимо&nbsp;передать&nbsp;хотя&nbsp;бы&nbsp;один&nbsp;вектор&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Собираем&nbsp;векторы&nbsp;в&nbsp;матрицу&nbsp;(каждый&nbsp;вектор&nbsp;-&nbsp;строка)<br>
&nbsp;&nbsp;&nbsp;&nbsp;vectors_array&nbsp;=&nbsp;[numpy.asarray(v).flatten()&nbsp;for&nbsp;v&nbsp;in&nbsp;vectors]<br>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;=&nbsp;numpy.vstack(vectors_array)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Используем&nbsp;rowspace_projector&nbsp;-&nbsp;он&nbsp;уже&nbsp;делает&nbsp;всё&nbsp;нужное:<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;-&nbsp;SVD&nbsp;разложение<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;-&nbsp;Учёт&nbsp;линейной&nbsp;зависимости<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;-&nbsp;Ортогонализацию<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;rowspace_projector(A)<br>
<br>
<br>
def&nbsp;orthogonal_complement(P):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Возвращает&nbsp;проектор&nbsp;на&nbsp;ортогональное&nbsp;дополнение&nbsp;подпространства.<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Если&nbsp;P&nbsp;-&nbsp;проектор&nbsp;на&nbsp;подпространство&nbsp;V,&nbsp;то&nbsp;(I&nbsp;-&nbsp;P)&nbsp;-&nbsp;проектор&nbsp;на&nbsp;V⊥.<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P:&nbsp;Матрица&nbsp;ортогонального&nbsp;проектора&nbsp;размера&nbsp;(n,&nbsp;n)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Матрица&nbsp;проектора&nbsp;на&nbsp;ортогональное&nbsp;дополнение&nbsp;размера&nbsp;(n,&nbsp;n)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Notes:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;P&nbsp;+&nbsp;orthogonal_complement(P)&nbsp;=&nbsp;I<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Работает&nbsp;для&nbsp;любого&nbsp;ортогонального&nbsp;проектора<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;dim(V)&nbsp;+&nbsp;dim(V⊥)&nbsp;=&nbsp;n<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Examples:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;#&nbsp;Проектор&nbsp;на&nbsp;ось&nbsp;X<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;P_x&nbsp;=&nbsp;subspace_projector([1.,&nbsp;0.,&nbsp;0.])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;P_perp&nbsp;=&nbsp;orthogonal_complement(P_x)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;#&nbsp;P_perp&nbsp;проецирует&nbsp;на&nbsp;плоскость&nbsp;YZ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;=&nbsp;numpy.asarray(P)<br>
&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;=&nbsp;P.shape[0]<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;numpy.eye(n,&nbsp;dtype=P.dtype)&nbsp;-&nbsp;P<br>
<br>
<br>
def&nbsp;is_in_subspace(v,&nbsp;P,&nbsp;tol=None):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Проверяет,&nbsp;принадлежит&nbsp;ли&nbsp;вектор&nbsp;подпространству.<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Вектор&nbsp;v&nbsp;∈&nbsp;V&nbsp;&lt;=&gt;&nbsp;P&nbsp;@&nbsp;v&nbsp;=&nbsp;v&nbsp;(проекция&nbsp;совпадает&nbsp;с&nbsp;исходным&nbsp;вектором).<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v:&nbsp;Вектор&nbsp;размера&nbsp;(n,)&nbsp;или&nbsp;(n,&nbsp;1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P:&nbsp;Проектор&nbsp;на&nbsp;подпространство&nbsp;V,&nbsp;размер&nbsp;(n,&nbsp;n)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tol:&nbsp;Порог&nbsp;для&nbsp;сравнения&nbsp;||P&nbsp;@&nbsp;v&nbsp;-&nbsp;v||.&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;По&nbsp;умолчанию:&nbsp;sqrt(n)&nbsp;*&nbsp;машинная_точность&nbsp;*&nbsp;||v||<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;True&nbsp;если&nbsp;v&nbsp;∈&nbsp;V,&nbsp;False&nbsp;иначе<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Notes:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Численно&nbsp;устойчиво&nbsp;для&nbsp;малых&nbsp;возмущений<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Для&nbsp;нулевого&nbsp;вектора&nbsp;всегда&nbsp;возвращает&nbsp;True<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Examples:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;P_xy&nbsp;=&nbsp;subspace_projector([1,0,0],&nbsp;[0,1,0])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;is_in_subspace([3,&nbsp;4,&nbsp;0],&nbsp;P_xy)&nbsp;&nbsp;#&nbsp;True<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;is_in_subspace([3,&nbsp;4,&nbsp;5],&nbsp;P_xy)&nbsp;&nbsp;#&nbsp;False<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;v&nbsp;=&nbsp;numpy.asarray(v).flatten()<br>
&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;=&nbsp;numpy.asarray(P)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Проецируем&nbsp;вектор<br>
&nbsp;&nbsp;&nbsp;&nbsp;projected&nbsp;=&nbsp;P&nbsp;@&nbsp;v<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Вычисляем&nbsp;разность<br>
&nbsp;&nbsp;&nbsp;&nbsp;diff&nbsp;=&nbsp;projected&nbsp;-&nbsp;v<br>
&nbsp;&nbsp;&nbsp;&nbsp;diff_norm&nbsp;=&nbsp;numpy.linalg.norm(diff)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Порог&nbsp;по&nbsp;умолчанию<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;tol&nbsp;is&nbsp;None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v_norm&nbsp;=&nbsp;numpy.linalg.norm(v)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;v_norm&nbsp;==&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;True&nbsp;&nbsp;#&nbsp;Нулевой&nbsp;вектор&nbsp;всегда&nbsp;в&nbsp;подпространстве<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tol&nbsp;=&nbsp;numpy.sqrt(len(v))&nbsp;*&nbsp;numpy.finfo(P.dtype).eps&nbsp;*&nbsp;v_norm<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;diff_norm&nbsp;&lt;=&nbsp;tol<br>
<br>
<br>
def&nbsp;subspace_dimension(P,&nbsp;tol=None):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Возвращает&nbsp;размерность&nbsp;подпространства,&nbsp;заданного&nbsp;проектором.<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Размерность&nbsp;=&nbsp;ранг&nbsp;проектора&nbsp;=&nbsp;след&nbsp;проектора.<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P:&nbsp;Проектор&nbsp;на&nbsp;подпространство,&nbsp;размер&nbsp;(n,&nbsp;n)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tol:&nbsp;Порог&nbsp;для&nbsp;определения&nbsp;ненулевых&nbsp;сингулярных&nbsp;чисел.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;По&nbsp;умолчанию:&nbsp;n&nbsp;*&nbsp;машинная_точность&nbsp;*&nbsp;max(сингулярное_число)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Целое&nbsp;число&nbsp;-&nbsp;размерность&nbsp;подпространства&nbsp;(0&nbsp;≤&nbsp;dim&nbsp;≤&nbsp;n)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Notes:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Для&nbsp;ортогонального&nbsp;проектора:&nbsp;dim&nbsp;=&nbsp;rank(P)&nbsp;=&nbsp;trace(P)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Численно&nbsp;более&nbsp;устойчиво&nbsp;использовать&nbsp;ранг,&nbsp;а&nbsp;не&nbsp;след<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Examples:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;P_xy&nbsp;=&nbsp;subspace_projector([1,0,0],&nbsp;[0,1,0])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;subspace_dimension(P_xy)&nbsp;&nbsp;#&nbsp;2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;P_x&nbsp;=&nbsp;vector_projector([1,0,0])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;subspace_dimension(P_x)&nbsp;&nbsp;#&nbsp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;=&nbsp;numpy.asarray(P)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Вычисляем&nbsp;ранг&nbsp;через&nbsp;SVD<br>
&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;=&nbsp;numpy.linalg.svd(P,&nbsp;compute_uv=False)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;tol&nbsp;is&nbsp;None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tol&nbsp;=&nbsp;max(P.shape)&nbsp;*&nbsp;numpy.finfo(P.dtype).eps&nbsp;*&nbsp;s[0]&nbsp;if&nbsp;s.size&nbsp;&gt;&nbsp;0&nbsp;else&nbsp;0<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;rank&nbsp;=&nbsp;numpy.sum(s&nbsp;&gt;&nbsp;tol)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;int(rank)<br>
<br>
<br>
def&nbsp;gram_schmidt(*vectors,&nbsp;tol=None):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Ортогонализует&nbsp;набор&nbsp;векторов&nbsp;классическим&nbsp;методом&nbsp;Грама-Шмидта.<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Итеративно&nbsp;строит&nbsp;ортогональный&nbsp;базис:&nbsp;каждый&nbsp;следующий&nbsp;вектор&nbsp;ортогонализуется<br>
&nbsp;&nbsp;&nbsp;&nbsp;относительно&nbsp;всех&nbsp;предыдущих&nbsp;путём&nbsp;вычитания&nbsp;проекций.<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*vectors:&nbsp;Набор&nbsp;векторов&nbsp;для&nbsp;ортогонализации.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Каждый&nbsp;вектор&nbsp;размера&nbsp;(n,)&nbsp;или&nbsp;(n,&nbsp;1).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tol:&nbsp;Порог&nbsp;для&nbsp;определения&nbsp;нулевых&nbsp;векторов&nbsp;(линейная&nbsp;зависимость).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;По&nbsp;умолчанию:&nbsp;машинная_точность&nbsp;*&nbsp;10<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Массив&nbsp;формы&nbsp;(n,&nbsp;k),&nbsp;где&nbsp;k&nbsp;≤&nbsp;len(vectors)&nbsp;-&nbsp;количество&nbsp;линейно&nbsp;независимых&nbsp;векторов.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Столбцы&nbsp;образуют&nbsp;ортонормированный&nbsp;базис&nbsp;span(vectors).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Если&nbsp;все&nbsp;векторы&nbsp;линейно&nbsp;зависимы,&nbsp;возвращает&nbsp;массив&nbsp;формы&nbsp;(n,&nbsp;0).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Notes:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Классический&nbsp;алгоритм&nbsp;Грама-Шмидта&nbsp;(не&nbsp;модифицированный)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Численно&nbsp;менее&nbsp;стабилен&nbsp;чем&nbsp;SVD,&nbsp;особенно&nbsp;для&nbsp;почти&nbsp;коллинеарных&nbsp;векторов<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Порядок&nbsp;векторов&nbsp;критичен:&nbsp;первые&nbsp;векторы&nbsp;определяют&nbsp;базис<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Для&nbsp;комплексных&nbsp;векторов&nbsp;использует&nbsp;эрмитово&nbsp;скалярное&nbsp;произведение<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Algorithm:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u₁&nbsp;=&nbsp;v₁&nbsp;/&nbsp;||v₁||<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u₂&nbsp;=&nbsp;(v₂&nbsp;-&nbsp;⟨v₂,&nbsp;u₁⟩u₁)&nbsp;/&nbsp;||v₂&nbsp;-&nbsp;⟨v₂,&nbsp;u₁⟩u₁||<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u₃&nbsp;=&nbsp;(v₃&nbsp;-&nbsp;⟨v₃,&nbsp;u₁⟩u₁&nbsp;-&nbsp;⟨v₃,&nbsp;u₂⟩u₂)&nbsp;/&nbsp;||...||<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Examples:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;v1&nbsp;=&nbsp;np.array([1.,&nbsp;1.,&nbsp;0.])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;v2&nbsp;=&nbsp;np.array([1.,&nbsp;0.,&nbsp;0.])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;Q&nbsp;=&nbsp;gram_schmidt(v1,&nbsp;v2)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;np.allclose(Q.T&nbsp;@&nbsp;Q,&nbsp;np.eye(2))&nbsp;&nbsp;#&nbsp;Ортонормированность<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;True<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;len(vectors)&nbsp;==&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;raise&nbsp;ValueError(&quot;Необходимо&nbsp;передать&nbsp;хотя&nbsp;бы&nbsp;один&nbsp;вектор&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Порог&nbsp;по&nbsp;умолчанию<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;tol&nbsp;is&nbsp;None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tol&nbsp;=&nbsp;10&nbsp;*&nbsp;numpy.finfo(float).eps<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Преобразуем&nbsp;векторы&nbsp;в&nbsp;массивы-столбцы<br>
&nbsp;&nbsp;&nbsp;&nbsp;vectors_list&nbsp;=&nbsp;[]<br>
&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;=&nbsp;None<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;v&nbsp;in&nbsp;vectors:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v_arr&nbsp;=&nbsp;numpy.asarray(v).flatten()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;n&nbsp;is&nbsp;None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;=&nbsp;len(v_arr)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif&nbsp;len(v_arr)&nbsp;!=&nbsp;n:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;raise&nbsp;ValueError(f&quot;Все&nbsp;векторы&nbsp;должны&nbsp;иметь&nbsp;одинаковую&nbsp;размерность,&nbsp;получены&nbsp;{n}&nbsp;и&nbsp;{len(v_arr)}&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vectors_list.append(v_arr)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Ортогонализация<br>
&nbsp;&nbsp;&nbsp;&nbsp;orthonormal_basis&nbsp;=&nbsp;[]<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;v&nbsp;in&nbsp;vectors_list:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Начинаем&nbsp;с&nbsp;исходного&nbsp;вектора<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u&nbsp;=&nbsp;v.copy()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Вычитаем&nbsp;проекции&nbsp;на&nbsp;все&nbsp;предыдущие&nbsp;ортонормированные&nbsp;векторы<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;q&nbsp;in&nbsp;orthonormal_basis:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Проекция:&nbsp;proj_q(u)&nbsp;=&nbsp;⟨u,&nbsp;q⟩&nbsp;q<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Для&nbsp;комплексных:&nbsp;используем&nbsp;vdot&nbsp;(сопряжённое&nbsp;скалярное&nbsp;произведение)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;projection_coef&nbsp;=&nbsp;numpy.vdot(q,&nbsp;u)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u&nbsp;=&nbsp;u&nbsp;-&nbsp;projection_coef&nbsp;*&nbsp;q<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Нормализуем<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;norm&nbsp;=&nbsp;numpy.linalg.norm(u)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Если&nbsp;вектор&nbsp;стал&nbsp;нулевым&nbsp;(линейно&nbsp;зависим&nbsp;от&nbsp;предыдущих),&nbsp;пропускаем<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;norm&nbsp;&gt;&nbsp;tol:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u_normalized&nbsp;=&nbsp;u&nbsp;/&nbsp;norm<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;orthonormal_basis.append(u_normalized)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Если&nbsp;нет&nbsp;независимых&nbsp;векторов<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;len(orthonormal_basis)&nbsp;==&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;numpy.empty((n,&nbsp;0),&nbsp;dtype=vectors_list[0].dtype)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Собираем&nbsp;в&nbsp;матрицу&nbsp;(векторы&nbsp;=&nbsp;столбцы)<br>
&nbsp;&nbsp;&nbsp;&nbsp;Q&nbsp;=&nbsp;numpy.column_stack(orthonormal_basis)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Q<br>
<br>
<br>
def&nbsp;orthogonalize_svd(*vectors,&nbsp;tol=None):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Ортогонализует&nbsp;набор&nbsp;векторов&nbsp;через&nbsp;SVD&nbsp;разложение.<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Строит&nbsp;ортонормированный&nbsp;базис&nbsp;подпространства,&nbsp;натянутого&nbsp;на&nbsp;входные&nbsp;векторы,<br>
&nbsp;&nbsp;&nbsp;&nbsp;используя&nbsp;сингулярное&nbsp;разложение&nbsp;(SVD).&nbsp;Численно&nbsp;более&nbsp;стабильный&nbsp;метод,<br>
&nbsp;&nbsp;&nbsp;&nbsp;чем&nbsp;классический&nbsp;Грам-Шмидт.<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*vectors:&nbsp;Набор&nbsp;векторов&nbsp;для&nbsp;ортогонализации.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Каждый&nbsp;вектор&nbsp;размера&nbsp;(n,)&nbsp;или&nbsp;(n,&nbsp;1).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tol:&nbsp;Относительный&nbsp;порог&nbsp;для&nbsp;определения&nbsp;линейной&nbsp;зависимости.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;По&nbsp;умолчанию:&nbsp;max(размеры)&nbsp;*&nbsp;машинная_точность<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Массив&nbsp;формы&nbsp;(n,&nbsp;k),&nbsp;где&nbsp;k&nbsp;≤&nbsp;len(vectors)&nbsp;-&nbsp;количество&nbsp;линейно&nbsp;независимых&nbsp;векторов.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Столбцы&nbsp;образуют&nbsp;ортонормированный&nbsp;базис&nbsp;span(vectors).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Если&nbsp;все&nbsp;векторы&nbsp;нулевые&nbsp;или&nbsp;линейно&nbsp;зависимые&nbsp;от&nbsp;нуля,&nbsp;возвращает&nbsp;массив&nbsp;формы&nbsp;(n,&nbsp;0).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Notes:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Использует&nbsp;SVD&nbsp;для&nbsp;численной&nbsp;устойчивости<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Порядок&nbsp;векторов&nbsp;НЕ&nbsp;влияет&nbsp;на&nbsp;базис&nbsp;(в&nbsp;отличие&nbsp;от&nbsp;Грама-Шмидта)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;SVD&nbsp;выбирает&nbsp;&quot;наилучший&quot;&nbsp;базис&nbsp;(главные&nbsp;направления)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Векторы&nbsp;базиса&nbsp;ортонормированы:&nbsp;Q.T&nbsp;@&nbsp;Q&nbsp;=&nbsp;I<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Для&nbsp;получения&nbsp;проектора:&nbsp;P&nbsp;=&nbsp;Q&nbsp;@&nbsp;Q.T<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Более&nbsp;медленный,&nbsp;но&nbsp;более&nbsp;точный&nbsp;чем&nbsp;Грам-Шмидт<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Examples:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;v1&nbsp;=&nbsp;np.array([3.,&nbsp;4.,&nbsp;0.])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;v2&nbsp;=&nbsp;np.array([1.,&nbsp;0.,&nbsp;1.])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;Q&nbsp;=&nbsp;orthogonalize_svd(v1,&nbsp;v2)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;Q.shape&nbsp;&nbsp;#&nbsp;(3,&nbsp;2)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;np.allclose(Q.T&nbsp;@&nbsp;Q,&nbsp;np.eye(2))&nbsp;&nbsp;#&nbsp;Ортонормированность<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;True<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;#&nbsp;Линейно&nbsp;зависимые&nbsp;векторы<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;v1&nbsp;=&nbsp;np.array([1.,&nbsp;0.,&nbsp;0.])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;v2&nbsp;=&nbsp;np.array([2.,&nbsp;0.,&nbsp;0.])&nbsp;&nbsp;#&nbsp;v2&nbsp;=&nbsp;2*v1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;Q&nbsp;=&nbsp;orthogonalize_svd(v1,&nbsp;v2)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;Q.shape&nbsp;&nbsp;#&nbsp;(3,&nbsp;1)&nbsp;-&nbsp;только&nbsp;один&nbsp;независимый&nbsp;вектор<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;len(vectors)&nbsp;==&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;raise&nbsp;ValueError(&quot;Необходимо&nbsp;передать&nbsp;хотя&nbsp;бы&nbsp;один&nbsp;вектор&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Преобразуем&nbsp;векторы&nbsp;в&nbsp;массив&nbsp;(векторы&nbsp;=&nbsp;строки)<br>
&nbsp;&nbsp;&nbsp;&nbsp;vectors_array&nbsp;=&nbsp;[numpy.asarray(v).flatten()&nbsp;for&nbsp;v&nbsp;in&nbsp;vectors]<br>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;=&nbsp;numpy.vstack(vectors_array)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;SVD&nbsp;разложение<br>
&nbsp;&nbsp;&nbsp;&nbsp;u,&nbsp;s,&nbsp;vh&nbsp;=&nbsp;numpy.linalg.svd(A,&nbsp;full_matrices=True)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Определяем&nbsp;порог&nbsp;для&nbsp;линейной&nbsp;независимости<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;tol&nbsp;is&nbsp;None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tol&nbsp;=&nbsp;max(A.shape)&nbsp;*&nbsp;numpy.finfo(A.dtype).eps<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;threshold&nbsp;=&nbsp;tol&nbsp;*&nbsp;s[0]&nbsp;if&nbsp;s.size&nbsp;&gt;&nbsp;0&nbsp;else&nbsp;tol<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Ранг&nbsp;=&nbsp;количество&nbsp;значимых&nbsp;сингулярных&nbsp;чисел<br>
&nbsp;&nbsp;&nbsp;&nbsp;rank&nbsp;=&nbsp;numpy.sum(s&nbsp;&gt;&nbsp;threshold)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Ортонормированный&nbsp;базис&nbsp;=&nbsp;правые&nbsp;сингулярные&nbsp;векторы&nbsp;для&nbsp;ненулевых&nbsp;σ<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Транспонируем,&nbsp;чтобы&nbsp;векторы&nbsp;были&nbsp;столбцами<br>
&nbsp;&nbsp;&nbsp;&nbsp;orthonormal_basis&nbsp;=&nbsp;vh[:rank].T.conj()<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;orthonormal_basis<br>
<br>
<br>
def&nbsp;orthogonalize(*vectors,&nbsp;method='svd',&nbsp;tol=None):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Ортогонализует&nbsp;набор&nbsp;векторов&nbsp;одним&nbsp;из&nbsp;двух&nbsp;методов.<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Универсальная&nbsp;функция&nbsp;ортогонализации&nbsp;с&nbsp;выбором&nbsp;метода.<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*vectors:&nbsp;Набор&nbsp;векторов&nbsp;для&nbsp;ортогонализации.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Каждый&nbsp;вектор&nbsp;размера&nbsp;(n,)&nbsp;или&nbsp;(n,&nbsp;1).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;method:&nbsp;Метод&nbsp;ортогонализации:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;'svd':&nbsp;SVD&nbsp;разложение&nbsp;(по&nbsp;умолчанию,&nbsp;более&nbsp;стабильный)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;'gram_schmidt'&nbsp;или&nbsp;'gs':&nbsp;классический&nbsp;Грам-Шмидт<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tol:&nbsp;Порог&nbsp;для&nbsp;определения&nbsp;линейной&nbsp;зависимости.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Интерпретация&nbsp;зависит&nbsp;от&nbsp;метода.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Массив&nbsp;формы&nbsp;(n,&nbsp;k),&nbsp;где&nbsp;k&nbsp;≤&nbsp;len(vectors).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Столбцы&nbsp;образуют&nbsp;ортонормированный&nbsp;базис&nbsp;span(vectors).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Notes:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;SVD:&nbsp;численно&nbsp;стабильный,&nbsp;базис&nbsp;не&nbsp;зависит&nbsp;от&nbsp;порядка&nbsp;векторов<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Грам-Шмидт:&nbsp;быстрее,&nbsp;но&nbsp;менее&nbsp;стабильный,&nbsp;порядок&nbsp;векторов&nbsp;важен<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Examples:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;v1&nbsp;=&nbsp;np.array([1.,&nbsp;1.,&nbsp;0.])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;v2&nbsp;=&nbsp;np.array([1.,&nbsp;0.,&nbsp;0.])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;Q_svd&nbsp;=&nbsp;orthogonalize(v1,&nbsp;v2,&nbsp;method='svd')<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;Q_gs&nbsp;=&nbsp;orthogonalize(v1,&nbsp;v2,&nbsp;method='gram_schmidt')<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;#&nbsp;Оба&nbsp;ортонормированы,&nbsp;но&nbsp;могут&nbsp;давать&nbsp;разные&nbsp;базисы<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;method&nbsp;in&nbsp;('svd',&nbsp;'SVD'):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;orthogonalize_svd(*vectors,&nbsp;tol=tol)<br>
&nbsp;&nbsp;&nbsp;&nbsp;elif&nbsp;method&nbsp;in&nbsp;('gram_schmidt',&nbsp;'gs',&nbsp;'GS',&nbsp;'Gram-Schmidt'):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;gram_schmidt(*vectors,&nbsp;tol=tol)<br>
&nbsp;&nbsp;&nbsp;&nbsp;else:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;raise&nbsp;ValueError(f&quot;Неизвестный&nbsp;метод:&nbsp;{method}.&nbsp;Используйте&nbsp;'svd'&nbsp;или&nbsp;'gram_schmidt'&quot;)<br>
<br>
<br>
def&nbsp;is_projector(P,&nbsp;tol=None):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Проверяет,&nbsp;является&nbsp;ли&nbsp;матрица&nbsp;ортогональным&nbsp;проектором.<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Ортогональный&nbsp;проектор&nbsp;должен&nbsp;удовлетворять&nbsp;двум&nbsp;условиям:<br>
&nbsp;&nbsp;&nbsp;&nbsp;1.&nbsp;Идемпотентность:&nbsp;P&nbsp;@&nbsp;P&nbsp;=&nbsp;P<br>
&nbsp;&nbsp;&nbsp;&nbsp;2.&nbsp;Эрмитовость:&nbsp;P^H&nbsp;=&nbsp;P&nbsp;(для&nbsp;вещественных&nbsp;матриц:&nbsp;P.T&nbsp;=&nbsp;P)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P:&nbsp;Матрица&nbsp;для&nbsp;проверки,&nbsp;размер&nbsp;(n,&nbsp;n)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tol:&nbsp;Порог&nbsp;для&nbsp;численного&nbsp;сравнения.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;По&nbsp;умолчанию:&nbsp;sqrt(n)&nbsp;*&nbsp;машинная_точность&nbsp;*&nbsp;||P||<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;True&nbsp;если&nbsp;P&nbsp;-&nbsp;ортогональный&nbsp;проектор,&nbsp;False&nbsp;иначе<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Notes:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Проверяет&nbsp;обе&nbsp;необходимые&nbsp;характеристики&nbsp;проектора<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Учитывает&nbsp;численные&nbsp;погрешности&nbsp;через&nbsp;параметр&nbsp;tol<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Для&nbsp;нулевой&nbsp;матрицы&nbsp;возвращает&nbsp;True&nbsp;(проектор&nbsp;на&nbsp;{0})<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Дополнительно&nbsp;проверяется,&nbsp;что&nbsp;сингулярные&nbsp;числа&nbsp;≈&nbsp;0&nbsp;или&nbsp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Examples:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;#&nbsp;Проектор&nbsp;на&nbsp;ось&nbsp;X<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;P&nbsp;=&nbsp;vector_projector([1.,&nbsp;0.,&nbsp;0.])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;is_projector(P)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;True<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;#&nbsp;Обычная&nbsp;матрица&nbsp;(не&nbsp;проектор)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;A&nbsp;=&nbsp;np.array([[1,&nbsp;2],&nbsp;[3,&nbsp;4]])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;is_projector(A)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;False<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;#&nbsp;Проектор&nbsp;на&nbsp;плоскость<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;P&nbsp;=&nbsp;subspace_projector([1,0,0],&nbsp;[0,1,0])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;is_projector(P)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;True<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;=&nbsp;numpy.asarray(P)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Проверка&nbsp;квадратности<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;P.ndim&nbsp;!=&nbsp;2&nbsp;or&nbsp;P.shape[0]&nbsp;!=&nbsp;P.shape[1]:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;False<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;=&nbsp;P.shape[0]<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Конвертируем&nbsp;в&nbsp;float&nbsp;для&nbsp;корректной&nbsp;работы&nbsp;с&nbsp;numpy.finfo<br>
&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;=&nbsp;_ensure_inexact(P)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Определяем&nbsp;порог<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;tol&nbsp;is&nbsp;None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P_norm&nbsp;=&nbsp;numpy.linalg.norm(P)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;P_norm&nbsp;==&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;True&nbsp;&nbsp;#&nbsp;Нулевая&nbsp;матрица&nbsp;-&nbsp;проектор&nbsp;на&nbsp;{0}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tol&nbsp;=&nbsp;numpy.sqrt(n)&nbsp;*&nbsp;numpy.finfo(P.dtype).eps&nbsp;*&nbsp;P_norm<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;1.&nbsp;Проверка&nbsp;идемпотентности:&nbsp;P&nbsp;@&nbsp;P&nbsp;=&nbsp;P<br>
&nbsp;&nbsp;&nbsp;&nbsp;P_squared&nbsp;=&nbsp;P&nbsp;@&nbsp;P<br>
&nbsp;&nbsp;&nbsp;&nbsp;idempotent&nbsp;=&nbsp;numpy.allclose(P_squared,&nbsp;P,&nbsp;atol=tol)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;idempotent:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;False<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;2.&nbsp;Проверка&nbsp;эрмитовости:&nbsp;P^H&nbsp;=&nbsp;P<br>
&nbsp;&nbsp;&nbsp;&nbsp;P_hermitian&nbsp;=&nbsp;P.T.conj()<br>
&nbsp;&nbsp;&nbsp;&nbsp;hermitian&nbsp;=&nbsp;numpy.allclose(P_hermitian,&nbsp;P,&nbsp;atol=tol)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;hermitian:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;False<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;3.&nbsp;Дополнительная&nbsp;проверка:&nbsp;сингулярные&nbsp;числа&nbsp;должны&nbsp;быть&nbsp;0&nbsp;или&nbsp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;=&nbsp;numpy.linalg.svd(P,&nbsp;compute_uv=False)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Более&nbsp;мягкий&nbsp;tolerance&nbsp;для&nbsp;сингулярных&nbsp;чисел<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;(SVD&nbsp;может&nbsp;давать&nbsp;разную&nbsp;точность&nbsp;на&nbsp;разных&nbsp;версиях&nbsp;NumPy/Python)<br>
&nbsp;&nbsp;&nbsp;&nbsp;svd_tol&nbsp;=&nbsp;max(tol,&nbsp;10&nbsp;*&nbsp;numpy.finfo(P.dtype).eps&nbsp;*&nbsp;P_norm)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Проверяем,&nbsp;что&nbsp;каждое&nbsp;сингулярное&nbsp;число&nbsp;близко&nbsp;либо&nbsp;к&nbsp;0,&nbsp;либо&nbsp;к&nbsp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;sigma&nbsp;in&nbsp;s:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Расстояние&nbsp;до&nbsp;ближайшего&nbsp;из&nbsp;{0,&nbsp;1}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;distance_to_binary&nbsp;=&nbsp;min(abs(sigma&nbsp;-&nbsp;0.0),&nbsp;abs(sigma&nbsp;-&nbsp;1.0))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;distance_to_binary&nbsp;&gt;&nbsp;svd_tol:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;False<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;True<br>
<br>
<br>
def&nbsp;projector_basis(P,&nbsp;rtol=None):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Извлекает&nbsp;ортонормированный&nbsp;базис&nbsp;подпространства&nbsp;из&nbsp;проектора.<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Для&nbsp;проектора&nbsp;P&nbsp;на&nbsp;подпространство&nbsp;V&nbsp;возвращает&nbsp;матрицу&nbsp;Q,&nbsp;столбцы&nbsp;которой<br>
&nbsp;&nbsp;&nbsp;&nbsp;образуют&nbsp;ортонормированный&nbsp;базис&nbsp;V.&nbsp;Обратная&nbsp;операция:&nbsp;P&nbsp;=&nbsp;Q&nbsp;@&nbsp;Q.T<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P:&nbsp;Ортогональный&nbsp;проектор&nbsp;на&nbsp;подпространство,&nbsp;размер&nbsp;(n,&nbsp;n)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rtol:&nbsp;Относительный&nbsp;порог&nbsp;для&nbsp;определения&nbsp;ранга&nbsp;проектора.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;По&nbsp;умолчанию:&nbsp;max(n)&nbsp;*&nbsp;машинная_точность<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Матрица&nbsp;размера&nbsp;(n,&nbsp;k)&nbsp;где&nbsp;k&nbsp;=&nbsp;dim(V)&nbsp;=&nbsp;rank(P).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Столбцы&nbsp;образуют&nbsp;ортонормированный&nbsp;базис&nbsp;подпространства.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Если&nbsp;P&nbsp;=&nbsp;0&nbsp;(тривиальное&nbsp;подпространство),&nbsp;возвращает&nbsp;массив&nbsp;формы&nbsp;(n,&nbsp;0).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Notes:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Использует&nbsp;SVD&nbsp;разложение&nbsp;проектора<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Базис&nbsp;извлекается&nbsp;из&nbsp;правых&nbsp;сингулярных&nbsp;векторов<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Векторы&nbsp;ортонормированы:&nbsp;Q.T&nbsp;@&nbsp;Q&nbsp;=&nbsp;I_k<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Проверка:&nbsp;P&nbsp;≈&nbsp;Q&nbsp;@&nbsp;Q.T&nbsp;(с&nbsp;точностью&nbsp;до&nbsp;численных&nbsp;ошибок)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Examples:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;#&nbsp;Создаём&nbsp;проектор&nbsp;на&nbsp;плоскость&nbsp;XY<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;P&nbsp;=&nbsp;subspace_projector([1,0,0],&nbsp;[0,1,0])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;Q&nbsp;=&nbsp;projector_basis(P)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;Q.shape&nbsp;&nbsp;#&nbsp;(3,&nbsp;2)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;np.allclose(P,&nbsp;Q&nbsp;@&nbsp;Q.T)&nbsp;&nbsp;#&nbsp;Восстановление&nbsp;проектора<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;True<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;=&nbsp;numpy.asarray(P)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;SVD&nbsp;разложение&nbsp;проектора<br>
&nbsp;&nbsp;&nbsp;&nbsp;u,&nbsp;s,&nbsp;vh&nbsp;=&nbsp;numpy.linalg.svd(P,&nbsp;full_matrices=True)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Определяем&nbsp;порог<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;rtol&nbsp;is&nbsp;None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rtol&nbsp;=&nbsp;max(P.shape)&nbsp;*&nbsp;numpy.finfo(P.dtype).eps<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;threshold&nbsp;=&nbsp;rtol&nbsp;*&nbsp;s[0]&nbsp;if&nbsp;s.size&nbsp;&gt;&nbsp;0&nbsp;else&nbsp;rtol<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Ранг&nbsp;=&nbsp;количество&nbsp;значимых&nbsp;сингулярных&nbsp;чисел<br>
&nbsp;&nbsp;&nbsp;&nbsp;rank&nbsp;=&nbsp;numpy.sum(s&nbsp;&gt;&nbsp;threshold)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;rank&nbsp;==&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Тривиальное&nbsp;подпространство&nbsp;{0}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;numpy.empty((P.shape[0],&nbsp;0),&nbsp;dtype=P.dtype)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Базис&nbsp;=&nbsp;правые&nbsp;сингулярные&nbsp;векторы&nbsp;для&nbsp;ненулевых&nbsp;σ<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;(транспонируем,&nbsp;чтобы&nbsp;векторы&nbsp;были&nbsp;столбцами)<br>
&nbsp;&nbsp;&nbsp;&nbsp;basis&nbsp;=&nbsp;vh[:rank].T.conj()<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;basis<br>
<br>
<br>
def&nbsp;subspace_intersection(P1,&nbsp;P2,&nbsp;tol=None):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Возвращает&nbsp;проектор&nbsp;на&nbsp;пересечение&nbsp;двух&nbsp;подпространств.<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Вычисляет&nbsp;проектор&nbsp;на&nbsp;V1&nbsp;∩&nbsp;V2,&nbsp;где&nbsp;V1&nbsp;и&nbsp;V2&nbsp;заданы&nbsp;проекторами&nbsp;P1&nbsp;и&nbsp;P2.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Использует&nbsp;метод&nbsp;через&nbsp;нуль-пространство:&nbsp;V1&nbsp;∩&nbsp;V2&nbsp;=&nbsp;V1&nbsp;∩&nbsp;ker(I&nbsp;-&nbsp;P2).<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P1:&nbsp;Проектор&nbsp;на&nbsp;первое&nbsp;подпространство&nbsp;V1,&nbsp;размер&nbsp;(n,&nbsp;n)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P2:&nbsp;Проектор&nbsp;на&nbsp;второе&nbsp;подпространство&nbsp;V2,&nbsp;размер&nbsp;(n,&nbsp;n)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tol:&nbsp;Порог&nbsp;для&nbsp;определения&nbsp;линейной&nbsp;зависимости.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;По&nbsp;умолчанию:&nbsp;max(n)&nbsp;*&nbsp;машинная_точность<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Матрица&nbsp;проектора&nbsp;на&nbsp;пересечение&nbsp;V1&nbsp;∩&nbsp;V2,&nbsp;размер&nbsp;(n,&nbsp;n)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Notes:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Если&nbsp;подпространства&nbsp;не&nbsp;пересекаются&nbsp;(только&nbsp;в&nbsp;0),&nbsp;возвращает&nbsp;нулевой&nbsp;проектор<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Метод:&nbsp;находим&nbsp;базис&nbsp;V1,&nbsp;проецируем&nbsp;на&nbsp;V2,&nbsp;ищем&nbsp;векторы,&nbsp;оставшиеся&nbsp;в&nbsp;V1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Математически:&nbsp;v&nbsp;∈&nbsp;V1&nbsp;∩&nbsp;V2&nbsp;⟺&nbsp;v&nbsp;∈&nbsp;V1&nbsp;и&nbsp;P2&nbsp;@&nbsp;v&nbsp;=&nbsp;v<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;dim(V1&nbsp;∩&nbsp;V2)&nbsp;≤&nbsp;min(dim(V1),&nbsp;dim(V2))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Для&nbsp;ортогональных&nbsp;подпространств:&nbsp;V1&nbsp;∩&nbsp;V2&nbsp;=&nbsp;{0}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Examples:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;#&nbsp;Плоскость&nbsp;XY&nbsp;и&nbsp;плоскость&nbsp;XZ&nbsp;пересекаются&nbsp;по&nbsp;оси&nbsp;X<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;P_xy&nbsp;=&nbsp;subspace_projector([1,0,0],&nbsp;[0,1,0])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;P_xz&nbsp;=&nbsp;subspace_projector([1,0,0],&nbsp;[0,0,1])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;P_x&nbsp;=&nbsp;subspace_intersection(P_xy,&nbsp;P_xz)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;#&nbsp;P_x&nbsp;-&nbsp;проектор&nbsp;на&nbsp;ось&nbsp;X&nbsp;(dim&nbsp;=&nbsp;1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;#&nbsp;Ортогональные&nbsp;подпространства<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;P_x&nbsp;=&nbsp;vector_projector([1,0,0])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;P_y&nbsp;=&nbsp;vector_projector([0,1,0])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;P_int&nbsp;=&nbsp;subspace_intersection(P_x,&nbsp;P_y)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;#&nbsp;P_int&nbsp;≈&nbsp;0&nbsp;(пересечение&nbsp;пустое)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;P1&nbsp;=&nbsp;numpy.asarray(P1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;P2&nbsp;=&nbsp;numpy.asarray(P2)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;P1.shape&nbsp;!=&nbsp;P2.shape:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;raise&nbsp;ValueError(f&quot;Проекторы&nbsp;должны&nbsp;иметь&nbsp;одинаковый&nbsp;размер,&nbsp;получены&nbsp;{P1.shape}&nbsp;и&nbsp;{P2.shape}&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Извлекаем&nbsp;базис&nbsp;V1&nbsp;из&nbsp;проектора&nbsp;P1<br>
&nbsp;&nbsp;&nbsp;&nbsp;basis1&nbsp;=&nbsp;projector_basis(P1,&nbsp;rtol=tol)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;basis1.size&nbsp;==&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;V1&nbsp;=&nbsp;{0},&nbsp;пересечение&nbsp;пустое<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;numpy.zeros_like(P1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Проецируем&nbsp;базисные&nbsp;векторы&nbsp;V1&nbsp;на&nbsp;V2<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Вектор&nbsp;v&nbsp;∈&nbsp;V1&nbsp;лежит&nbsp;в&nbsp;V1&nbsp;∩&nbsp;V2&nbsp;⟺&nbsp;P2&nbsp;@&nbsp;v&nbsp;=&nbsp;v<br>
&nbsp;&nbsp;&nbsp;&nbsp;projected_basis&nbsp;=&nbsp;P2&nbsp;@&nbsp;basis1<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Разность:&nbsp;(P2&nbsp;@&nbsp;v&nbsp;-&nbsp;v)&nbsp;должна&nbsp;быть&nbsp;нулевой&nbsp;для&nbsp;векторов&nbsp;из&nbsp;пересечения<br>
&nbsp;&nbsp;&nbsp;&nbsp;diff&nbsp;=&nbsp;projected_basis&nbsp;-&nbsp;basis1<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Находим&nbsp;нуль-пространство&nbsp;diff&nbsp;(линейные&nbsp;комбинации&nbsp;столбцов&nbsp;basis1,<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;которые&nbsp;не&nbsp;изменяются&nbsp;при&nbsp;проекции&nbsp;на&nbsp;V2)<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;diff&nbsp;@&nbsp;c&nbsp;≈&nbsp;0&nbsp;&nbsp;=&gt;&nbsp;&nbsp;c&nbsp;задаёт&nbsp;вектор&nbsp;из&nbsp;пересечения<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Определяем&nbsp;абсолютный&nbsp;порог&nbsp;для&nbsp;сингулярных&nbsp;чисел<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Используем&nbsp;норму&nbsp;базиса&nbsp;как&nbsp;характерный&nbsp;масштаб<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;tol&nbsp;is&nbsp;None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tol&nbsp;=&nbsp;max(P1.shape)&nbsp;*&nbsp;numpy.finfo(P1.dtype).eps<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Абсолютный&nbsp;порог&nbsp;учитывает&nbsp;масштаб&nbsp;задачи<br>
&nbsp;&nbsp;&nbsp;&nbsp;threshold&nbsp;=&nbsp;tol&nbsp;*&nbsp;max(1.0,&nbsp;numpy.linalg.norm(basis1))<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Используем&nbsp;существующую&nbsp;функцию&nbsp;с&nbsp;абсолютным&nbsp;порогом<br>
&nbsp;&nbsp;&nbsp;&nbsp;null_coefs&nbsp;=&nbsp;nullspace_basis(diff,&nbsp;atol=threshold)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;null_coefs.size&nbsp;==&nbsp;0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Пересечение&nbsp;пустое&nbsp;(только&nbsp;нулевой&nbsp;вектор)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;numpy.zeros_like(P1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Строим&nbsp;базис&nbsp;пересечения:&nbsp;линейные&nbsp;комбинации&nbsp;basis1<br>
&nbsp;&nbsp;&nbsp;&nbsp;intersection_basis&nbsp;=&nbsp;basis1&nbsp;@&nbsp;null_coefs<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Проектор&nbsp;=&nbsp;базис&nbsp;@&nbsp;базис^H<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;intersection_basis&nbsp;@&nbsp;intersection_basis.T.conj()<br>
<br>
<br>
def&nbsp;project_onto_affine(x,&nbsp;C,&nbsp;b):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Возвращает&nbsp;ортогональную&nbsp;проекцию&nbsp;вектора&nbsp;x&nbsp;на&nbsp;аффинное&nbsp;множество,&nbsp;заданное&nbsp;C&nbsp;@&nbsp;y&nbsp;=&nbsp;b.<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x:&nbsp;Вектор&nbsp;размера&nbsp;(n,)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C:&nbsp;Линейно-независимая&nbsp;матрица&nbsp;размера&nbsp;(m,&nbsp;n),&nbsp;задающая&nbsp;линейное&nbsp;отображение<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b:&nbsp;Вектор&nbsp;размера&nbsp;(m,),&nbsp;задающий&nbsp;сдвиг&nbsp;аффинного&nbsp;множества<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Вектор&nbsp;размера&nbsp;(n,)&nbsp;-&nbsp;проекция&nbsp;x&nbsp;на&nbsp;множество&nbsp;{y&nbsp;|&nbsp;C&nbsp;@&nbsp;y&nbsp;=&nbsp;b}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;numpy.asarray(x).flatten()<br>
&nbsp;&nbsp;&nbsp;&nbsp;C&nbsp;=&nbsp;numpy.asarray(C)<br>
&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;=&nbsp;numpy.asarray(b).flatten()<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;C.shape[0]&nbsp;!=&nbsp;b.shape[0]:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;raise&nbsp;ValueError(f&quot;Размерность&nbsp;b&nbsp;должна&nbsp;соответствовать&nbsp;числу&nbsp;строк&nbsp;C,&nbsp;получены&nbsp;{C.shape[0]}&nbsp;и&nbsp;{b.shape[0]}&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;C.shape[1]&nbsp;!=&nbsp;x.shape[0]:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;raise&nbsp;ValueError(f&quot;Размерность&nbsp;x&nbsp;должна&nbsp;соответствовать&nbsp;числу&nbsp;столбцов&nbsp;C,&nbsp;получены&nbsp;{C.shape[1]}&nbsp;и&nbsp;{x.shape[0]}&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Ct&nbsp;=&nbsp;C.T.conj()<br>
&nbsp;&nbsp;&nbsp;&nbsp;CCt_inv&nbsp;=&nbsp;numpy.linalg.pinv(C&nbsp;@&nbsp;Ct)<br>
&nbsp;&nbsp;&nbsp;&nbsp;projection&nbsp;=&nbsp;x&nbsp;-&nbsp;Ct&nbsp;@&nbsp;(CCt_inv&nbsp;@&nbsp;(C&nbsp;@&nbsp;x&nbsp;-&nbsp;b))<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;projection<br>
<br>
def&nbsp;affine_projector(C,&nbsp;b):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Возвращает&nbsp;проектор&nbsp;на&nbsp;аффинное&nbsp;множество&nbsp;A,&nbsp;заданное&nbsp;C&nbsp;@&nbsp;y&nbsp;=&nbsp;b&nbsp;и&nbsp;вектор&nbsp;смещения&nbsp;B:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Решение&nbsp;следует&nbsp;подставлять&nbsp;в&nbsp;форму&nbsp;x^&nbsp;=&nbsp;x&nbsp;-&nbsp;(A.x&nbsp;-&nbsp;B).<br>
&nbsp;&nbsp;&nbsp;&nbsp;Здесь<br>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;=&nbsp;C.T&nbsp;@&nbsp;(C&nbsp;@&nbsp;C.T)^(-1)&nbsp;@&nbsp;C<br>
&nbsp;&nbsp;&nbsp;&nbsp;B&nbsp;=&nbsp;C.T&nbsp;@&nbsp;(C&nbsp;@&nbsp;C.T)^(-1)&nbsp;@&nbsp;b<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;C&nbsp;=&nbsp;numpy.asarray(C)<br>
&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;=&nbsp;numpy.asarray(b).flatten()<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;C.shape[0]&nbsp;!=&nbsp;b.shape[0]:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;raise&nbsp;ValueError(f&quot;Размерность&nbsp;b&nbsp;должна&nbsp;соответствовать&nbsp;числу&nbsp;строк&nbsp;C,&nbsp;получены&nbsp;{C.shape[0]}&nbsp;и&nbsp;{b.shape[0]}&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Ct&nbsp;=&nbsp;C.T.conj()<br>
&nbsp;&nbsp;&nbsp;&nbsp;CCt_inv&nbsp;=&nbsp;numpy.linalg.pinv(C&nbsp;@&nbsp;Ct)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;K&nbsp;=&nbsp;Ct&nbsp;@&nbsp;CCt_inv<br>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;=&nbsp;K&nbsp;@&nbsp;C<br>
&nbsp;&nbsp;&nbsp;&nbsp;B&nbsp;=&nbsp;K&nbsp;@&nbsp;b<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;A,&nbsp;B<br>
<br>
def&nbsp;metric_project_onto_constraints(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q:&nbsp;numpy.ndarray,&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;H:&nbsp;numpy.ndarray,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M_inv:&nbsp;numpy.ndarray,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error:&nbsp;numpy.ndarray&nbsp;=&nbsp;None,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h:&nbsp;numpy.ndarray&nbsp;=&nbsp;None)&nbsp;-&gt;&nbsp;numpy.ndarray:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Проецировать&nbsp;скорости&nbsp;на&nbsp;ограничения<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;q&nbsp;-&nbsp;текущий&nbsp;вектор<br>
&nbsp;&nbsp;&nbsp;&nbsp;H&nbsp;-&nbsp;матрица&nbsp;ограничений<br>
&nbsp;&nbsp;&nbsp;&nbsp;M_inv&nbsp;-&nbsp;метрическая&nbsp;матрица<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Одно&nbsp;из&nbsp;двух&nbsp;должно&nbsp;быть&nbsp;задано:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error&nbsp;-&nbsp;текущая&nbsp;ошибка<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h&nbsp;-&nbsp;правая&nbsp;часть&nbsp;ограничений<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;error&nbsp;is&nbsp;None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error&nbsp;=&nbsp;H&nbsp;@&nbsp;q&nbsp;-&nbsp;h<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;S&nbsp;=&nbsp;H&nbsp;@&nbsp;M_inv&nbsp;@&nbsp;H.T<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;lmbda&nbsp;=&nbsp;numpy.linalg.solve(S,&nbsp;error)<br>
&nbsp;&nbsp;&nbsp;&nbsp;corrected&nbsp;=&nbsp;q&nbsp;-&nbsp;M_inv&nbsp;@&nbsp;H.T&nbsp;@&nbsp;lmbda<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;corrected&nbsp;<br>
<!-- END SCAT CODE -->
</body>
</html>
