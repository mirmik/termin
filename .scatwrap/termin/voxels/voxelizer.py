<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>termin/voxels/voxelizer.py</title>
</head>
<body>
<!-- BEGIN SCAT CODE -->
&quot;&quot;&quot;<br>
Вокселизатор&nbsp;—&nbsp;преобразование&nbsp;мешей&nbsp;в&nbsp;воксели.<br>
&quot;&quot;&quot;<br>
<br>
from&nbsp;__future__&nbsp;import&nbsp;annotations<br>
<br>
from&nbsp;typing&nbsp;import&nbsp;TYPE_CHECKING,&nbsp;Optional,&nbsp;Callable<br>
import&nbsp;numpy&nbsp;as&nbsp;np<br>
<br>
from&nbsp;termin.voxels.grid&nbsp;import&nbsp;VoxelGrid<br>
from&nbsp;termin.voxels.intersection&nbsp;import&nbsp;triangle_aabb_intersect,&nbsp;triangle_aabb<br>
<br>
if&nbsp;TYPE_CHECKING:<br>
&nbsp;&nbsp;&nbsp;&nbsp;from&nbsp;termin.mesh.mesh&nbsp;import&nbsp;Mesh3<br>
&nbsp;&nbsp;&nbsp;&nbsp;from&nbsp;termin.visualization.core.entity&nbsp;import&nbsp;Entity<br>
&nbsp;&nbsp;&nbsp;&nbsp;from&nbsp;termin.visualization.core.scene&nbsp;import&nbsp;Scene<br>
<br>
<br>
#&nbsp;Типы&nbsp;вокселей<br>
VOXEL_EMPTY&nbsp;=&nbsp;0<br>
VOXEL_SOLID&nbsp;=&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Заполненный&nbsp;воксель&nbsp;(после&nbsp;вокселизации&nbsp;и&nbsp;fill)<br>
VOXEL_SURFACE&nbsp;=&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Поверхностный&nbsp;воксель&nbsp;(после&nbsp;mark_surface)<br>
<br>
<br>
def&nbsp;_compute_triangle_normal(v0:&nbsp;np.ndarray,&nbsp;v1:&nbsp;np.ndarray,&nbsp;v2:&nbsp;np.ndarray)&nbsp;-&gt;&nbsp;np.ndarray:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Вычислить&nbsp;нормаль&nbsp;треугольника.&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;edge1&nbsp;=&nbsp;v1&nbsp;-&nbsp;v0<br>
&nbsp;&nbsp;&nbsp;&nbsp;edge2&nbsp;=&nbsp;v2&nbsp;-&nbsp;v0<br>
&nbsp;&nbsp;&nbsp;&nbsp;normal&nbsp;=&nbsp;np.cross(edge1,&nbsp;edge2)<br>
&nbsp;&nbsp;&nbsp;&nbsp;length&nbsp;=&nbsp;np.linalg.norm(normal)<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;length&nbsp;&gt;&nbsp;1e-8:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;normal&nbsp;/=&nbsp;length<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;normal.astype(np.float32)<br>
<br>
<br>
class&nbsp;MeshVoxelizer:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Вокселизатор&nbsp;одного&nbsp;меша.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Использует&nbsp;алгоритм&nbsp;triangle-box&nbsp;intersection&nbsp;для&nbsp;определения<br>
&nbsp;&nbsp;&nbsp;&nbsp;какие&nbsp;воксели&nbsp;пересекает&nbsp;поверхность&nbsp;меша.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;__init__(self,&nbsp;grid:&nbsp;VoxelGrid)&nbsp;-&gt;&nbsp;None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._grid&nbsp;=&nbsp;grid<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._cell_size&nbsp;=&nbsp;grid.cell_size<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._half_size&nbsp;=&nbsp;np.array([self._cell_size&nbsp;/&nbsp;2]&nbsp;*&nbsp;3,&nbsp;dtype=np.float32)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;voxelize_mesh(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mesh:&nbsp;&quot;Mesh3&quot;,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transform_matrix:&nbsp;Optional[np.ndarray]&nbsp;=&nbsp;None,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;voxel_type:&nbsp;int&nbsp;=&nbsp;VOXEL_SOLID,<br>
&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;-&gt;&nbsp;int:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Вокселизировать&nbsp;меш.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mesh:&nbsp;Меш&nbsp;для&nbsp;вокселизации.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transform_matrix:&nbsp;Матрица&nbsp;трансформации&nbsp;4x4&nbsp;(world&nbsp;space).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;voxel_type:&nbsp;Тип&nbsp;вокселя&nbsp;для&nbsp;записи.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Количество&nbsp;записанных&nbsp;вокселей.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertices&nbsp;=&nbsp;mesh.vertices<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;triangles&nbsp;=&nbsp;mesh.triangles<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;vertices&nbsp;is&nbsp;None&nbsp;or&nbsp;triangles&nbsp;is&nbsp;None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Применяем&nbsp;трансформацию&nbsp;если&nbsp;есть<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;transform_matrix&nbsp;is&nbsp;not&nbsp;None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertices&nbsp;=&nbsp;self._transform_vertices(vertices,&nbsp;transform_matrix)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count&nbsp;=&nbsp;0<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;tri&nbsp;in&nbsp;triangles:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v0&nbsp;=&nbsp;vertices[tri[0]]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v1&nbsp;=&nbsp;vertices[tri[1]]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v2&nbsp;=&nbsp;vertices[tri[2]]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count&nbsp;+=&nbsp;self._voxelize_triangle(v0,&nbsp;v1,&nbsp;v2,&nbsp;voxel_type)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;count<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;_transform_vertices(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertices:&nbsp;np.ndarray,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matrix:&nbsp;np.ndarray,<br>
&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;-&gt;&nbsp;np.ndarray:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Применить&nbsp;матрицу&nbsp;трансформации&nbsp;к&nbsp;вершинам.&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Добавляем&nbsp;w=1&nbsp;для&nbsp;homogeneous&nbsp;coordinates<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;=&nbsp;len(vertices)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;homogeneous&nbsp;=&nbsp;np.ones((n,&nbsp;4),&nbsp;dtype=np.float32)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;homogeneous[:,&nbsp;:3]&nbsp;=&nbsp;vertices<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Умножаем&nbsp;на&nbsp;транспонированную&nbsp;матрицу&nbsp;(vertices&nbsp;как&nbsp;строки)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transformed&nbsp;=&nbsp;homogeneous&nbsp;@&nbsp;matrix.T<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Возвращаем&nbsp;xyz<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;transformed[:,&nbsp;:3]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;_voxelize_triangle(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v0:&nbsp;np.ndarray,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v1:&nbsp;np.ndarray,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v2:&nbsp;np.ndarray,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;voxel_type:&nbsp;int,<br>
&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;-&gt;&nbsp;int:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Вокселизировать&nbsp;один&nbsp;треугольник.&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;AABB&nbsp;треугольника&nbsp;в&nbsp;мировых&nbsp;координатах<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tri_min,&nbsp;tri_max&nbsp;=&nbsp;triangle_aabb(v0,&nbsp;v1,&nbsp;v2)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Небольшое&nbsp;расширение&nbsp;для&nbsp;треугольников&nbsp;на&nbsp;границах&nbsp;вокселей<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;epsilon&nbsp;=&nbsp;self._cell_size&nbsp;*&nbsp;0.01<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tri_min&nbsp;=&nbsp;tri_min&nbsp;-&nbsp;epsilon<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tri_max&nbsp;=&nbsp;tri_max&nbsp;+&nbsp;epsilon<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Преобразуем&nbsp;в&nbsp;индексы&nbsp;вокселей<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;voxel_min&nbsp;=&nbsp;self._grid.world_to_voxel(tri_min)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;voxel_max&nbsp;=&nbsp;self._grid.world_to_voxel(tri_max)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count&nbsp;=&nbsp;0<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Перебираем&nbsp;все&nbsp;воксели&nbsp;в&nbsp;AABB<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;vx&nbsp;in&nbsp;range(voxel_min[0],&nbsp;voxel_max[0]&nbsp;+&nbsp;1):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;vy&nbsp;in&nbsp;range(voxel_min[1],&nbsp;voxel_max[1]&nbsp;+&nbsp;1):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;vz&nbsp;in&nbsp;range(voxel_min[2],&nbsp;voxel_max[2]&nbsp;+&nbsp;1):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Центр&nbsp;вокселя&nbsp;в&nbsp;мировых&nbsp;координатах<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;center&nbsp;=&nbsp;self._grid.voxel_to_world(vx,&nbsp;vy,&nbsp;vz)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Тест&nbsp;пересечения<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;triangle_aabb_intersect(v0,&nbsp;v1,&nbsp;v2,&nbsp;center,&nbsp;self._half_size):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._grid.set(vx,&nbsp;vy,&nbsp;vz,&nbsp;voxel_type)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count&nbsp;+=&nbsp;1<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;count<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;compute_surface_normals(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mesh:&nbsp;&quot;Mesh3&quot;,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;surface_voxels:&nbsp;set[tuple[int,&nbsp;int,&nbsp;int]],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transform_matrix:&nbsp;Optional[np.ndarray]&nbsp;=&nbsp;None,<br>
&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;-&gt;&nbsp;int:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Вычислить&nbsp;нормали&nbsp;для&nbsp;поверхностных&nbsp;вокселей.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Второй&nbsp;проход&nbsp;по&nbsp;треугольникам&nbsp;меша.&nbsp;Для&nbsp;каждого&nbsp;треугольника,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;пересекающего&nbsp;surface&nbsp;воксель,&nbsp;накапливаем&nbsp;его&nbsp;нормаль.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Результат&nbsp;—&nbsp;усреднённые&nbsp;нормализованные&nbsp;нормали&nbsp;в&nbsp;grid.surface_normals.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mesh:&nbsp;Меш&nbsp;для&nbsp;вычисления&nbsp;нормалей.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;surface_voxels:&nbsp;Множество&nbsp;координат&nbsp;поверхностных&nbsp;вокселей.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transform_matrix:&nbsp;Матрица&nbsp;трансформации&nbsp;4x4&nbsp;(world&nbsp;space).<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Количество&nbsp;вокселей&nbsp;с&nbsp;вычисленными&nbsp;нормалями.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertices&nbsp;=&nbsp;mesh.vertices<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;triangles&nbsp;=&nbsp;mesh.triangles<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;vertices&nbsp;is&nbsp;None&nbsp;or&nbsp;triangles&nbsp;is&nbsp;None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;surface_voxels:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Применяем&nbsp;трансформацию&nbsp;если&nbsp;есть<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;transform_matrix&nbsp;is&nbsp;not&nbsp;None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertices&nbsp;=&nbsp;self._transform_vertices(vertices,&nbsp;transform_matrix)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Накапливаем&nbsp;нормали&nbsp;для&nbsp;каждого&nbsp;surface&nbsp;вокселя<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;voxels_with_normals:&nbsp;set[tuple[int,&nbsp;int,&nbsp;int]]&nbsp;=&nbsp;set()<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;tri&nbsp;in&nbsp;triangles:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v0&nbsp;=&nbsp;vertices[tri[0]]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v1&nbsp;=&nbsp;vertices[tri[1]]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v2&nbsp;=&nbsp;vertices[tri[2]]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Нормаль&nbsp;треугольника<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tri_normal&nbsp;=&nbsp;_compute_triangle_normal(v0,&nbsp;v1,&nbsp;v2)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;AABB&nbsp;треугольника<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tri_min,&nbsp;tri_max&nbsp;=&nbsp;triangle_aabb(v0,&nbsp;v1,&nbsp;v2)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;epsilon&nbsp;=&nbsp;self._cell_size&nbsp;*&nbsp;0.01<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tri_min&nbsp;=&nbsp;tri_min&nbsp;-&nbsp;epsilon<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tri_max&nbsp;=&nbsp;tri_max&nbsp;+&nbsp;epsilon<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;voxel_min&nbsp;=&nbsp;self._grid.world_to_voxel(tri_min)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;voxel_max&nbsp;=&nbsp;self._grid.world_to_voxel(tri_max)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Проверяем&nbsp;воксели&nbsp;в&nbsp;AABB&nbsp;треугольника<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;vx&nbsp;in&nbsp;range(voxel_min[0],&nbsp;voxel_max[0]&nbsp;+&nbsp;1):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;vy&nbsp;in&nbsp;range(voxel_min[1],&nbsp;voxel_max[1]&nbsp;+&nbsp;1):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;vz&nbsp;in&nbsp;range(voxel_min[2],&nbsp;voxel_max[2]&nbsp;+&nbsp;1):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;voxel_key&nbsp;=&nbsp;(vx,&nbsp;vy,&nbsp;vz)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Только&nbsp;surface&nbsp;воксели<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;voxel_key&nbsp;not&nbsp;in&nbsp;surface_voxels:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Проверяем&nbsp;пересечение<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;center&nbsp;=&nbsp;self._grid.voxel_to_world(vx,&nbsp;vy,&nbsp;vz)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;triangle_aabb_intersect(v0,&nbsp;v1,&nbsp;v2,&nbsp;center,&nbsp;self._half_size):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Добавляем&nbsp;нормаль&nbsp;треугольника&nbsp;к&nbsp;списку&nbsp;(без&nbsp;усреднения)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._grid.add_surface_normal(vx,&nbsp;vy,&nbsp;vz,&nbsp;tri_normal)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;voxels_with_normals.add(voxel_key)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;len(voxels_with_normals)<br>
<br>
<br>
class&nbsp;SceneVoxelizer:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Вокселизатор&nbsp;сцены.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Обходит&nbsp;все&nbsp;entity&nbsp;с&nbsp;MeshRenderer&nbsp;и&nbsp;вокселизирует&nbsp;их.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;__init__(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid:&nbsp;VoxelGrid,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;progress_callback:&nbsp;Optional[Callable[[int,&nbsp;int],&nbsp;None]]&nbsp;=&nbsp;None,<br>
&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;-&gt;&nbsp;None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid:&nbsp;Воксельная&nbsp;сетка&nbsp;для&nbsp;записи.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;progress_callback:&nbsp;Колбэк&nbsp;прогресса&nbsp;(current,&nbsp;total).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._grid&nbsp;=&nbsp;grid<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._mesh_voxelizer&nbsp;=&nbsp;MeshVoxelizer(grid)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._progress_callback&nbsp;=&nbsp;progress_callback<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;voxelize_scene(self,&nbsp;scene:&nbsp;&quot;Scene&quot;)&nbsp;-&gt;&nbsp;int:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Вокселизировать&nbsp;всю&nbsp;сцену.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scene:&nbsp;Сцена&nbsp;для&nbsp;вокселизации.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Общее&nbsp;количество&nbsp;записанных&nbsp;вокселей.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from&nbsp;termin.visualization.render.components&nbsp;import&nbsp;MeshRenderer<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Собираем&nbsp;все&nbsp;entity&nbsp;с&nbsp;MeshRenderer<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mesh_entities&nbsp;=&nbsp;[]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;entity&nbsp;in&nbsp;scene.entities:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;entity.visible&nbsp;or&nbsp;not&nbsp;entity.enabled:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;comp&nbsp;=&nbsp;entity.get_component(MeshRenderer)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;comp&nbsp;is&nbsp;not&nbsp;None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mesh_entities.append((entity,&nbsp;comp))<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;total&nbsp;=&nbsp;len(mesh_entities)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;total_voxels&nbsp;=&nbsp;0<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i,&nbsp;(entity,&nbsp;renderer)&nbsp;in&nbsp;enumerate(mesh_entities):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;self._progress_callback&nbsp;is&nbsp;not&nbsp;None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._progress_callback(i,&nbsp;total)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mesh_drawable&nbsp;=&nbsp;renderer.mesh<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;mesh_drawable&nbsp;is&nbsp;None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mesh&nbsp;=&nbsp;mesh_drawable.mesh<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;mesh&nbsp;is&nbsp;None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Получаем&nbsp;world&nbsp;transform&nbsp;матрицу&nbsp;(включая&nbsp;scale)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transform_matrix&nbsp;=&nbsp;entity.model_matrix()<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;voxels&nbsp;=&nbsp;self._mesh_voxelizer.voxelize_mesh(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mesh,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transform_matrix=transform_matrix,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;total_voxels&nbsp;+=&nbsp;voxels<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;self._progress_callback&nbsp;is&nbsp;not&nbsp;None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._progress_callback(total,&nbsp;total)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;total_voxels<br>
<br>
<br>
def&nbsp;voxelize_scene(<br>
&nbsp;&nbsp;&nbsp;&nbsp;scene:&nbsp;&quot;Scene&quot;,<br>
&nbsp;&nbsp;&nbsp;&nbsp;cell_size:&nbsp;float&nbsp;=&nbsp;0.25,<br>
&nbsp;&nbsp;&nbsp;&nbsp;padding:&nbsp;float&nbsp;=&nbsp;1.0,<br>
&nbsp;&nbsp;&nbsp;&nbsp;progress_callback:&nbsp;Optional[Callable[[int,&nbsp;int],&nbsp;None]]&nbsp;=&nbsp;None,<br>
)&nbsp;-&gt;&nbsp;VoxelGrid:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Удобная&nbsp;функция&nbsp;для&nbsp;вокселизации&nbsp;сцены.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Автоматически&nbsp;вычисляет&nbsp;bounds&nbsp;и&nbsp;создаёт&nbsp;сетку.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scene:&nbsp;Сцена&nbsp;для&nbsp;вокселизации.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cell_size:&nbsp;Размер&nbsp;вокселя.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;padding:&nbsp;Отступ&nbsp;вокруг&nbsp;сцены.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;progress_callback:&nbsp;Колбэк&nbsp;прогресса.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Заполненная&nbsp;воксельная&nbsp;сетка.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Вычисляем&nbsp;bounds&nbsp;сцены<br>
&nbsp;&nbsp;&nbsp;&nbsp;scene_min,&nbsp;scene_max&nbsp;=&nbsp;_compute_scene_bounds(scene)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;scene_min&nbsp;is&nbsp;None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Пустая&nbsp;сцена<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;VoxelGrid(origin=(0,&nbsp;0,&nbsp;0),&nbsp;cell_size=cell_size)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Добавляем&nbsp;padding<br>
&nbsp;&nbsp;&nbsp;&nbsp;origin&nbsp;=&nbsp;scene_min&nbsp;-&nbsp;padding<br>
&nbsp;&nbsp;&nbsp;&nbsp;size&nbsp;=&nbsp;scene_max&nbsp;-&nbsp;scene_min&nbsp;+&nbsp;2&nbsp;*&nbsp;padding<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Выравниваем&nbsp;origin&nbsp;на&nbsp;cell_size<br>
&nbsp;&nbsp;&nbsp;&nbsp;origin&nbsp;=&nbsp;np.floor(origin&nbsp;/&nbsp;cell_size)&nbsp;*&nbsp;cell_size<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;grid&nbsp;=&nbsp;VoxelGrid(origin=tuple(origin),&nbsp;cell_size=cell_size)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;voxelizer&nbsp;=&nbsp;SceneVoxelizer(grid,&nbsp;progress_callback)<br>
&nbsp;&nbsp;&nbsp;&nbsp;voxelizer.voxelize_scene(scene)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;grid<br>
<br>
<br>
def&nbsp;_compute_scene_bounds(scene:&nbsp;&quot;Scene&quot;):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Вычислить&nbsp;bounds&nbsp;сцены&nbsp;по&nbsp;всем&nbsp;мешам.&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;from&nbsp;termin.visualization.render.components&nbsp;import&nbsp;MeshRenderer<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;scene_min&nbsp;=&nbsp;None<br>
&nbsp;&nbsp;&nbsp;&nbsp;scene_max&nbsp;=&nbsp;None<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;entity&nbsp;in&nbsp;scene.entities:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;entity.visible&nbsp;or&nbsp;not&nbsp;entity.enabled:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;comp&nbsp;in&nbsp;entity.components:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;isinstance(comp,&nbsp;MeshRenderer):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mesh_drawable&nbsp;=&nbsp;comp.mesh<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;mesh_drawable&nbsp;is&nbsp;None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mesh&nbsp;=&nbsp;mesh_drawable.mesh<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;mesh&nbsp;is&nbsp;None&nbsp;or&nbsp;mesh.vertices&nbsp;is&nbsp;None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Трансформируем&nbsp;вершины&nbsp;в&nbsp;world&nbsp;space<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matrix&nbsp;=&nbsp;entity.model_matrix()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertices&nbsp;=&nbsp;mesh.vertices<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;=&nbsp;len(vertices)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;homogeneous&nbsp;=&nbsp;np.ones((n,&nbsp;4),&nbsp;dtype=np.float32)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;homogeneous[:,&nbsp;:3]&nbsp;=&nbsp;vertices<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transformed&nbsp;=&nbsp;homogeneous&nbsp;@&nbsp;matrix.T<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;world_vertices&nbsp;=&nbsp;transformed[:,&nbsp;:3]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mesh_min&nbsp;=&nbsp;world_vertices.min(axis=0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mesh_max&nbsp;=&nbsp;world_vertices.max(axis=0)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;scene_min&nbsp;is&nbsp;None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scene_min&nbsp;=&nbsp;mesh_min<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scene_max&nbsp;=&nbsp;mesh_max<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scene_min&nbsp;=&nbsp;np.minimum(scene_min,&nbsp;mesh_min)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scene_max&nbsp;=&nbsp;np.maximum(scene_max,&nbsp;mesh_max)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;scene_min,&nbsp;scene_max<br>
<!-- END SCAT CODE -->
</body>
</html>
