<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>termin/voxels/native_voxelizer.py</title>
</head>
<body>
<!-- BEGIN SCAT CODE -->
&quot;&quot;&quot;<br>
Native&nbsp;C++&nbsp;voxelization&nbsp;wrapper.<br>
<br>
Provides&nbsp;accelerated&nbsp;voxelization&nbsp;using&nbsp;the&nbsp;C++&nbsp;implementation&nbsp;when&nbsp;available.<br>
Falls&nbsp;back&nbsp;to&nbsp;Python&nbsp;implementation&nbsp;if&nbsp;native&nbsp;module&nbsp;not&nbsp;built.<br>
&quot;&quot;&quot;<br>
<br>
from&nbsp;__future__&nbsp;import&nbsp;annotations<br>
<br>
from&nbsp;typing&nbsp;import&nbsp;TYPE_CHECKING,&nbsp;Optional<br>
import&nbsp;numpy&nbsp;as&nbsp;np<br>
<br>
#&nbsp;Try&nbsp;to&nbsp;import&nbsp;native&nbsp;module<br>
try:<br>
&nbsp;&nbsp;&nbsp;&nbsp;from&nbsp;termin.voxels&nbsp;import&nbsp;_voxels_native<br>
&nbsp;&nbsp;&nbsp;&nbsp;HAS_NATIVE&nbsp;=&nbsp;True<br>
except&nbsp;ImportError:<br>
&nbsp;&nbsp;&nbsp;&nbsp;_voxels_native&nbsp;=&nbsp;None<br>
&nbsp;&nbsp;&nbsp;&nbsp;HAS_NATIVE&nbsp;=&nbsp;False<br>
<br>
if&nbsp;TYPE_CHECKING:<br>
&nbsp;&nbsp;&nbsp;&nbsp;from&nbsp;termin.mesh.mesh&nbsp;import&nbsp;Mesh3<br>
&nbsp;&nbsp;&nbsp;&nbsp;from&nbsp;termin.voxels.grid&nbsp;import&nbsp;VoxelGrid<br>
<br>
<br>
def&nbsp;is_native_available()&nbsp;-&gt;&nbsp;bool:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Check&nbsp;if&nbsp;native&nbsp;C++&nbsp;voxelization&nbsp;is&nbsp;available.&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;HAS_NATIVE<br>
<br>
<br>
def&nbsp;voxelize_mesh_native(<br>
&nbsp;&nbsp;&nbsp;&nbsp;mesh:&nbsp;&quot;Mesh3&quot;,<br>
&nbsp;&nbsp;&nbsp;&nbsp;cell_size:&nbsp;float&nbsp;=&nbsp;0.25,<br>
&nbsp;&nbsp;&nbsp;&nbsp;fill_interior:&nbsp;bool&nbsp;=&nbsp;False,<br>
&nbsp;&nbsp;&nbsp;&nbsp;mark_surface:&nbsp;bool&nbsp;=&nbsp;False,<br>
&nbsp;&nbsp;&nbsp;&nbsp;clear_interior:&nbsp;bool&nbsp;=&nbsp;False,<br>
&nbsp;&nbsp;&nbsp;&nbsp;compute_normals:&nbsp;bool&nbsp;=&nbsp;False,<br>
)&nbsp;-&gt;&nbsp;&quot;VoxelGrid&quot;:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Voxelize&nbsp;a&nbsp;mesh&nbsp;using&nbsp;native&nbsp;C++&nbsp;implementation.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mesh:&nbsp;Input&nbsp;mesh&nbsp;to&nbsp;voxelize.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cell_size:&nbsp;Size&nbsp;of&nbsp;each&nbsp;voxel.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fill_interior:&nbsp;Fill&nbsp;interior&nbsp;voxels&nbsp;after&nbsp;surface&nbsp;voxelization.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mark_surface:&nbsp;Mark&nbsp;surface&nbsp;voxels&nbsp;with&nbsp;VOXEL_SURFACE&nbsp;type.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clear_interior:&nbsp;Remove&nbsp;interior&nbsp;(SOLID)&nbsp;voxels,&nbsp;keeping&nbsp;only&nbsp;surface.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;compute_normals:&nbsp;Compute&nbsp;surface&nbsp;normals&nbsp;for&nbsp;surface&nbsp;voxels.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VoxelGrid&nbsp;with&nbsp;voxelization&nbsp;results.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Raises:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RuntimeError:&nbsp;If&nbsp;native&nbsp;module&nbsp;not&nbsp;available.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;HAS_NATIVE:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;raise&nbsp;RuntimeError(&quot;Native&nbsp;voxelization&nbsp;module&nbsp;not&nbsp;available.&nbsp;Build&nbsp;with:&nbsp;cd&nbsp;cpp&nbsp;&amp;&amp;&nbsp;mkdir&nbsp;build&nbsp;&amp;&amp;&nbsp;cd&nbsp;build&nbsp;&amp;&amp;&nbsp;cmake&nbsp;..&nbsp;&amp;&amp;&nbsp;make&quot;)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;from&nbsp;termin.voxels.grid&nbsp;import&nbsp;VoxelGrid<br>
&nbsp;&nbsp;&nbsp;&nbsp;from&nbsp;termin.voxels.voxelizer&nbsp;import&nbsp;VOXEL_SOLID,&nbsp;VOXEL_SURFACE<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;vertices&nbsp;=&nbsp;mesh.vertices<br>
&nbsp;&nbsp;&nbsp;&nbsp;triangles&nbsp;=&nbsp;mesh.triangles<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;vertices&nbsp;is&nbsp;None&nbsp;or&nbsp;triangles&nbsp;is&nbsp;None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;VoxelGrid(origin=(0,&nbsp;0,&nbsp;0),&nbsp;cell_size=cell_size)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Ensure&nbsp;correct&nbsp;dtypes<br>
&nbsp;&nbsp;&nbsp;&nbsp;vertices&nbsp;=&nbsp;np.asarray(vertices,&nbsp;dtype=np.float64)<br>
&nbsp;&nbsp;&nbsp;&nbsp;triangles&nbsp;=&nbsp;np.asarray(triangles,&nbsp;dtype=np.int32)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Create&nbsp;native&nbsp;grid<br>
&nbsp;&nbsp;&nbsp;&nbsp;from&nbsp;termin.geombase._geom_native&nbsp;import&nbsp;Vec3<br>
&nbsp;&nbsp;&nbsp;&nbsp;native_grid&nbsp;=&nbsp;_voxels_native.VoxelGrid(cell_size,&nbsp;Vec3(0,&nbsp;0,&nbsp;0))<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Voxelize<br>
&nbsp;&nbsp;&nbsp;&nbsp;voxel_count&nbsp;=&nbsp;native_grid.voxelize_mesh(vertices,&nbsp;triangles,&nbsp;VOXEL_SOLID)<br>
&nbsp;&nbsp;&nbsp;&nbsp;print(f&quot;Native&nbsp;voxelization:&nbsp;{voxel_count}&nbsp;surface&nbsp;voxels&quot;)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Fill&nbsp;interior<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;fill_interior:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filled&nbsp;=&nbsp;native_grid.fill_interior(VOXEL_SOLID)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(f&quot;Native&nbsp;fill_interior:&nbsp;{filled}&nbsp;voxels&quot;)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Mark&nbsp;surface<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;mark_surface:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;marked&nbsp;=&nbsp;native_grid.mark_surface(VOXEL_SURFACE)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(f&quot;Native&nbsp;mark_surface:&nbsp;{marked}&nbsp;voxels&quot;)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Clear&nbsp;interior<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;clear_interior:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cleared&nbsp;=&nbsp;native_grid.clear_by_type(VOXEL_SOLID)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(f&quot;Native&nbsp;clear_by_type:&nbsp;{cleared}&nbsp;voxels&quot;)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Compute&nbsp;normals<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;compute_normals:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;normals_count&nbsp;=&nbsp;native_grid.compute_surface_normals(vertices,&nbsp;triangles)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(f&quot;Native&nbsp;compute_surface_normals:&nbsp;{normals_count}&nbsp;normals&quot;)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Convert&nbsp;to&nbsp;Python&nbsp;VoxelGrid<br>
&nbsp;&nbsp;&nbsp;&nbsp;py_grid&nbsp;=&nbsp;VoxelGrid(origin=(0,&nbsp;0,&nbsp;0),&nbsp;cell_size=cell_size)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;vx,&nbsp;vy,&nbsp;vz,&nbsp;vtype&nbsp;in&nbsp;native_grid.iter_non_empty():<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;py_grid.set(vx,&nbsp;vy,&nbsp;vz,&nbsp;vtype)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Copy&nbsp;surface&nbsp;normals&nbsp;(list&nbsp;of&nbsp;normals&nbsp;per&nbsp;voxel)<br>
&nbsp;&nbsp;&nbsp;&nbsp;native_normals&nbsp;=&nbsp;native_grid.surface_normals<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;key,&nbsp;normals_list&nbsp;in&nbsp;native_normals.items():<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx,&nbsp;vy,&nbsp;vz&nbsp;=&nbsp;key<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;py_grid.set_surface_normals(vx,&nbsp;vy,&nbsp;vz,&nbsp;list(normals_list))<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;py_grid<br>
<br>
<br>
def&nbsp;benchmark_voxelization(mesh:&nbsp;&quot;Mesh3&quot;,&nbsp;cell_size:&nbsp;float&nbsp;=&nbsp;0.25,&nbsp;iterations:&nbsp;int&nbsp;=&nbsp;3):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Benchmark&nbsp;native&nbsp;vs&nbsp;Python&nbsp;voxelization.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mesh:&nbsp;Mesh&nbsp;to&nbsp;voxelize.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cell_size:&nbsp;Voxel&nbsp;size.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iterations:&nbsp;Number&nbsp;of&nbsp;iterations&nbsp;for&nbsp;timing.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;import&nbsp;time<br>
&nbsp;&nbsp;&nbsp;&nbsp;from&nbsp;termin.voxels.grid&nbsp;import&nbsp;VoxelGrid<br>
&nbsp;&nbsp;&nbsp;&nbsp;from&nbsp;termin.voxels.voxelizer&nbsp;import&nbsp;MeshVoxelizer<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;vertices&nbsp;=&nbsp;mesh.vertices<br>
&nbsp;&nbsp;&nbsp;&nbsp;triangles&nbsp;=&nbsp;mesh.triangles<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;vertices&nbsp;is&nbsp;None&nbsp;or&nbsp;triangles&nbsp;is&nbsp;None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&quot;Mesh&nbsp;has&nbsp;no&nbsp;geometry&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;print(f&quot;Mesh:&nbsp;{len(vertices)}&nbsp;vertices,&nbsp;{len(triangles)}&nbsp;triangles&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;print(f&quot;Cell&nbsp;size:&nbsp;{cell_size}&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;print(f&quot;Iterations:&nbsp;{iterations}&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;print()<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Python&nbsp;benchmark<br>
&nbsp;&nbsp;&nbsp;&nbsp;print(&quot;Python&nbsp;voxelization:&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;py_times&nbsp;=&nbsp;[]<br>
&nbsp;&nbsp;&nbsp;&nbsp;py_voxel_count&nbsp;=&nbsp;0<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i&nbsp;in&nbsp;range(iterations):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid&nbsp;=&nbsp;VoxelGrid(origin=(0,&nbsp;0,&nbsp;0),&nbsp;cell_size=cell_size)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;voxelizer&nbsp;=&nbsp;MeshVoxelizer(grid)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;start&nbsp;=&nbsp;time.perf_counter()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;voxelizer.voxelize_mesh(mesh,&nbsp;transform_matrix=None)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elapsed&nbsp;=&nbsp;time.perf_counter()&nbsp;-&nbsp;start<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;py_times.append(elapsed)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;py_voxel_count&nbsp;=&nbsp;grid.voxel_count<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(f&quot;&nbsp;&nbsp;Run&nbsp;{i+1}:&nbsp;{elapsed:.4f}s&nbsp;({py_voxel_count}&nbsp;voxels)&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;py_avg&nbsp;=&nbsp;sum(py_times)&nbsp;/&nbsp;len(py_times)<br>
&nbsp;&nbsp;&nbsp;&nbsp;print(f&quot;&nbsp;&nbsp;Average:&nbsp;{py_avg:.4f}s&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;print()<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Native&nbsp;benchmark<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;HAS_NATIVE:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&quot;Native&nbsp;voxelization:&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;native_times&nbsp;=&nbsp;[]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;native_voxel_count&nbsp;=&nbsp;0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertices_f64&nbsp;=&nbsp;np.asarray(vertices,&nbsp;dtype=np.float64)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;triangles_i32&nbsp;=&nbsp;np.asarray(triangles,&nbsp;dtype=np.int32)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from&nbsp;termin.geombase._geom_native&nbsp;import&nbsp;Vec3<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i&nbsp;in&nbsp;range(iterations):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;native_grid&nbsp;=&nbsp;_voxels_native.VoxelGrid(cell_size,&nbsp;Vec3(0,&nbsp;0,&nbsp;0))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;start&nbsp;=&nbsp;time.perf_counter()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;native_grid.voxelize_mesh(vertices_f64,&nbsp;triangles_i32)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elapsed&nbsp;=&nbsp;time.perf_counter()&nbsp;-&nbsp;start<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;native_times.append(elapsed)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;native_voxel_count&nbsp;=&nbsp;native_grid.voxel_count()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(f&quot;&nbsp;&nbsp;Run&nbsp;{i+1}:&nbsp;{elapsed:.4f}s&nbsp;({native_voxel_count}&nbsp;voxels)&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;native_avg&nbsp;=&nbsp;sum(native_times)&nbsp;/&nbsp;len(native_times)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(f&quot;&nbsp;&nbsp;Average:&nbsp;{native_avg:.4f}s&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print()<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;speedup&nbsp;=&nbsp;py_avg&nbsp;/&nbsp;native_avg&nbsp;if&nbsp;native_avg&nbsp;&gt;&nbsp;0&nbsp;else&nbsp;float('inf')<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(f&quot;Speedup:&nbsp;{speedup:.1f}x&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;else:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&quot;Native&nbsp;module&nbsp;not&nbsp;available&quot;)<br>
<!-- END SCAT CODE -->
</body>
</html>
