<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>termin/voxels/intersection.py</title>
</head>
<body>
<!-- BEGIN SCAT CODE -->
&quot;&quot;&quot;<br>
Тесты&nbsp;пересечения&nbsp;для&nbsp;вокселизации.<br>
&quot;&quot;&quot;<br>
<br>
from&nbsp;__future__&nbsp;import&nbsp;annotations<br>
<br>
import&nbsp;numpy&nbsp;as&nbsp;np<br>
from&nbsp;typing&nbsp;import&nbsp;Tuple<br>
<br>
#&nbsp;Epsilon&nbsp;для&nbsp;численной&nbsp;устойчивости&nbsp;при&nbsp;сравнении&nbsp;с&nbsp;границами<br>
_EPSILON&nbsp;=&nbsp;1e-6<br>
<br>
<br>
def&nbsp;triangle_aabb_intersect(<br>
&nbsp;&nbsp;&nbsp;&nbsp;v0:&nbsp;np.ndarray,<br>
&nbsp;&nbsp;&nbsp;&nbsp;v1:&nbsp;np.ndarray,<br>
&nbsp;&nbsp;&nbsp;&nbsp;v2:&nbsp;np.ndarray,<br>
&nbsp;&nbsp;&nbsp;&nbsp;box_center:&nbsp;np.ndarray,<br>
&nbsp;&nbsp;&nbsp;&nbsp;box_half_size:&nbsp;np.ndarray,<br>
)&nbsp;-&gt;&nbsp;bool:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Тест&nbsp;пересечения&nbsp;треугольника&nbsp;и&nbsp;AABB&nbsp;(axis-aligned&nbsp;bounding&nbsp;box).<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Алгоритм&nbsp;Tomas&nbsp;Akenine-Möller&nbsp;(SAT&nbsp;—&nbsp;Separating&nbsp;Axis&nbsp;Theorem).<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v0,&nbsp;v1,&nbsp;v2:&nbsp;Вершины&nbsp;треугольника.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;box_center:&nbsp;Центр&nbsp;AABB.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;box_half_size:&nbsp;Половина&nbsp;размера&nbsp;AABB&nbsp;по&nbsp;каждой&nbsp;оси.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;True&nbsp;если&nbsp;пересекаются.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Переносим&nbsp;треугольник&nbsp;так,&nbsp;чтобы&nbsp;центр&nbsp;AABB&nbsp;был&nbsp;в&nbsp;origin<br>
&nbsp;&nbsp;&nbsp;&nbsp;v0&nbsp;=&nbsp;v0&nbsp;-&nbsp;box_center<br>
&nbsp;&nbsp;&nbsp;&nbsp;v1&nbsp;=&nbsp;v1&nbsp;-&nbsp;box_center<br>
&nbsp;&nbsp;&nbsp;&nbsp;v2&nbsp;=&nbsp;v2&nbsp;-&nbsp;box_center<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Рёбра&nbsp;треугольника<br>
&nbsp;&nbsp;&nbsp;&nbsp;e0&nbsp;=&nbsp;v1&nbsp;-&nbsp;v0<br>
&nbsp;&nbsp;&nbsp;&nbsp;e1&nbsp;=&nbsp;v2&nbsp;-&nbsp;v1<br>
&nbsp;&nbsp;&nbsp;&nbsp;e2&nbsp;=&nbsp;v0&nbsp;-&nbsp;v2<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;hx,&nbsp;hy,&nbsp;hz&nbsp;=&nbsp;box_half_size<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;---&nbsp;Тест&nbsp;1:&nbsp;оси&nbsp;AABB&nbsp;(X,&nbsp;Y,&nbsp;Z)&nbsp;---<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Проверяем,&nbsp;что&nbsp;проекции&nbsp;треугольника&nbsp;и&nbsp;AABB&nbsp;пересекаются&nbsp;по&nbsp;каждой&nbsp;оси<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Добавляем&nbsp;epsilon&nbsp;для&nbsp;численной&nbsp;устойчивости&nbsp;на&nbsp;границах<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Ось&nbsp;X<br>
&nbsp;&nbsp;&nbsp;&nbsp;min_x&nbsp;=&nbsp;min(v0[0],&nbsp;v1[0],&nbsp;v2[0])<br>
&nbsp;&nbsp;&nbsp;&nbsp;max_x&nbsp;=&nbsp;max(v0[0],&nbsp;v1[0],&nbsp;v2[0])<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;min_x&nbsp;&gt;&nbsp;hx&nbsp;+&nbsp;_EPSILON&nbsp;or&nbsp;max_x&nbsp;&lt;&nbsp;-hx&nbsp;-&nbsp;_EPSILON:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;False<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Ось&nbsp;Y<br>
&nbsp;&nbsp;&nbsp;&nbsp;min_y&nbsp;=&nbsp;min(v0[1],&nbsp;v1[1],&nbsp;v2[1])<br>
&nbsp;&nbsp;&nbsp;&nbsp;max_y&nbsp;=&nbsp;max(v0[1],&nbsp;v1[1],&nbsp;v2[1])<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;min_y&nbsp;&gt;&nbsp;hy&nbsp;+&nbsp;_EPSILON&nbsp;or&nbsp;max_y&nbsp;&lt;&nbsp;-hy&nbsp;-&nbsp;_EPSILON:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;False<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Ось&nbsp;Z<br>
&nbsp;&nbsp;&nbsp;&nbsp;min_z&nbsp;=&nbsp;min(v0[2],&nbsp;v1[2],&nbsp;v2[2])<br>
&nbsp;&nbsp;&nbsp;&nbsp;max_z&nbsp;=&nbsp;max(v0[2],&nbsp;v1[2],&nbsp;v2[2])<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;min_z&nbsp;&gt;&nbsp;hz&nbsp;+&nbsp;_EPSILON&nbsp;or&nbsp;max_z&nbsp;&lt;&nbsp;-hz&nbsp;-&nbsp;_EPSILON:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;False<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;---&nbsp;Тест&nbsp;2:&nbsp;нормаль&nbsp;треугольника&nbsp;---<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;normal&nbsp;=&nbsp;np.cross(e0,&nbsp;e1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;d&nbsp;=&nbsp;-np.dot(normal,&nbsp;v0)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Проекция&nbsp;AABB&nbsp;на&nbsp;нормаль<br>
&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;=&nbsp;(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hx&nbsp;*&nbsp;abs(normal[0])&nbsp;+<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hy&nbsp;*&nbsp;abs(normal[1])&nbsp;+<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hz&nbsp;*&nbsp;abs(normal[2])<br>
&nbsp;&nbsp;&nbsp;&nbsp;)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;d&nbsp;&gt;&nbsp;r&nbsp;+&nbsp;_EPSILON&nbsp;or&nbsp;d&nbsp;&lt;&nbsp;-r&nbsp;-&nbsp;_EPSILON:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;False<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;---&nbsp;Тест&nbsp;3:&nbsp;кросс-произведения&nbsp;рёбер&nbsp;---<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;9&nbsp;осей:&nbsp;cross(edge_i,&nbsp;axis_j)&nbsp;для&nbsp;i=0,1,2&nbsp;и&nbsp;j=X,Y,Z<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;e0&nbsp;×&nbsp;X&nbsp;=&nbsp;(0,&nbsp;-e0.z,&nbsp;e0.y)<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;_axis_test_x(e0,&nbsp;v0,&nbsp;v2,&nbsp;hy,&nbsp;hz):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;False<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;e0&nbsp;×&nbsp;Y&nbsp;=&nbsp;(e0.z,&nbsp;0,&nbsp;-e0.x)<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;_axis_test_y(e0,&nbsp;v0,&nbsp;v2,&nbsp;hx,&nbsp;hz):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;False<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;e0&nbsp;×&nbsp;Z&nbsp;=&nbsp;(-e0.y,&nbsp;e0.x,&nbsp;0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;_axis_test_z(e0,&nbsp;v0,&nbsp;v2,&nbsp;hx,&nbsp;hy):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;False<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;e1&nbsp;×&nbsp;X,&nbsp;Y,&nbsp;Z<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;_axis_test_x(e1,&nbsp;v1,&nbsp;v0,&nbsp;hy,&nbsp;hz):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;False<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;_axis_test_y(e1,&nbsp;v1,&nbsp;v0,&nbsp;hx,&nbsp;hz):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;False<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;_axis_test_z(e1,&nbsp;v1,&nbsp;v0,&nbsp;hx,&nbsp;hy):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;False<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;e2&nbsp;×&nbsp;X,&nbsp;Y,&nbsp;Z<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;_axis_test_x(e2,&nbsp;v2,&nbsp;v1,&nbsp;hy,&nbsp;hz):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;False<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;_axis_test_y(e2,&nbsp;v2,&nbsp;v1,&nbsp;hx,&nbsp;hz):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;False<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;_axis_test_z(e2,&nbsp;v2,&nbsp;v1,&nbsp;hx,&nbsp;hy):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;False<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;True<br>
<br>
<br>
def&nbsp;_axis_test_x(edge:&nbsp;np.ndarray,&nbsp;va:&nbsp;np.ndarray,&nbsp;vb:&nbsp;np.ndarray,&nbsp;hy:&nbsp;float,&nbsp;hz:&nbsp;float)&nbsp;-&gt;&nbsp;bool:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Тест&nbsp;оси&nbsp;edge&nbsp;×&nbsp;X.&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;axis&nbsp;=&nbsp;(0,&nbsp;-edge.z,&nbsp;edge.y)<br>
&nbsp;&nbsp;&nbsp;&nbsp;p0&nbsp;=&nbsp;-edge[2]&nbsp;*&nbsp;va[1]&nbsp;+&nbsp;edge[1]&nbsp;*&nbsp;va[2]<br>
&nbsp;&nbsp;&nbsp;&nbsp;p1&nbsp;=&nbsp;-edge[2]&nbsp;*&nbsp;vb[1]&nbsp;+&nbsp;edge[1]&nbsp;*&nbsp;vb[2]<br>
&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;=&nbsp;hy&nbsp;*&nbsp;abs(edge[2])&nbsp;+&nbsp;hz&nbsp;*&nbsp;abs(edge[1])<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;not&nbsp;(min(p0,&nbsp;p1)&nbsp;&gt;&nbsp;r&nbsp;+&nbsp;_EPSILON&nbsp;or&nbsp;max(p0,&nbsp;p1)&nbsp;&lt;&nbsp;-r&nbsp;-&nbsp;_EPSILON)<br>
<br>
<br>
def&nbsp;_axis_test_y(edge:&nbsp;np.ndarray,&nbsp;va:&nbsp;np.ndarray,&nbsp;vb:&nbsp;np.ndarray,&nbsp;hx:&nbsp;float,&nbsp;hz:&nbsp;float)&nbsp;-&gt;&nbsp;bool:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Тест&nbsp;оси&nbsp;edge&nbsp;×&nbsp;Y.&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;axis&nbsp;=&nbsp;(edge.z,&nbsp;0,&nbsp;-edge.x)<br>
&nbsp;&nbsp;&nbsp;&nbsp;p0&nbsp;=&nbsp;edge[2]&nbsp;*&nbsp;va[0]&nbsp;-&nbsp;edge[0]&nbsp;*&nbsp;va[2]<br>
&nbsp;&nbsp;&nbsp;&nbsp;p1&nbsp;=&nbsp;edge[2]&nbsp;*&nbsp;vb[0]&nbsp;-&nbsp;edge[0]&nbsp;*&nbsp;vb[2]<br>
&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;=&nbsp;hx&nbsp;*&nbsp;abs(edge[2])&nbsp;+&nbsp;hz&nbsp;*&nbsp;abs(edge[0])<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;not&nbsp;(min(p0,&nbsp;p1)&nbsp;&gt;&nbsp;r&nbsp;+&nbsp;_EPSILON&nbsp;or&nbsp;max(p0,&nbsp;p1)&nbsp;&lt;&nbsp;-r&nbsp;-&nbsp;_EPSILON)<br>
<br>
<br>
def&nbsp;_axis_test_z(edge:&nbsp;np.ndarray,&nbsp;va:&nbsp;np.ndarray,&nbsp;vb:&nbsp;np.ndarray,&nbsp;hx:&nbsp;float,&nbsp;hy:&nbsp;float)&nbsp;-&gt;&nbsp;bool:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Тест&nbsp;оси&nbsp;edge&nbsp;×&nbsp;Z.&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;axis&nbsp;=&nbsp;(-edge.y,&nbsp;edge.x,&nbsp;0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;p0&nbsp;=&nbsp;-edge[1]&nbsp;*&nbsp;va[0]&nbsp;+&nbsp;edge[0]&nbsp;*&nbsp;va[1]<br>
&nbsp;&nbsp;&nbsp;&nbsp;p1&nbsp;=&nbsp;-edge[1]&nbsp;*&nbsp;vb[0]&nbsp;+&nbsp;edge[0]&nbsp;*&nbsp;vb[1]<br>
&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;=&nbsp;hx&nbsp;*&nbsp;abs(edge[1])&nbsp;+&nbsp;hy&nbsp;*&nbsp;abs(edge[0])<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;not&nbsp;(min(p0,&nbsp;p1)&nbsp;&gt;&nbsp;r&nbsp;+&nbsp;_EPSILON&nbsp;or&nbsp;max(p0,&nbsp;p1)&nbsp;&lt;&nbsp;-r&nbsp;-&nbsp;_EPSILON)<br>
<br>
<br>
def&nbsp;triangle_aabb(<br>
&nbsp;&nbsp;&nbsp;&nbsp;v0:&nbsp;np.ndarray,<br>
&nbsp;&nbsp;&nbsp;&nbsp;v1:&nbsp;np.ndarray,<br>
&nbsp;&nbsp;&nbsp;&nbsp;v2:&nbsp;np.ndarray,<br>
)&nbsp;-&gt;&nbsp;Tuple[np.ndarray,&nbsp;np.ndarray]:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Вычислить&nbsp;AABB&nbsp;треугольника.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(min_corner,&nbsp;max_corner)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;min_corner&nbsp;=&nbsp;np.minimum(np.minimum(v0,&nbsp;v1),&nbsp;v2)<br>
&nbsp;&nbsp;&nbsp;&nbsp;max_corner&nbsp;=&nbsp;np.maximum(np.maximum(v0,&nbsp;v1),&nbsp;v2)<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;min_corner,&nbsp;max_corner<br>
<!-- END SCAT CODE -->
</body>
</html>
