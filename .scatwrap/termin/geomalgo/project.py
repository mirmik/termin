<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>termin/geomalgo/project.py</title>
</head>
<body>
<!-- BEGIN SCAT CODE -->
import&nbsp;math<br>
from&nbsp;tracemalloc&nbsp;import&nbsp;start<br>
import&nbsp;numpy&nbsp;as&nbsp;np<br>
<br>
def&nbsp;project_point_on_plane(point,&nbsp;plane_point,&nbsp;plane_normal):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Projects&nbsp;a&nbsp;point&nbsp;onto&nbsp;a&nbsp;plane&nbsp;defined&nbsp;by&nbsp;a&nbsp;point&nbsp;and&nbsp;a&nbsp;normal&nbsp;vector.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Parameters:<br>
&nbsp;&nbsp;&nbsp;&nbsp;point&nbsp;(np.array):&nbsp;The&nbsp;3D&nbsp;point&nbsp;to&nbsp;be&nbsp;projected&nbsp;(shape:&nbsp;(3,)).<br>
&nbsp;&nbsp;&nbsp;&nbsp;plane_point&nbsp;(np.array):&nbsp;A&nbsp;point&nbsp;on&nbsp;the&nbsp;plane&nbsp;(shape:&nbsp;(3,)).<br>
&nbsp;&nbsp;&nbsp;&nbsp;plane_normal&nbsp;(np.array):&nbsp;The&nbsp;normal&nbsp;vector&nbsp;of&nbsp;the&nbsp;plane&nbsp;(shape:&nbsp;(3,)).<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;np.array:&nbsp;The&nbsp;projected&nbsp;point&nbsp;on&nbsp;the&nbsp;plane&nbsp;(shape:&nbsp;(3,)).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;point&nbsp;=&nbsp;np.asarray(point)<br>
&nbsp;&nbsp;&nbsp;&nbsp;plane_point&nbsp;=&nbsp;np.asarray(plane_point)<br>
&nbsp;&nbsp;&nbsp;&nbsp;plane_normal&nbsp;=&nbsp;np.asarray(plane_normal)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Normalize&nbsp;the&nbsp;plane&nbsp;normal<br>
&nbsp;&nbsp;&nbsp;&nbsp;plane_normal&nbsp;=&nbsp;plane_normal&nbsp;/&nbsp;np.linalg.norm(plane_normal)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Vector&nbsp;from&nbsp;plane&nbsp;point&nbsp;to&nbsp;the&nbsp;point<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec&nbsp;=&nbsp;point&nbsp;-&nbsp;plane_point<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Distance&nbsp;from&nbsp;the&nbsp;point&nbsp;to&nbsp;the&nbsp;plane&nbsp;along&nbsp;the&nbsp;normal<br>
&nbsp;&nbsp;&nbsp;&nbsp;distance&nbsp;=&nbsp;np.dot(vec,&nbsp;plane_normal)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Projected&nbsp;point&nbsp;calculation<br>
&nbsp;&nbsp;&nbsp;&nbsp;projected_point&nbsp;=&nbsp;point&nbsp;-&nbsp;distance&nbsp;*&nbsp;plane_normal<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;projected_point<br>
<br>
def&nbsp;project_point_on_line(point,&nbsp;line_point,&nbsp;line_direction):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Projects&nbsp;a&nbsp;point&nbsp;onto&nbsp;a&nbsp;line&nbsp;defined&nbsp;by&nbsp;a&nbsp;point&nbsp;and&nbsp;a&nbsp;direction&nbsp;vector.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Parameters:<br>
&nbsp;&nbsp;&nbsp;&nbsp;point&nbsp;(np.array):&nbsp;The&nbsp;3D&nbsp;point&nbsp;to&nbsp;be&nbsp;projected&nbsp;(shape:&nbsp;(3,)).<br>
&nbsp;&nbsp;&nbsp;&nbsp;line_point&nbsp;(np.array):&nbsp;A&nbsp;point&nbsp;on&nbsp;the&nbsp;line&nbsp;(shape:&nbsp;(3,)).<br>
&nbsp;&nbsp;&nbsp;&nbsp;line_direction&nbsp;(np.array):&nbsp;The&nbsp;direction&nbsp;vector&nbsp;of&nbsp;the&nbsp;line&nbsp;(shape:&nbsp;(3,)).<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;np.array:&nbsp;The&nbsp;projected&nbsp;point&nbsp;on&nbsp;the&nbsp;line&nbsp;(shape:&nbsp;(3,)).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;point&nbsp;=&nbsp;np.asarray(point)<br>
&nbsp;&nbsp;&nbsp;&nbsp;line_point&nbsp;=&nbsp;np.asarray(line_point)<br>
&nbsp;&nbsp;&nbsp;&nbsp;line_direction&nbsp;=&nbsp;np.asarray(line_direction)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Normalize&nbsp;the&nbsp;line&nbsp;direction<br>
&nbsp;&nbsp;&nbsp;&nbsp;line_direction&nbsp;=&nbsp;line_direction&nbsp;/&nbsp;np.linalg.norm(line_direction)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Vector&nbsp;from&nbsp;line&nbsp;point&nbsp;to&nbsp;the&nbsp;point<br>
&nbsp;&nbsp;&nbsp;&nbsp;vec&nbsp;=&nbsp;point&nbsp;-&nbsp;line_point<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Projection&nbsp;length&nbsp;along&nbsp;the&nbsp;line&nbsp;direction<br>
&nbsp;&nbsp;&nbsp;&nbsp;projection_length&nbsp;=&nbsp;np.dot(vec,&nbsp;line_direction)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Projected&nbsp;point&nbsp;calculation<br>
&nbsp;&nbsp;&nbsp;&nbsp;projected_point&nbsp;=&nbsp;line_point&nbsp;+&nbsp;projection_length&nbsp;*&nbsp;line_direction<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;projected_point<br>
<br>
def&nbsp;project_point_on_aabb(point,&nbsp;aabb_min,&nbsp;aabb_max):<br>
&nbsp;&nbsp;&nbsp;&nbsp;point&nbsp;=&nbsp;np.asarray(point)<br>
&nbsp;&nbsp;&nbsp;&nbsp;aabb_min&nbsp;=&nbsp;np.asarray(aabb_min)<br>
&nbsp;&nbsp;&nbsp;&nbsp;aabb_max&nbsp;=&nbsp;np.asarray(aabb_max)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;projected_point&nbsp;=&nbsp;np.maximum(aabb_min,&nbsp;np.minimum(point,&nbsp;aabb_max))<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;projected_point<br>
<br>
def&nbsp;found_parameter(t0,&nbsp;t1,&nbsp;value):<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;abs(t1&nbsp;-&nbsp;t0)&nbsp;&lt;&nbsp;1e-12:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;float('inf')<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(value&nbsp;-&nbsp;t0)&nbsp;/&nbsp;(t1&nbsp;-&nbsp;t0)<br>
<br>
def&nbsp;parameter_of_noclamped_segment_projection(point,&nbsp;segment_start,&nbsp;segment_end):<br>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;=&nbsp;np.asarray(segment_start)<br>
&nbsp;&nbsp;&nbsp;&nbsp;B&nbsp;=&nbsp;np.asarray(segment_end)<br>
&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;=&nbsp;np.asarray(point)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;AB&nbsp;=&nbsp;B&nbsp;-&nbsp;A<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;AB_sqr&nbsp;=&nbsp;np.dot(AB,&nbsp;AB)<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;AB_sqr&nbsp;&lt;&nbsp;1e-12:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0.0&nbsp;&nbsp;#&nbsp;Segment&nbsp;is&nbsp;a&nbsp;point<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;AP&nbsp;=&nbsp;P&nbsp;-&nbsp;A&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;t&nbsp;=&nbsp;np.dot(AP,&nbsp;AB)&nbsp;/&nbsp;AB_sqr<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;t<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
def&nbsp;project_segment_on_aabb(segment_start,&nbsp;segment_end,&nbsp;aabb_min,&nbsp;aabb_max):<br>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;=&nbsp;np.asarray(segment_start)<br>
&nbsp;&nbsp;&nbsp;&nbsp;B&nbsp;=&nbsp;np.asarray(segment_end)<br>
&nbsp;&nbsp;&nbsp;&nbsp;Min&nbsp;=&nbsp;np.asarray(aabb_min)<br>
&nbsp;&nbsp;&nbsp;&nbsp;Max&nbsp;=&nbsp;np.asarray(aabb_max)<br>
&nbsp;&nbsp;&nbsp;&nbsp;d&nbsp;=&nbsp;B&nbsp;-&nbsp;A<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;candidates&nbsp;=&nbsp;[]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;rank&nbsp;=&nbsp;len(aabb_max)<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i&nbsp;in&nbsp;range(rank):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t_of_min_intersection&nbsp;=&nbsp;found_parameter(A[i],&nbsp;B[i],&nbsp;Min[i])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t_of_max_intersection&nbsp;=&nbsp;found_parameter(A[i],&nbsp;B[i],&nbsp;Max[i])<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;0&nbsp;&lt;=&nbsp;t_of_min_intersection&nbsp;&lt;=&nbsp;1:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;point_of_min_intersection&nbsp;=&nbsp;A&nbsp;+&nbsp;t_of_min_intersection&nbsp;*&nbsp;d<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;candidates.append(project_point_on_aabb(point_of_min_intersection,&nbsp;Min,&nbsp;Max))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;0&nbsp;&lt;=&nbsp;t_of_max_intersection&nbsp;&lt;=&nbsp;1:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;point_of_max_intersection&nbsp;=&nbsp;A&nbsp;+&nbsp;t_of_max_intersection&nbsp;*&nbsp;d<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;candidates.append(project_point_on_aabb(point_of_max_intersection,&nbsp;Min,&nbsp;Max))<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;min_distance_sq&nbsp;=&nbsp;float('inf')<br>
&nbsp;&nbsp;&nbsp;&nbsp;closest_point_on_segment&nbsp;=&nbsp;None<br>
&nbsp;&nbsp;&nbsp;&nbsp;closest_point_on_aabb&nbsp;=&nbsp;None<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;A_projected&nbsp;=&nbsp;project_point_on_aabb(A,&nbsp;Min,&nbsp;Max)<br>
&nbsp;&nbsp;&nbsp;&nbsp;B_projected&nbsp;=&nbsp;project_point_on_aabb(B,&nbsp;Min,&nbsp;Max)<br>
&nbsp;&nbsp;&nbsp;&nbsp;distance_sq_A&nbsp;=&nbsp;np.sum((A&nbsp;-&nbsp;A_projected)&nbsp;**&nbsp;2)<br>
&nbsp;&nbsp;&nbsp;&nbsp;distance_sq_B&nbsp;=&nbsp;np.sum((B&nbsp;-&nbsp;B_projected)&nbsp;**&nbsp;2)<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;distance_sq_A&nbsp;&lt;&nbsp;distance_sq_B:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min_distance_sq&nbsp;=&nbsp;distance_sq_A<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;closest_point_on_segment&nbsp;=&nbsp;A<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;closest_point_on_aabb&nbsp;=&nbsp;A_projected<br>
&nbsp;&nbsp;&nbsp;&nbsp;else:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min_distance_sq&nbsp;=&nbsp;distance_sq_B<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;closest_point_on_segment&nbsp;=&nbsp;B<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;closest_point_on_aabb&nbsp;=&nbsp;B_projected<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;candidate&nbsp;in&nbsp;candidates:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parameter_of_closest_on_segment&nbsp;=&nbsp;parameter_of_noclamped_segment_projection(candidate,&nbsp;A,&nbsp;B)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;0.0&nbsp;&lt;=&nbsp;parameter_of_closest_on_segment&nbsp;&lt;=&nbsp;1.0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;closest_point_on_segment_candidate&nbsp;=&nbsp;A&nbsp;+&nbsp;parameter_of_closest_on_segment&nbsp;*&nbsp;d<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;distance_sq&nbsp;=&nbsp;np.sum((candidate&nbsp;-&nbsp;closest_point_on_segment_candidate)&nbsp;**&nbsp;2)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;distance_sq&nbsp;&lt;&nbsp;min_distance_sq:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min_distance_sq&nbsp;=&nbsp;distance_sq<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;closest_point_on_segment&nbsp;=&nbsp;closest_point_on_segment_candidate<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;closest_point_on_aabb&nbsp;=&nbsp;candidate<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;closest_point_on_segment,&nbsp;closest_point_on_aabb,&nbsp;math.sqrt(min_distance_sq)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
<br>
def&nbsp;closest_of_aabb_and_capsule(aabb_min,&nbsp;aabb_max,&nbsp;capsule_point1,&nbsp;capsule_point2,&nbsp;capsule_radius):<br>
&nbsp;&nbsp;&nbsp;&nbsp;capsule_core_point,&nbsp;aabb_point,&nbsp;distance&nbsp;=&nbsp;project_segment_on_aabb(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;capsule_point1,&nbsp;capsule_point2,&nbsp;aabb_min,&nbsp;aabb_max<br>
&nbsp;&nbsp;&nbsp;&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;distance&nbsp;&lt;=&nbsp;capsule_radius:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;capsule_core_point,&nbsp;aabb_point,&nbsp;0.0<br>
&nbsp;&nbsp;&nbsp;&nbsp;direction&nbsp;=&nbsp;np.asarray(aabb_point&nbsp;-&nbsp;capsule_core_point,&nbsp;dtype=float)<br>
&nbsp;&nbsp;&nbsp;&nbsp;direction_norm&nbsp;=&nbsp;np.linalg.norm(direction)<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;direction_norm&nbsp;&lt;&nbsp;1e-12:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Capsule&nbsp;core&nbsp;point&nbsp;is&nbsp;inside&nbsp;AABB;&nbsp;choose&nbsp;arbitrary&nbsp;direction<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;direction&nbsp;=&nbsp;np.array([1.0,&nbsp;0.0,&nbsp;0.0])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;direction_norm&nbsp;=&nbsp;1.0<br>
&nbsp;&nbsp;&nbsp;&nbsp;direction&nbsp;=&nbsp;direction&nbsp;/&nbsp;direction_norm<br>
&nbsp;&nbsp;&nbsp;&nbsp;closest_capsule_point&nbsp;=&nbsp;capsule_core_point&nbsp;+&nbsp;direction&nbsp;*&nbsp;capsule_radius<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;aabb_point,&nbsp;closest_capsule_point,&nbsp;distance&nbsp;-&nbsp;capsule_radius<br>
<br>
def&nbsp;closest_of_aabb_and_sphere(aabb_min,&nbsp;aabb_max,&nbsp;sphere_center,&nbsp;sphere_radius):<br>
&nbsp;&nbsp;&nbsp;&nbsp;aabb_point&nbsp;=&nbsp;project_point_on_aabb(sphere_center,&nbsp;aabb_min,&nbsp;aabb_max)<br>
&nbsp;&nbsp;&nbsp;&nbsp;direction&nbsp;=&nbsp;np.asarray(sphere_center&nbsp;-&nbsp;aabb_point,&nbsp;dtype=float)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;print(aabb_max)<br>
&nbsp;&nbsp;&nbsp;&nbsp;print(aabb_min)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;distance&nbsp;=&nbsp;np.linalg.norm(direction)<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;distance&nbsp;&lt;=&nbsp;sphere_radius:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;aabb_point,&nbsp;sphere_center,&nbsp;0.0<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;distance&nbsp;&lt;&nbsp;1e-12:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Sphere&nbsp;center&nbsp;is&nbsp;inside&nbsp;AABB;&nbsp;choose&nbsp;arbitrary&nbsp;direction<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;direction&nbsp;=&nbsp;np.array([1.0,&nbsp;0.0,&nbsp;0.0])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;distance&nbsp;=&nbsp;1.0<br>
&nbsp;&nbsp;&nbsp;&nbsp;direction&nbsp;=&nbsp;direction&nbsp;/&nbsp;distance<br>
&nbsp;&nbsp;&nbsp;&nbsp;closest_sphere_point&nbsp;=&nbsp;sphere_center&nbsp;-&nbsp;direction&nbsp;*&nbsp;sphere_radius<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;aabb_point,&nbsp;closest_sphere_point,&nbsp;distance&nbsp;-&nbsp;sphere_radius<br>
<!-- END SCAT CODE -->
</body>
</html>
