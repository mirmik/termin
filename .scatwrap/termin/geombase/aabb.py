<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>termin/geombase/aabb.py</title>
</head>
<body>
<!-- BEGIN SCAT CODE -->
<br>
import&nbsp;numpy&nbsp;<br>
from&nbsp;weakref&nbsp;import&nbsp;WeakKeyDictionary<br>
from&nbsp;termin.geomalgo.project&nbsp;import&nbsp;project_point_on_aabb,&nbsp;project_segment_on_aabb<br>
<br>
class&nbsp;AABB:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Axis-Aligned&nbsp;Bounding&nbsp;Box&nbsp;in&nbsp;3D&nbsp;space.&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;__init__(self,&nbsp;min_point:&nbsp;numpy.ndarray,&nbsp;max_point:&nbsp;numpy.ndarray):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.min_point&nbsp;=&nbsp;min_point<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.max_point&nbsp;=&nbsp;max_point<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;extend(self,&nbsp;point:&nbsp;numpy.ndarray):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Extend&nbsp;the&nbsp;AABB&nbsp;to&nbsp;include&nbsp;the&nbsp;given&nbsp;point.&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.min_point&nbsp;=&nbsp;numpy.minimum(self.min_point,&nbsp;point)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.max_point&nbsp;=&nbsp;numpy.maximum(self.max_point,&nbsp;point)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;intersects(self,&nbsp;other:&nbsp;&quot;AABB&quot;)&nbsp;-&gt;&nbsp;bool:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Check&nbsp;if&nbsp;this&nbsp;AABB&nbsp;intersects&nbsp;with&nbsp;another&nbsp;AABB.&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;numpy.all(self.max_point&nbsp;&gt;=&nbsp;other.min_point)&nbsp;and&nbsp;numpy.all(other.max_point&nbsp;&gt;=&nbsp;self.min_point)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;__repr__(self):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;f&quot;AABB(min_point={self.min_point},&nbsp;max_point={self.max_point})&quot;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;@staticmethod<br>
&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;from_points(points:&nbsp;numpy.ndarray)&nbsp;-&gt;&nbsp;&quot;AABB&quot;:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Create&nbsp;an&nbsp;AABB&nbsp;that&nbsp;encompasses&nbsp;a&nbsp;set&nbsp;of&nbsp;points.&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min_point&nbsp;=&nbsp;numpy.min(points,&nbsp;axis=0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max_point&nbsp;=&nbsp;numpy.max(points,&nbsp;axis=0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;AABB(min_point,&nbsp;max_point)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;merge(self,&nbsp;other:&nbsp;&quot;AABB&quot;)&nbsp;-&gt;&nbsp;&quot;AABB&quot;:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Merge&nbsp;this&nbsp;AABB&nbsp;with&nbsp;another&nbsp;AABB&nbsp;and&nbsp;return&nbsp;the&nbsp;resulting&nbsp;AABB.&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_min&nbsp;=&nbsp;numpy.minimum(self.min_point,&nbsp;other.min_point)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_max&nbsp;=&nbsp;numpy.maximum(self.max_point,&nbsp;other.max_point)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;AABB(new_min,&nbsp;new_max)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;get_corners_homogeneous(self)&nbsp;-&gt;&nbsp;numpy.ndarray:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Get&nbsp;the&nbsp;8&nbsp;corners&nbsp;of&nbsp;the&nbsp;AABB&nbsp;in&nbsp;homogeneous&nbsp;coordinates.&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;corners&nbsp;=&nbsp;numpy.array([<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[self.min_point[0],&nbsp;self.min_point[1],&nbsp;self.min_point[2],&nbsp;1.0],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[self.min_point[0],&nbsp;self.min_point[1],&nbsp;self.max_point[2],&nbsp;1.0],&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[self.min_point[0],&nbsp;self.max_point[1],&nbsp;self.min_point[2],&nbsp;1.0],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[self.min_point[0],&nbsp;self.max_point[1],&nbsp;self.max_point[2],&nbsp;1.0],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[self.max_point[0],&nbsp;self.min_point[1],&nbsp;self.min_point[2],&nbsp;1.0],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[self.max_point[0],&nbsp;self.min_point[1],&nbsp;self.max_point[2],&nbsp;1.0],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[self.max_point[0],&nbsp;self.max_point[1],&nbsp;self.min_point[2],&nbsp;1.0],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[self.max_point[0],&nbsp;self.max_point[1],&nbsp;self.max_point[2],&nbsp;1.0],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;corners<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;project_point(self,&nbsp;point:&nbsp;numpy.ndarray)&nbsp;-&gt;&nbsp;numpy.ndarray:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Project&nbsp;a&nbsp;point&nbsp;onto&nbsp;the&nbsp;AABB&nbsp;is&nbsp;performed&nbsp;with&nbsp;clamping.&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;numpy.minimum(numpy.maximum(point,&nbsp;self.min_point),&nbsp;self.max_point)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;project_segment_on_aabb(self,&nbsp;seg_start:&nbsp;numpy.ndarray,&nbsp;seg_end:&nbsp;numpy.ndarray):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Project&nbsp;a&nbsp;segment&nbsp;onto&nbsp;the&nbsp;AABB&nbsp;and&nbsp;return&nbsp;the&nbsp;closest&nbsp;points&nbsp;and&nbsp;distance.&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;project_segment_on_aabb(seg_start,&nbsp;seg_end,&nbsp;self.min_point,&nbsp;self.max_point)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
<br>
class&nbsp;TransformAABB:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;AABB&nbsp;associated&nbsp;with&nbsp;a&nbsp;Transform.&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;transform_to_taabb_map&nbsp;=&nbsp;WeakKeyDictionary()<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;__init__(self,&nbsp;transform:&nbsp;'Transform',&nbsp;aabb:&nbsp;AABB):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._transform&nbsp;=&nbsp;transform<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._my_aabb&nbsp;=&nbsp;aabb<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._my_world_aabb&nbsp;=&nbsp;None<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._compiled_aabb&nbsp;=&nbsp;None<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._last_inspected_version&nbsp;=&nbsp;-1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._last_tree_inspected_version&nbsp;=&nbsp;-1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TransformAABB.transform_to_taabb_map[transform]&nbsp;=&nbsp;self<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;compile_tree_aabb(self)&nbsp;-&gt;&nbsp;AABB:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;self._last_tree_inspected_version&nbsp;==&nbsp;self._transform._version_for_walking_to_distal:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;self._compiled_aabb<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;self.get_world_aabb()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;child&nbsp;in&nbsp;self._transform.children:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;child_taabb&nbsp;=&nbsp;TransformAABB.transform_to_taabb_map.get(child)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;child_taabb:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;child_aabb&nbsp;=&nbsp;child_taabb.compile_tree_aabb()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;result.merge(child_aabb)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._compiled_aabb&nbsp;=&nbsp;result<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._last_tree_inspected_version&nbsp;=&nbsp;self._transform._version_for_walking_to_distal<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;self._compiled_aabb<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;get_world_aabb(self)&nbsp;-&gt;&nbsp;AABB:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;Get&nbsp;the&nbsp;AABB&nbsp;widened&nbsp;by&nbsp;the&nbsp;rotation&nbsp;of&nbsp;the&nbsp;transform.&quot;&quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;self._last_inspected_version&nbsp;==&nbsp;self._transform._version_only_my:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;self._my_world_aabb<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matrix&nbsp;=&nbsp;self._transform.global_pose().as_matrix34()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;corners&nbsp;=&nbsp;self._my_aabb.get_corners_homogeneous()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transformed_corners&nbsp;=&nbsp;numpy.dot(matrix,&nbsp;corners.T).T<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_aabb&nbsp;=&nbsp;AABB.from_points(transformed_corners)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._my_world_aabb&nbsp;=&nbsp;new_aabb<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new_aabb<br>
<!-- END SCAT CODE -->
</body>
</html>
